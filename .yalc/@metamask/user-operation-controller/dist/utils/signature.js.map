{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../src/utils/signature.ts"],"names":[],"mappings":";AAAA,kEAAkE;;;;;;;;;;;;AAElE,gDAAgD;AAEhD,kDAA+C;AAC/C,wDAAqD;AACrD,4CAAqD;AAErD,SAAsB,iBAAiB,CACrC,aAA4B,EAC5B,iBAAyB,EACzB,OAAe,EACf,UAAkB;;QAElB,MAAM,IAAI,GAAG,oBAAoB,CAAC,aAAa,EAAE,iBAAiB,EAAE,OAAO,CAAC,CAAC;QAC7E,MAAM,OAAO,GAAG,IAAA,gBAAQ,EAAC,IAAI,CAAC,CAAC;QAC/B,MAAM,MAAM,GAAG,IAAI,eAAM,CAAC,UAAU,CAAC,CAAC;QAEtC,OAAO,MAAM,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IAC3C,CAAC;CAAA;AAXD,8CAWC;AAED,SAAS,oBAAoB,CAC3B,aAA4B,EAC5B,iBAAyB,EACzB,OAAe;IAEf,MAAM,cAAc,GAAG,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;IAC7C,MAAM,IAAI,GAAG,IAAA,qBAAS,EAAC,6BAA6B,CAAC,aAAa,CAAC,CAAC,CAAC;IAErE,MAAM,IAAI,GAAG,qBAAe,CAAC,MAAM,CACjC,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EACjC,CAAC,IAAI,EAAE,iBAAiB,EAAE,cAAc,CAAC,CAC1C,CAAC;IAEF,OAAO,IAAA,qBAAS,EAAC,IAAI,CAAC,CAAC;AACzB,CAAC;AAED,SAAS,6BAA6B,CACpC,aAA4B;IAE5B,OAAO,qBAAe,CAAC,MAAM,CAC3B;QACE,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;KACV,EACD;QACE,aAAa,CAAC,MAAM;QACpB,aAAa,CAAC,KAAK;QACnB,IAAA,qBAAS,EAAC,aAAa,CAAC,QAAQ,CAAC;QACjC,IAAA,qBAAS,EAAC,aAAa,CAAC,QAAQ,CAAC;QACjC,aAAa,CAAC,YAAY;QAC1B,aAAa,CAAC,oBAAoB;QAClC,aAAa,CAAC,kBAAkB;QAChC,aAAa,CAAC,YAAY;QAC1B,aAAa,CAAC,oBAAoB;QAClC,IAAA,qBAAS,EAAC,aAAa,CAAC,gBAAgB,CAAC;KAC1C,CACF,CAAC;AACJ,CAAC","sourcesContent":["// Temporary until new keyring is available via KeyringController.\n\nimport { arrayify } from '@ethersproject/bytes';\nimport { UserOperation } from '../types';\nimport { Wallet } from '@ethersproject/wallet';\nimport { keccak256 } from '@ethersproject/keccak256';\nimport { defaultAbiCoder } from '@ethersproject/abi';\n\nexport async function signUserOperation(\n  userOperation: UserOperation,\n  entrypointAddress: string,\n  chainId: string,\n  privateKey: string,\n): Promise<string> {\n  const hash = getUserOperationHash(userOperation, entrypointAddress, chainId);\n  const message = arrayify(hash);\n  const signer = new Wallet(privateKey);\n\n  return await signer.signMessage(message);\n}\n\nfunction getUserOperationHash(\n  userOperation: UserOperation,\n  entrypointAddress: string,\n  chainId: string,\n): string {\n  const chainIdDecimal = parseInt(chainId, 16);\n  const hash = keccak256(encodeUserOperationForSigning(userOperation));\n\n  const data = defaultAbiCoder.encode(\n    ['bytes32', 'address', 'uint256'],\n    [hash, entrypointAddress, chainIdDecimal],\n  );\n\n  return keccak256(data);\n}\n\nfunction encodeUserOperationForSigning(\n  userOperation: UserOperation,\n): string {\n  return defaultAbiCoder.encode(\n    [\n      'address',\n      'uint256',\n      'bytes32',\n      'bytes32',\n      'uint256',\n      'uint256',\n      'uint256',\n      'uint256',\n      'uint256',\n      'bytes32',\n    ],\n    [\n      userOperation.sender,\n      userOperation.nonce,\n      keccak256(userOperation.initCode),\n      keccak256(userOperation.callData),\n      userOperation.callGasLimit,\n      userOperation.verificationGasLimit,\n      userOperation.preVerificationGas,\n      userOperation.maxFeePerGas,\n      userOperation.maxPriorityFeePerGas,\n      keccak256(userOperation.paymasterAndData),\n    ],\n  );\n}\n"]}