{"version":3,"file":"validation.js","sourceRoot":"","sources":["../../src/utils/validation.ts"],"names":[],"mappings":"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","sourcesContent":["import { TransactionType } from '@metamask/transaction-controller';\nimport { isStrictHexString } from '@metamask/utils';\nimport type { Struct, StructError } from 'superstruct';\nimport {\n  assert,\n  boolean,\n  define,\n  enums,\n  func,\n  number,\n  object,\n  optional,\n  refine,\n  string,\n} from 'superstruct';\n\nimport { EMPTY_BYTES } from '../constants';\nimport type {\n  PrepareUserOperationResponse,\n  SignUserOperationResponse,\n  UpdateUserOperationResponse,\n} from '../types';\nimport type {\n  AddUserOperationOptions,\n  AddUserOperationRequest,\n} from '../UserOperationController';\n\n/**\n * Validate a request to add a user operation.\n * @param request - The request to validate.\n */\nexport function validateAddUserOperationRequest(\n  request: AddUserOperationRequest,\n) {\n  const Hex = defineHex();\n  const HexOrEmptyBytes = defineHexOrEmptyBytes();\n\n  const ValidRequest = object({\n    data: optional(HexOrEmptyBytes),\n    maxFeePerGas: Hex,\n    maxPriorityFeePerGas: Hex,\n    to: optional(Hex),\n    value: optional(Hex),\n  });\n\n  validate(request, ValidRequest, 'Invalid request to add user operation');\n}\n\n/**\n * Validate the options when adding a user operation.\n * @param options - The options to validate.\n */\nexport function validateAddUserOperationOptions(\n  options: AddUserOperationOptions,\n) {\n  const ValidOptions = object({\n    networkClientId: string(),\n    origin: string(),\n    requireApproval: optional(boolean()),\n    smartContractAccount: object({\n      prepareUserOperation: func(),\n      updateUserOperation: func(),\n      signUserOperation: func(),\n    }),\n    swaps: optional(\n      object({\n        approvalTxId: optional(string()),\n        destinationTokenAddress: optional(string()),\n        destinationTokenDecimals: optional(number()),\n        destinationTokenSymbol: optional(string()),\n        estimatedBaseFee: optional(string()),\n        sourceTokenSymbol: optional(string()),\n        swapMetaData: optional(object()),\n        swapTokenValue: optional(string()),\n      }),\n    ),\n    type: optional(enums(Object.values(TransactionType))),\n  });\n\n  validate(options, ValidOptions, 'Invalid options to add user operation');\n}\n\n/**\n * Validate the response from a smart contract account when preparing the user operation.\n * @param response - The response to validate.\n */\nexport function validatePrepareUserOperationResponse(\n  response: PrepareUserOperationResponse,\n) {\n  const Hex = defineHex();\n  const HexOrEmptyBytes = defineHexOrEmptyBytes();\n\n  const ValidResponse = refine(\n    object({\n      bundler: string(),\n      callData: Hex,\n      dummyPaymasterAndData: optional(HexOrEmptyBytes),\n      dummySignature: optional(HexOrEmptyBytes),\n      gas: optional(\n        object({\n          callGasLimit: Hex,\n          preVerificationGas: Hex,\n          verificationGasLimit: Hex,\n        }),\n      ),\n      initCode: optional(HexOrEmptyBytes),\n      nonce: Hex,\n      sender: Hex,\n    }),\n    'ValidPrepareUserOperationResponse',\n    ({ gas, dummySignature }) => {\n      if (!gas && (!dummySignature || dummySignature === EMPTY_BYTES)) {\n        return 'Must specify dummySignature if not specifying gas';\n      }\n\n      /* istanbul ignore next */\n      return true;\n    },\n  );\n\n  validate(\n    response,\n    ValidResponse,\n    'Invalid response when preparing user operation',\n  );\n}\n\n/**\n * Validate the response from a smart contract account when updating the user operation.\n * @param response - The response to validate.\n */\nexport function validateUpdateUserOperationResponse(\n  response: UpdateUserOperationResponse,\n) {\n  const HexOrEmptyBytes = defineHex();\n\n  const ValidResponse = optional(\n    object({\n      paymasterAndData: optional(HexOrEmptyBytes),\n    }),\n  );\n\n  validate(\n    response,\n    ValidResponse,\n    'Invalid response when updating user operation',\n  );\n}\n\n/**\n * Validate the response from a smart contract account when signing the user operation.\n * @param response - The response to validate.\n */\nexport function validateSignUserOperationResponse(\n  response: SignUserOperationResponse,\n) {\n  const Hex = defineHex();\n\n  const ValidResponse = object({\n    signature: Hex,\n  });\n\n  validate(\n    response,\n    ValidResponse,\n    'Invalid response when signing user operation',\n  );\n}\n\n/**\n * Validate data against a struct.\n * @param data - The data to validate.\n * @param struct - The struct to validate against.\n * @param message - The message to throw if validation fails.\n */\nfunction validate<T>(data: unknown, struct: Struct<T>, message: string) {\n  try {\n    assert(data, struct, message);\n  } catch (error) {\n    const causes = (error as StructError)\n      .failures()\n      .map((failure) => {\n        if (!failure.path.length) {\n          return failure.message;\n        }\n\n        return `${failure.path.join('.')} - ${failure.message}`;\n      })\n      .join('\\n');\n\n    const finalMessage = `${message}\\n${causes}`;\n\n    throw new Error(finalMessage);\n  }\n}\n\n/**\n * Define the Hex type used by superstruct.\n * @returns The Hex superstruct type.\n */\nfunction defineHex() {\n  return define<string>('Hexadecimal String', (value) =>\n    isStrictHexString(value),\n  );\n}\n\n/**\n * Define the HexOrEmptyBytes type used by superstruct.\n * @returns The HexOrEmptyBytes superstruct type.\n */\nfunction defineHexOrEmptyBytes() {\n  return define<string>(\n    'Hexadecimal String or 0x',\n    (value) => isStrictHexString(value) || value === EMPTY_BYTES,\n  );\n}\n"]}