{"version":3,"file":"validation.js","sourceRoot":"","sources":["../../src/utils/validation.ts"],"names":[],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi';\nimport { ORIGIN_METAMASK, isValidHexAddress } from '@metamask/controller-utils';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { TransactionEnvelopeType, type TransactionParams } from '../types';\nimport { isEIP1559Transaction } from './utils';\n\ntype GasFieldsToValidate = 'gasPrice' | 'maxFeePerGas' | 'maxPriorityFeePerGas';\n\n/**\n * Validates whether a transaction initiated by a specific 'from' address is permitted by the origin.\n *\n * @param permittedAddresses - The permitted accounts for the given origin.\n * @param selectedAddress - The currently selected Ethereum address in the wallet.\n * @param from - The address from which the transaction is initiated.\n * @param origin - The origin or source of the transaction.\n * @throws Throws an error if the transaction is not permitted.\n */\nexport async function validateTransactionOrigin(\n  permittedAddresses: string[],\n  selectedAddress: string,\n  from: string,\n  origin: string,\n) {\n  if (origin === ORIGIN_METAMASK) {\n    // Ensure the 'from' address matches the currently selected address\n    if (from !== selectedAddress) {\n      throw rpcErrors.internal({\n        message: `Internally initiated transaction is using invalid account.`,\n        data: {\n          origin,\n          fromAddress: from,\n          selectedAddress,\n        },\n      });\n    }\n    return;\n  }\n\n  // Check if the origin has permissions to initiate transactions from the specified address\n  if (!permittedAddresses.includes(from)) {\n    throw providerErrors.unauthorized({ data: { origin } });\n  }\n}\n\n/**\n * Validates the transaction params for required properties and throws in\n * the event of any validation error.\n *\n * @param txParams - Transaction params object to validate.\n * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.\n */\nexport function validateTxParams(\n  txParams: TransactionParams,\n  isEIP1559Compatible = true,\n) {\n  validateEIP1559Compatibility(txParams, isEIP1559Compatible);\n  validateParamFrom(txParams.from);\n  validateParamRecipient(txParams);\n  validateParamValue(txParams.value);\n  validateParamData(txParams.data);\n  validateParamChainId(txParams.chainId);\n  validateGasFeeParams(txParams);\n}\n\n/**\n * Validates EIP-1559 compatibility for transaction creation.\n *\n * @param txParams - The transaction parameters to validate.\n * @param isEIP1559Compatible - Indicates if the current network supports EIP-1559.\n * @throws Throws invalid params if the transaction specifies EIP-1559 but the network does not support it.\n */\nfunction validateEIP1559Compatibility(\n  txParams: TransactionParams,\n  isEIP1559Compatible: boolean,\n) {\n  if (isEIP1559Transaction(txParams) && !isEIP1559Compatible) {\n    throw rpcErrors.invalidParams(\n      'Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559',\n    );\n  }\n}\n\n/**\n * Validates value property, ensuring it is a valid positive integer number\n * denominated in wei.\n *\n * @param value - The value to validate, expressed as a string.\n * @throws Throws an error if the value is not a valid positive integer\n * number denominated in wei.\n * - If the value contains a hyphen (-), it is considered invalid.\n * - If the value contains a decimal point (.), it is considered invalid.\n * - If the value is not a finite number, is NaN, or is not a safe integer, it is considered invalid.\n */\nfunction validateParamValue(value?: string) {\n  if (value !== undefined) {\n    if (value.includes('-')) {\n      throw rpcErrors.invalidParams(\n        `Invalid transaction value \"${value}\": not a positive number.`,\n      );\n    }\n\n    if (value.includes('.')) {\n      throw rpcErrors.invalidParams(\n        `Invalid transaction value \"${value}\": number must be in wei.`,\n      );\n    }\n    const intValue = parseInt(value, 10);\n    const isValid =\n      Number.isFinite(intValue) &&\n      !Number.isNaN(intValue) &&\n      !isNaN(Number(value)) &&\n      Number.isSafeInteger(intValue);\n    if (!isValid) {\n      throw rpcErrors.invalidParams(\n        `Invalid transaction value ${value}: number must be a valid number.`,\n      );\n    }\n  }\n}\n\n/**\n * Validates the recipient address in a transaction's parameters.\n *\n * @param txParams - The transaction parameters object to validate.\n * @throws Throws an error if the recipient address is invalid:\n * - If the recipient address is an empty string ('0x') or undefined and the transaction contains data,\n * the \"to\" field is removed from the transaction parameters.\n * - If the recipient address is not a valid hexadecimal Ethereum address, an error is thrown.\n */\nfunction validateParamRecipient(txParams: TransactionParams) {\n  if (txParams.to === '0x' || txParams.to === undefined) {\n    if (txParams.data) {\n      delete txParams.to;\n    } else {\n      throw rpcErrors.invalidParams(`Invalid \"to\" address.`);\n    }\n  } else if (txParams.to !== undefined && !isValidHexAddress(txParams.to)) {\n    throw rpcErrors.invalidParams(`Invalid \"to\" address.`);\n  }\n}\n\n/**\n * Validates the recipient address in a transaction's parameters.\n *\n * @param from - The from property to validate.\n * @throws Throws an error if the recipient address is invalid:\n * - If the recipient address is an empty string ('0x') or undefined and the transaction contains data,\n * the \"to\" field is removed from the transaction parameters.\n * - If the recipient address is not a valid hexadecimal Ethereum address, an error is thrown.\n */\nfunction validateParamFrom(from: string) {\n  if (!from || typeof from !== 'string') {\n    throw rpcErrors.invalidParams(\n      `Invalid \"from\" address ${from}: not a string.`,\n    );\n  }\n  if (!isValidHexAddress(from)) {\n    throw rpcErrors.invalidParams('Invalid \"from\" address.');\n  }\n}\n\n/**\n * Validates input data for transactions.\n *\n * @param value - The input data to validate.\n * @throws Throws invalid params if the input data is invalid.\n */\nfunction validateParamData(value?: string) {\n  if (value) {\n    const ERC20Interface = new Interface(abiERC20);\n    try {\n      ERC20Interface.parseTransaction({ data: value });\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.message.match(/BUFFER_OVERRUN/u)) {\n        throw rpcErrors.invalidParams(\n          'Invalid transaction params: data out-of-bounds, BUFFER_OVERRUN.',\n        );\n      }\n    }\n  }\n}\n\n/**\n * Validates chainId type.\n *\n * @param chainId - The chainId to validate.\n */\nfunction validateParamChainId(chainId: number | string | undefined) {\n  if (\n    chainId !== undefined &&\n    typeof chainId !== 'number' &&\n    typeof chainId !== 'string'\n  ) {\n    throw rpcErrors.invalidParams(\n      `Invalid transaction params: chainId is not a Number or hex string. got: (${chainId})`,\n    );\n  }\n}\n\n/**\n * Validates gas values.\n *\n * @param txParams - The transaction parameters to validate.\n */\nfunction validateGasFeeParams(txParams: TransactionParams) {\n  if (txParams.gasPrice) {\n    ensureProperTransactionEnvelopeTypeProvided(txParams, 'gasPrice');\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'gasPrice',\n      'maxFeePerGas',\n    );\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'gasPrice',\n      'maxPriorityFeePerGas',\n    );\n    ensureFieldIsString(txParams, 'gasPrice');\n  }\n\n  if (txParams.maxFeePerGas) {\n    ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxFeePerGas');\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'maxFeePerGas',\n      'gasPrice',\n    );\n    ensureFieldIsString(txParams, 'maxFeePerGas');\n  }\n\n  if (txParams.maxPriorityFeePerGas) {\n    ensureProperTransactionEnvelopeTypeProvided(\n      txParams,\n      'maxPriorityFeePerGas',\n    );\n    ensureMutuallyExclusiveFieldsNotProvided(\n      txParams,\n      'maxPriorityFeePerGas',\n      'gasPrice',\n    );\n    ensureFieldIsString(txParams, 'maxPriorityFeePerGas');\n  }\n}\n\n/**\n * Ensures that the provided txParams has the proper 'type' specified for the\n * given field, if it is provided. If types do not match throws an\n * invalidParams error.\n *\n * @param txParams - The transaction parameters object\n * @param field - The current field being validated\n * @throws {ethErrors.rpc.invalidParams} Throws if type does not match the\n * expectations for provided field.\n */\nfunction ensureProperTransactionEnvelopeTypeProvided(\n  txParams: TransactionParams,\n  field: GasFieldsToValidate,\n) {\n  switch (field) {\n    case 'maxFeePerGas':\n    case 'maxPriorityFeePerGas':\n      if (\n        txParams.type &&\n        txParams.type !== TransactionEnvelopeType.feeMarket\n      ) {\n        throw rpcErrors.invalidParams(\n          `Invalid transaction envelope type: specified type \"${txParams.type}\" but including maxFeePerGas and maxPriorityFeePerGas requires type: \"${TransactionEnvelopeType.feeMarket}\"`,\n        );\n      }\n      break;\n    case 'gasPrice':\n    default:\n      if (\n        txParams.type &&\n        txParams.type === TransactionEnvelopeType.feeMarket\n      ) {\n        throw rpcErrors.invalidParams(\n          `Invalid transaction envelope type: specified type \"${txParams.type}\" but included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas`,\n        );\n      }\n  }\n}\n\n/**\n * Given two fields, ensure that the second field is not included in txParams,\n * and if it is throw an invalidParams error.\n *\n * @param txParams - The transaction parameters object\n * @param fieldBeingValidated - The current field being validated\n * @param mutuallyExclusiveField - The field to ensure is not provided\n * @throws {ethErrors.rpc.invalidParams} Throws if mutuallyExclusiveField is\n * present in txParams.\n */\nfunction ensureMutuallyExclusiveFieldsNotProvided(\n  txParams: TransactionParams,\n  fieldBeingValidated: GasFieldsToValidate,\n  mutuallyExclusiveField: GasFieldsToValidate,\n) {\n  if (typeof txParams[mutuallyExclusiveField] !== 'undefined') {\n    throw rpcErrors.invalidParams(\n      `Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`,\n    );\n  }\n}\n\n/**\n * Ensures that the provided value for field is a string, throws an\n * invalidParams error if field is not a string.\n *\n * @param txParams - The transaction parameters object\n * @param field - The current field being validated\n * @throws {rpcErrors.invalidParams} Throws if field is not a string\n */\nfunction ensureFieldIsString(\n  txParams: TransactionParams,\n  field: GasFieldsToValidate,\n) {\n  if (typeof txParams[field] !== 'string') {\n    throw rpcErrors.invalidParams(\n      `Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`,\n    );\n  }\n}\n"]}