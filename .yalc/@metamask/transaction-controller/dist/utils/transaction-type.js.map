{"version":3,"file":"transaction-type.js","sourceRoot":"","sources":["../../src/utils/transaction-type.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TransactionDescription } from '@ethersproject/abi';\nimport { Interface } from '@ethersproject/abi';\nimport { query } from '@metamask/controller-utils';\nimport type EthQuery from '@metamask/eth-query';\nimport { abiERC721, abiERC20, abiERC1155 } from '@metamask/metamask-eth-abis';\n\nimport type { InferTransactionTypeResult, TransactionParams } from '../types';\nimport { TransactionType } from '../types';\n\nexport const ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';\n\nconst ERC20Interface = new Interface(abiERC20);\nconst ERC721Interface = new Interface(abiERC721);\nconst ERC1155Interface = new Interface(abiERC1155);\n\n/**\n * Determines the type of the transaction by analyzing the txParams.\n * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these\n * represent specific events that we specify manually at transaction creation.\n *\n * @param txParams - Parameters for the transaction.\n * @param ethQuery - EthQuery instance.\n * @returns A object with the transaction type and the contract code response in Hex.\n */\nexport async function determineTransactionType(\n  txParams: TransactionParams,\n  ethQuery: EthQuery,\n): Promise<InferTransactionTypeResult> {\n  const { data, to } = txParams;\n\n  if (data && !to) {\n    return { type: TransactionType.deployContract, getCodeResponse: undefined };\n  }\n\n  const { contractCode: getCodeResponse, isContractAddress } =\n    await readAddressAsContract(ethQuery, to);\n\n  if (!isContractAddress) {\n    return { type: TransactionType.simpleSend, getCodeResponse };\n  }\n\n  const hasValue = Number(txParams.value ?? '0') !== 0;\n\n  const contractInteractionResult = {\n    type: TransactionType.contractInteraction,\n    getCodeResponse,\n  };\n\n  if (!data || hasValue) {\n    return contractInteractionResult;\n  }\n\n  const name = parseStandardTokenTransactionData(data)?.name;\n\n  if (!name) {\n    return contractInteractionResult;\n  }\n\n  const tokenMethodName = [\n    TransactionType.tokenMethodApprove,\n    TransactionType.tokenMethodSetApprovalForAll,\n    TransactionType.tokenMethodTransfer,\n    TransactionType.tokenMethodTransferFrom,\n    TransactionType.tokenMethodSafeTransferFrom,\n  ].find((methodName) => methodName.toLowerCase() === name.toLowerCase());\n\n  if (tokenMethodName) {\n    return { type: tokenMethodName, getCodeResponse };\n  }\n\n  return contractInteractionResult;\n}\n\n/**\n * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.\n * The data will decode correctly if the transaction is an interaction with a contract that matches one of these\n * contract standards\n *\n * @param data - Encoded transaction data.\n * @returns A representation of an ethereum contract call.\n */\nfunction parseStandardTokenTransactionData(\n  data?: string,\n): TransactionDescription | undefined {\n  if (!data) {\n    return undefined;\n  }\n\n  try {\n    return ERC20Interface.parseTransaction({ data });\n  } catch {\n    // ignore and next try to parse with erc721 ABI\n  }\n\n  try {\n    return ERC721Interface.parseTransaction({ data });\n  } catch {\n    // ignore and next try to parse with erc1155 ABI\n  }\n\n  try {\n    return ERC1155Interface.parseTransaction({ data });\n  } catch {\n    // ignore and return undefined\n  }\n\n  return undefined;\n}\n\n/**\n * Reads an Ethereum address and determines if it is a contract address.\n *\n * @param ethQuery - The Ethereum query object used to interact with the Ethereum blockchain.\n * @param address - The Ethereum address.\n * @returns An object containing the contract code and a boolean indicating if it is a contract address.\n */\nasync function readAddressAsContract(\n  ethQuery: EthQuery,\n  address?: string,\n): Promise<{\n  contractCode: string | null;\n  isContractAddress: boolean;\n}> {\n  let contractCode;\n  try {\n    contractCode = await query(ethQuery, 'getCode', [address]);\n  } catch (e) {\n    contractCode = null;\n  }\n\n  const isContractAddress = contractCode\n    ? contractCode !== '0x' && contractCode !== '0x0'\n    : false;\n  return { contractCode, isContractAddress };\n}\n"]}