diff --git a/node_modules/@metamask/eth-ledger-bridge-keyring/index.js b/node_modules/@metamask/eth-ledger-bridge-keyring/index.js
index 2c6a7de..c7f331a 100644
--- a/node_modules/@metamask/eth-ledger-bridge-keyring/index.js
+++ b/node_modules/@metamask/eth-ledger-bridge-keyring/index.js
@@ -20,6 +20,10 @@ const NETWORK_API_URLS = {
 
 const CONNECTION_EVENT = 'ledger-connection-change'
 
+// A function that sleeps for x ms
+const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
+
+
 class LedgerBridgeKeyring extends EventEmitter {
   constructor (opts = {}) {
     super()
@@ -34,29 +38,51 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.iframe = null
     this.network = 'mainnet'
     this.implementFullBIP44 = false
+    this.delayedPromises = [];
     this.deserialize(opts)
 
     this.iframeLoaded = false
-    this._setupIframe()
-
     this.currentMessageId = 0
     this.messageCallbacks = {}
+
+    if(!opts.delayInit){
+      this.init();
+    }
+  }
+
+  init(opts){
+    this._setupIframe()
     this._setupListener()
+    return this.updateTransportMethod('webhid');
   }
 
   serialize () {
     return Promise.resolve({
+      hdk: this.isUnlocked() ? {
+        publicKey: this.hdk.publicKey.toString('hex'),
+        chainCode: this.hdk.chainCode.toString('hex'),
+      } : null,
       hdPath: this.hdPath,
       accounts: this.accounts,
+      page: this.page,
       accountDetails: this.accountDetails,
       bridgeUrl: this.bridgeUrl,
       implementFullBIP44: false,
+      unlockedAccount: this.unlockedAccount,
     })
   }
 
   deserialize (opts = {}) {
+    console.log('Updating ledger state', opts);
+
+    if(opts.hdk){
+      this.setHdk(opts.hdk);
+    }
+
     this.hdPath = opts.hdPath || hdPathString
+    this.page = opts.page || 0
     this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
+    this.unlockedAccount = opts.unlockedAccount || 0;
     this.accounts = opts.accounts || []
     this.accountDetails = opts.accountDetails || {}
     if (!opts.accountDetails) {
@@ -99,6 +125,11 @@ class LedgerBridgeKeyring extends EventEmitter {
     }
   }
 
+  setHdk ({ publicKey, chainCode }) {
+    this.hdk.publicKey = Buffer.from(publicKey, 'hex')
+    this.hdk.chainCode = Buffer.from(chainCode, 'hex')
+  }
+
   isUnlocked () {
     return Boolean(this.hdk && this.hdk.publicKey)
   }
@@ -119,12 +150,16 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.hdPath = hdPath
   }
 
-  unlock (hdPath, updateHdk = true) {
+  async unlock (hdPath, updateHdk = true) {
     if (this.isUnlocked() && !hdPath) {
       return Promise.resolve('already unlocked')
     }
+
     const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
-    return new Promise((resolve, reject) => {
+
+    await sleep(10000);
+
+    return new Promise(async (resolve, reject) => {
       this._sendMessage({
         action: 'ledger-unlock',
         params: {
@@ -133,15 +168,18 @@ class LedgerBridgeKeyring extends EventEmitter {
       },
       ({ success, payload }) => {
         if (success) {
-          if (updateHdk) {
-            this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
-            this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
+          if(updateHdk) {
+            this.setHdk(payload);
           }
           resolve(payload.address)
         } else {
           reject(payload.error || new Error('Unknown error'))
         }
       })
+
+      await sleep(10000);
+
+      reject('timeout');
     })
   }
 
@@ -222,11 +260,11 @@ class LedgerBridgeKeyring extends EventEmitter {
       // If the iframe isn't loaded yet, let's store the desired transportType value and
       // optimistically return a successful promise
       if (!this.iframeLoaded) {
-        this.delayedPromise = {
+        this.delayedPromises.push({
           resolve,
           reject,
           transportType,
-        }
+        })
         return
       }
 
@@ -235,6 +273,7 @@ class LedgerBridgeKeyring extends EventEmitter {
         params: { transportType },
       }, ({ success }) => {
         if (success) {
+          console.log(`Ledger transport method updated to ${transportType}`);
           resolve(true)
         } else {
           reject(new Error('Ledger transport could not be updated'))
@@ -336,11 +375,14 @@ class LedgerBridgeKeyring extends EventEmitter {
   }
 
   // For personal_sign, we need to prefix the message:
-  signPersonalMessage (withAccount, message) {
-    return new Promise((resolve, reject) => {
-      this.unlockAccountByAddress(withAccount)
-        .then((hdPath) => {
-          this._sendMessage({
+  async signPersonalMessage (withAccount, message) {
+
+    try {
+      const hdPath = await this.unlockAccountByAddress(withAccount);
+
+
+      return new Promise((resolve, reject) => {
+        this._sendMessage({
             action: 'ledger-sign-personal-message',
             params: {
               hdPath,
@@ -348,6 +390,7 @@ class LedgerBridgeKeyring extends EventEmitter {
             },
           },
           ({ success, payload }) => {
+
             if (success) {
               let v = payload.v - 27
               v = v.toString(16)
@@ -364,9 +407,14 @@ class LedgerBridgeKeyring extends EventEmitter {
               reject(payload.error || new Error('Ledger: Unknown error while signing message'))
             }
           })
-        })
-        .catch(reject)
-    })
+
+        sleep(1000);
+      });
+
+
+    } catch (e) {
+      throw e;
+    }
   }
 
   async unlockAccountByAddress (address) {
@@ -455,18 +503,14 @@ class LedgerBridgeKeyring extends EventEmitter {
       // If the ledger live preference was set before the iframe is loaded,
       // set it after the iframe has loaded
       this.iframeLoaded = true
-      if (this.delayedPromise) {
-        try {
-          const result = await this.updateTransportMethod(
-            this.delayedPromise.transportType,
-          )
-          this.delayedPromise.resolve(result)
-        } catch (e) {
-          this.delayedPromise.reject(e)
-        } finally {
-          delete this.delayedPromise
-        }
+
+      for (const delayedPromise of this.delayedPromises) {
+        this.updateTransportMethod(delayedPromise.transportType)
+          .then((res) => delayedPromise.resolve(res))
+          .catch(e => delayedPromise.reject(e))
       }
+
+      this.delayedPromises = [];
     }
     document.head.appendChild(this.iframe)
   }
