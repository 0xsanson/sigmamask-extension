diff --git a/index.js b/index.js
index 2c6a7def1a0320c7928e5fdafcc7fdcdbc44432b..f8fe3b37944fcb4bb7c1613b02e27433c483f825 100644
--- a/index.js
+++ b/index.js
@@ -19,6 +19,15 @@ const NETWORK_API_URLS = {
 }

 const CONNECTION_EVENT = 'ledger-connection-change'
+const TIMEOUT_DURATION_MS = 10 * 1000
+
+/**
+ * A promise that resolves in x milliseconds
+ *
+ * @param {number} ms
+ * @returns {Promise<number>}
+ */
+const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

 class LedgerBridgeKeyring extends EventEmitter {
   constructor (opts = {}) {
@@ -29,6 +38,7 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.page = 0
     this.perPage = 5
     this.unlockedAccount = 0
+    this.delayedPromises = []
     this.hdk = new HDKey()
     this.paths = {}
     this.iframe = null
@@ -37,26 +47,45 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.deserialize(opts)

     this.iframeLoaded = false
-    this._setupIframe()

     this.currentMessageId = 0
     this.messageCallbacks = {}
+
+    if(!opts.delayInit){
+      this.init();
+    }
+  }
+
+  init(opts){
+    this._setupIframe()
     this._setupListener()
   }

   serialize () {
     return Promise.resolve({
+      hdk: this.isUnlocked() ? {
+        publicKey: this.hdk.publicKey.toString('hex'),
+        chainCode: this.hdk.chainCode.toString('hex'),
+      } : null,
       hdPath: this.hdPath,
+      page: this.page,
       accounts: this.accounts,
       accountDetails: this.accountDetails,
       bridgeUrl: this.bridgeUrl,
       implementFullBIP44: false,
+      unlockedAccount: this.unlockedAccount,
     })
   }

   deserialize (opts = {}) {
+    if(opts.hdk){
+      this.setHdk(opts.hdk);
+    }
+
     this.hdPath = opts.hdPath || hdPathString
+    this.page = opts.page || 0
     this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
+    this.unlockedAccount = opts.unlockedAccount || 0
     this.accounts = opts.accounts || []
     this.accountDetails = opts.accountDetails || {}
     if (!opts.accountDetails) {
@@ -72,6 +101,11 @@ class LedgerBridgeKeyring extends EventEmitter {
     return Promise.resolve()
   }

+  setHdk ({ publicKey, chainCode }) {
+    this.hdk.publicKey = Buffer.from(publicKey, 'hex')
+    this.hdk.chainCode = Buffer.from(chainCode, 'hex')
+  }
+
   _migrateAccountDetails (opts) {
     if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
       for (const account of Object.keys(opts.accountIndexes)) {
@@ -119,12 +153,12 @@ class LedgerBridgeKeyring extends EventEmitter {
     this.hdPath = hdPath
   }

-  unlock (hdPath, updateHdk = true) {
+  async unlock (hdPath, updateHdk = true) {
     if (this.isUnlocked() && !hdPath) {
       return Promise.resolve('already unlocked')
     }
     const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
-    return new Promise((resolve, reject) => {
+    return new Promise(async (resolve, reject) => {
       this._sendMessage({
         action: 'ledger-unlock',
         params: {
@@ -134,14 +168,17 @@ class LedgerBridgeKeyring extends EventEmitter {
       ({ success, payload }) => {
         if (success) {
           if (updateHdk) {
-            this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
-            this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
+            this.setHdk(payload)
           }
           resolve(payload.address)
         } else {
           reject(payload.error || new Error('Unknown error'))
         }
       })
+
+      // Prevent infinite promise hanging
+      await sleep(TIMEOUT_DURATION_MS)
+      reject('Ledger Bridge unlock timeout');
     })
   }

@@ -222,11 +259,11 @@ class LedgerBridgeKeyring extends EventEmitter {
       // If the iframe isn't loaded yet, let's store the desired transportType value and
       // optimistically return a successful promise
       if (!this.iframeLoaded) {
-        this.delayedPromise = {
+        this.delayedPromises.push({
           resolve,
           reject,
           transportType,
-        }
+        })
         return
       }

@@ -235,6 +272,7 @@ class LedgerBridgeKeyring extends EventEmitter {
         params: { transportType },
       }, ({ success }) => {
         if (success) {
+          console.log(`Ledger transport method updated to ${transportType}`);
           resolve(true)
         } else {
           reject(new Error('Ledger transport could not be updated'))
@@ -455,18 +493,13 @@ class LedgerBridgeKeyring extends EventEmitter {
       // If the ledger live preference was set before the iframe is loaded,
       // set it after the iframe has loaded
       this.iframeLoaded = true
-      if (this.delayedPromise) {
-        try {
-          const result = await this.updateTransportMethod(
-            this.delayedPromise.transportType,
-          )
-          this.delayedPromise.resolve(result)
-        } catch (e) {
-          this.delayedPromise.reject(e)
-        } finally {
-          delete this.delayedPromise
-        }
+      for (const delayedPromise of this.delayedPromises) {
+        this.updateTransportMethod(delayedPromise.transportType)
+          .then((res) => delayedPromise.resolve(res))
+          .catch(e => delayedPromise.reject(e))
       }
+
+      this.delayedPromises = [];
     }
     document.head.appendChild(this.iframe)
   }
