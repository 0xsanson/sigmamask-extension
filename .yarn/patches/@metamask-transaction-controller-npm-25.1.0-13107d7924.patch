diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 32e85c46607567fad81242ca8e83108ee52ad747..9437066a90c95ec63f81d02337a0c0644d6b6580 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -4,31 +4,31 @@
 
 
 
-var _chunkQDIYZX5Vjs = require('./chunk-QDIYZX5V.js');
+var _chunkAFM3ZOKZjs = require('./chunk-AFM3ZOKZ.js');
 require('./chunk-VH47Q6TS.js');
 require('./chunk-RQKICZYP.js');
 require('./chunk-QP75SWIQ.js');
 require('./chunk-ZNZEJDOE.js');
-require('./chunk-WXQZIUNW.js');
-require('./chunk-4S25HUCL.js');
+require('./chunk-EAUE4RCU.js');
+require('./chunk-BOZ2GRIU.js');
 require('./chunk-HS277C77.js');
-require('./chunk-BILEZLAT.js');
+require('./chunk-QEX3QMSL.js');
 require('./chunk-R7NJVDWN.js');
 require('./chunk-DTDTOMTB.js');
 require('./chunk-NRWEI43Q.js');
 require('./chunk-5XBULBP2.js');
 require('./chunk-7LXE4KHV.js');
-require('./chunk-CQBXHAYR.js');
-require('./chunk-TXVH44HM.js');
-require('./chunk-QPNEFZB3.js');
+require('./chunk-FHG5GY6F.js');
+require('./chunk-PF3UOCRW.js');
+require('./chunk-5IHLDAOF.js');
 require('./chunk-5OQ373JS.js');
 require('./chunk-UGFBA4GV.js');
-require('./chunk-O7H2MC7R.js');
+require('./chunk-TZTP4JVA.js');
 require('./chunk-F3CMU2DM.js');
 require('./chunk-CXXGL43K.js');
 require('./chunk-ITDY6AIZ.js');
 require('./chunk-S6VGOPUY.js');
-require('./chunk-W3GAOR7Y.js');
+require('./chunk-VEJ3MIZG.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -36,5 +36,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.ApprovalState = _chunkQDIYZX5Vjs.ApprovalState; exports.CANCEL_RATE = _chunkQDIYZX5Vjs.CANCEL_RATE; exports.HARDFORK = _chunkQDIYZX5Vjs.HARDFORK; exports.SPEED_UP_RATE = _chunkQDIYZX5Vjs.SPEED_UP_RATE; exports.TransactionController = _chunkQDIYZX5Vjs.TransactionController;
+exports.ApprovalState = _chunkAFM3ZOKZjs.ApprovalState; exports.CANCEL_RATE = _chunkAFM3ZOKZjs.CANCEL_RATE; exports.HARDFORK = _chunkAFM3ZOKZjs.HARDFORK; exports.SPEED_UP_RATE = _chunkAFM3ZOKZjs.SPEED_UP_RATE; exports.TransactionController = _chunkAFM3ZOKZjs.TransactionController;
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/chunk-5IHLDAOF.js b/dist/chunk-5IHLDAOF.js
new file mode 100644
index 0000000000000000000000000000000000000000..06f3748679a26a7c2bbc66e72fdeb6fbf5b6ac5d
--- /dev/null
+++ b/dist/chunk-5IHLDAOF.js
@@ -0,0 +1,208 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunk5OQ373JSjs = require('./chunk-5OQ373JS.js');
+
+
+var _chunkTZTP4JVAjs = require('./chunk-TZTP4JVA.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/gas-fees.ts
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "gas-fees");
+async function updateGasFees(request) {
+  const { txMeta } = request;
+  const initialParams = { ...txMeta.txParams };
+  const isSwap = _chunk5OQ373JSjs.SWAP_TRANSACTION_TYPES.includes(
+    txMeta.type
+  );
+  const savedGasFees = isSwap ? void 0 : request.getSavedGasFees(txMeta.chainId);
+  const suggestedGasFees = await getSuggestedGasFees(request);
+  log("Suggested gas fees", suggestedGasFees);
+  const getGasFeeRequest = {
+    ...request,
+    initialParams,
+    savedGasFees,
+    suggestedGasFees
+  };
+  txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
+  txMeta.txParams.maxPriorityFeePerGas = getMaxPriorityFeePerGas(getGasFeeRequest);
+  txMeta.txParams.gasPrice = getGasPrice(getGasFeeRequest);
+  txMeta.userFeeLevel = getUserFeeLevel(getGasFeeRequest);
+  log("Updated gas fee properties", {
+    maxFeePerGas: txMeta.txParams.maxFeePerGas,
+    maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas,
+    gasPrice: txMeta.txParams.gasPrice
+  });
+  if (txMeta.txParams.maxFeePerGas || txMeta.txParams.maxPriorityFeePerGas) {
+    delete txMeta.txParams.gasPrice;
+  }
+  if (txMeta.txParams.gasPrice) {
+    delete txMeta.txParams.maxFeePerGas;
+    delete txMeta.txParams.maxPriorityFeePerGas;
+  }
+  updateDefaultGasEstimates(txMeta);
+}
+function gweiDecimalToWeiHex(value) {
+  return _controllerutils.toHex.call(void 0, _controllerutils.gweiDecToWEIBN.call(void 0, value));
+}
+function getMaxFeePerGas(request) {
+  const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    const maxFeePerGas = gweiDecimalToWeiHex(savedGasFees.maxBaseFee);
+    log("Using maxFeePerGas from savedGasFees", maxFeePerGas);
+    return maxFeePerGas;
+  }
+  if (initialParams.maxFeePerGas) {
+    log("Using maxFeePerGas from request", initialParams.maxFeePerGas);
+    return initialParams.maxFeePerGas;
+  }
+  if (initialParams.gasPrice && !initialParams.maxPriorityFeePerGas) {
+    log(
+      "Setting maxFeePerGas to gasPrice from request",
+      initialParams.gasPrice
+    );
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxFeePerGas) {
+    log("Using suggested maxFeePerGas", suggestedGasFees.maxFeePerGas);
+    return suggestedGasFees.maxFeePerGas;
+  }
+  if (suggestedGasFees.gasPrice) {
+    log(
+      "Setting maxFeePerGas to suggested gasPrice",
+      suggestedGasFees.gasPrice
+    );
+    return suggestedGasFees.gasPrice;
+  }
+  log("maxFeePerGas not set");
+  return void 0;
+}
+function getMaxPriorityFeePerGas(request) {
+  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    const maxPriorityFeePerGas = gweiDecimalToWeiHex(savedGasFees.priorityFee);
+    log(
+      "Using maxPriorityFeePerGas from savedGasFees.priorityFee",
+      maxPriorityFeePerGas
+    );
+    return maxPriorityFeePerGas;
+  }
+  if (initialParams.maxPriorityFeePerGas) {
+    log(
+      "Using maxPriorityFeePerGas from request",
+      initialParams.maxPriorityFeePerGas
+    );
+    return initialParams.maxPriorityFeePerGas;
+  }
+  if (initialParams.gasPrice && !initialParams.maxFeePerGas) {
+    log(
+      "Setting maxPriorityFeePerGas to gasPrice from request",
+      initialParams.gasPrice
+    );
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxPriorityFeePerGas) {
+    log(
+      "Using suggested maxPriorityFeePerGas",
+      suggestedGasFees.maxPriorityFeePerGas
+    );
+    return suggestedGasFees.maxPriorityFeePerGas;
+  }
+  if (txMeta.txParams.maxFeePerGas) {
+    log(
+      "Setting maxPriorityFeePerGas to maxFeePerGas",
+      txMeta.txParams.maxFeePerGas
+    );
+    return txMeta.txParams.maxFeePerGas;
+  }
+  log("maxPriorityFeePerGas not set");
+  return void 0;
+}
+function getGasPrice(request) {
+  const { eip1559, initialParams, suggestedGasFees } = request;
+  if (eip1559) {
+    return void 0;
+  }
+  if (initialParams.gasPrice) {
+    log("Using gasPrice from request", initialParams.gasPrice);
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxFeePerGas) {
+    log("Using suggested maxFeePerGas", suggestedGasFees.maxFeePerGas);
+    return suggestedGasFees.maxFeePerGas;
+  }
+  if (suggestedGasFees.gasPrice) {
+    log("Using suggested gasPrice", suggestedGasFees.gasPrice);
+    return suggestedGasFees.gasPrice;
+  }
+  log("gasPrice not set");
+  return void 0;
+}
+function getUserFeeLevel(request) {
+  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    return "custom" /* CUSTOM */;
+  }
+  if (!initialParams.maxFeePerGas && !initialParams.maxPriorityFeePerGas && initialParams.gasPrice) {
+    return txMeta.origin === _controllerutils.ORIGIN_METAMASK ? "custom" /* CUSTOM */ : "dappSuggested" /* DAPP_SUGGESTED */;
+  }
+  if (!initialParams.maxFeePerGas && !initialParams.maxPriorityFeePerGas && suggestedGasFees.maxFeePerGas && suggestedGasFees.maxPriorityFeePerGas) {
+    return "medium" /* MEDIUM */;
+  }
+  if (txMeta.origin === _controllerutils.ORIGIN_METAMASK) {
+    return "medium" /* MEDIUM */;
+  }
+  return "dappSuggested" /* DAPP_SUGGESTED */;
+}
+function updateDefaultGasEstimates(txMeta) {
+  if (!txMeta.defaultGasEstimates) {
+    txMeta.defaultGasEstimates = {};
+  }
+  txMeta.defaultGasEstimates.maxFeePerGas = txMeta.txParams.maxFeePerGas;
+  txMeta.defaultGasEstimates.maxPriorityFeePerGas = txMeta.txParams.maxPriorityFeePerGas;
+  txMeta.defaultGasEstimates.gasPrice = txMeta.txParams.gasPrice;
+  txMeta.defaultGasEstimates.estimateType = txMeta.userFeeLevel;
+}
+async function getSuggestedGasFees(request) {
+  const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
+  if (!eip1559 && txMeta.txParams.gasPrice || eip1559 && txMeta.txParams.maxFeePerGas && txMeta.txParams.maxPriorityFeePerGas) {
+    return {};
+  }
+  const gasFeeFlow = _chunkTZTP4JVAjs.getGasFeeFlow.call(void 0, txMeta, gasFeeFlows);
+  try {
+    const response = await gasFeeFlow.getGasFees({
+      ethQuery,
+      getGasFeeControllerEstimates: getGasFeeEstimates,
+      transactionMeta: txMeta
+    });
+    return response.estimates.medium;
+  } catch (error) {
+    log("Failed to get suggested gas fees", error);
+  }
+  const gasPriceDecimal = await _controllerutils.query.call(void 0, ethQuery, "gasPrice");
+  const gasPrice = gasPriceDecimal ? _utils.add0x.call(void 0, gasPriceDecimal.toString(16)) : void 0;
+  return { gasPrice };
+}
+
+
+
+
+exports.updateGasFees = updateGasFees; exports.gweiDecimalToWeiHex = gweiDecimalToWeiHex;
+//# sourceMappingURL=chunk-5IHLDAOF.js.map
\ No newline at end of file
diff --git a/dist/chunk-AFM3ZOKZ.js b/dist/chunk-AFM3ZOKZ.js
new file mode 100644
index 0000000000000000000000000000000000000000..3eb9cf25d036e6566ffbe38c1319d8635df0e3d4
--- /dev/null
+++ b/dist/chunk-AFM3ZOKZ.js
@@ -0,0 +1,2358 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+var _chunkVH47Q6TSjs = require('./chunk-VH47Q6TS.js');
+
+
+
+
+var _chunkRQKICZYPjs = require('./chunk-RQKICZYP.js');
+
+
+
+var _chunkQP75SWIQjs = require('./chunk-QP75SWIQ.js');
+
+
+
+var _chunkZNZEJDOEjs = require('./chunk-ZNZEJDOE.js');
+
+
+var _chunkEAUE4RCUjs = require('./chunk-EAUE4RCU.js');
+
+
+var _chunkHS277C77js = require('./chunk-HS277C77.js');
+
+
+var _chunkQEX3QMSLjs = require('./chunk-QEX3QMSL.js');
+
+
+var _chunkR7NJVDWNjs = require('./chunk-R7NJVDWN.js');
+
+
+var _chunkDTDTOMTBjs = require('./chunk-DTDTOMTB.js');
+
+
+var _chunkNRWEI43Qjs = require('./chunk-NRWEI43Q.js');
+
+
+var _chunk5XBULBP2js = require('./chunk-5XBULBP2.js');
+
+
+var _chunk7LXE4KHVjs = require('./chunk-7LXE4KHV.js');
+
+
+var _chunkFHG5GY6Fjs = require('./chunk-FHG5GY6F.js');
+
+
+var _chunkPF3UOCRWjs = require('./chunk-PF3UOCRW.js');
+
+
+var _chunk5IHLDAOFjs = require('./chunk-5IHLDAOF.js');
+
+
+
+var _chunk5OQ373JSjs = require('./chunk-5OQ373JS.js');
+
+
+
+
+
+
+
+
+
+
+
+var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
+
+
+var _chunkF3CMU2DMjs = require('./chunk-F3CMU2DM.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TransactionController.ts
+var _common = require('@ethereumjs/common');
+var _tx = require('@ethereumjs/tx');
+var _util = require('@ethereumjs/util');
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _networkcontroller = require('@metamask/network-controller');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _ethmethodregistry = require('eth-method-registry');
+var _events = require('events');
+var _lodash = require('lodash');
+var _noncetracker = require('nonce-tracker');
+var _uuid = require('uuid');
+var metadata = {
+  transactions: {
+    persist: true,
+    anonymous: false
+  },
+  methodData: {
+    persist: true,
+    anonymous: false
+  },
+  lastFetchedBlockNumbers: {
+    persist: true,
+    anonymous: false
+  }
+};
+var HARDFORK = _common.Hardfork.London;
+var CANCEL_RATE = 1.1;
+var SPEED_UP_RATE = 1.1;
+var controllerName = "TransactionController";
+var ApprovalState = /* @__PURE__ */ ((ApprovalState2) => {
+  ApprovalState2["Approved"] = "approved";
+  ApprovalState2["NotApproved"] = "not-approved";
+  ApprovalState2["SkippedViaBeforePublishHook"] = "skipped-via-before-publish-hook";
+  return ApprovalState2;
+})(ApprovalState || {});
+function getDefaultTransactionControllerState() {
+  return {
+    methodData: {},
+    transactions: [],
+    lastFetchedBlockNumbers: {}
+  };
+}
+var _internalEvents, _incomingTransactionOptions, _pendingTransactionOptions, _transactionHistoryLimit, _isSimulationEnabled, _multichainTrackingHelper, _createNonceTracker, createNonceTracker_fn, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn, _createPendingTransactionTracker, createPendingTransactionTracker_fn, _checkForPendingTransactionAndStartPolling, _stopAllTracking, stopAllTracking_fn, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn, _getGasFeeFlows, getGasFeeFlows_fn, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn, _updateTransactionInternal, updateTransactionInternal_fn, _getSimulationData, getSimulationData_fn;
+var TransactionController = class extends _basecontroller.BaseController {
+  /**
+   * Constructs a TransactionController.
+   *
+   * @param options - The controller options.
+   * @param options.blockTracker - The block tracker used to poll for new blocks data.
+   * @param options.disableHistory - Whether to disable storing history in transaction metadata.
+   * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.
+   * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.
+   * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
+   * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
+   * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+   * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
+   * @param options.getNetworkClientRegistry - Gets the network client registry.
+   * @param options.getNetworkState - Gets the state of the network controller.
+   * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.
+   * @param options.getSavedGasFees - Gets the saved gas fee config.
+   * @param options.getSelectedAddress - Gets the address of the currently selected account.
+   * @param options.incomingTransactions - Configuration options for incoming transaction support.
+   * @param options.isMultichainEnabled - Enable multichain support.
+   * @param options.isSimulationEnabled - Whether new transactions will be automatically simulated.
+   * @param options.messenger - The controller messenger.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.pendingTransactions - Configuration options for pending transaction support.
+   * @param options.provider - The provider used to create the underlying EthQuery instance.
+   * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
+   * @param options.sign - Function used to sign transactions.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.transactionHistoryLimit - Transaction history limit.
+   * @param options.hooks - The controller hooks.
+   */
+  constructor({
+    blockTracker,
+    disableHistory,
+    disableSendFlowHistory,
+    disableSwaps,
+    getCurrentAccountEIP1559Compatibility,
+    getCurrentNetworkEIP1559Compatibility,
+    getExternalPendingTransactions,
+    getGasFeeEstimates,
+    getNetworkClientRegistry,
+    getNetworkState,
+    getPermittedAccounts,
+    getSavedGasFees,
+    getSelectedAddress,
+    incomingTransactions = {},
+    isMultichainEnabled = false,
+    isSimulationEnabled,
+    messenger,
+    onNetworkStateChange,
+    pendingTransactions = {},
+    provider,
+    securityProviderRequest,
+    sign,
+    state,
+    transactionHistoryLimit = 40,
+    hooks
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultTransactionControllerState(),
+        ...state
+      }
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createNonceTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createIncomingTransactionHelper);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createPendingTransactionTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopAllTracking);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removeIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removePendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addPendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNonceTrackerPendingTransactions);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getGasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLayer1GasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionInternal);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getSimulationData);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _internalEvents, new (0, _events.EventEmitter)());
+    this.inProcessOfSigning = /* @__PURE__ */ new Set();
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _incomingTransactionOptions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pendingTransactionOptions, void 0);
+    this.signAbortCallbacks = /* @__PURE__ */ new Map();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _transactionHistoryLimit, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isSimulationEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _multichainTrackingHelper, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkForPendingTransactionAndStartPolling, () => {
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).checkForPendingTransactionAndStartPolling();
+    });
+    this.messagingSystem = messenger;
+    this.getNetworkState = getNetworkState;
+    this.isSendFlowHistoryDisabled = disableSendFlowHistory ?? false;
+    this.isHistoryDisabled = disableHistory ?? false;
+    this.isSwapsDisabled = disableSwaps ?? false;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isSimulationEnabled, isSimulationEnabled ?? (() => true));
+    this.registry = new (0, _ethmethodregistry.MethodRegistry)({ provider });
+    this.getSavedGasFees = getSavedGasFees ?? ((_chainId) => void 0);
+    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility ?? (() => Promise.resolve(true));
+    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
+    this.getGasFeeEstimates = getGasFeeEstimates || (() => Promise.resolve({}));
+    this.getPermittedAccounts = getPermittedAccounts;
+    this.getSelectedAddress = getSelectedAddress;
+    this.getExternalPendingTransactions = getExternalPendingTransactions ?? (() => []);
+    this.securityProviderRequest = securityProviderRequest;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _incomingTransactionOptions, incomingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pendingTransactionOptions, pendingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _transactionHistoryLimit, transactionHistoryLimit);
+    this.sign = sign;
+    this.afterSign = hooks?.afterSign ?? (() => true);
+    this.beforeApproveOnInit = hooks?.beforeApproveOnInit ?? (() => true);
+    this.beforeCheckPendingTransaction = hooks?.beforeCheckPendingTransaction ?? /* istanbul ignore next */
+    (() => true);
+    this.beforePublish = hooks?.beforePublish ?? (() => true);
+    this.getAdditionalSignArguments = hooks?.getAdditionalSignArguments ?? (() => []);
+    this.publish = hooks?.publish ?? (() => Promise.resolve({ transactionHash: void 0 }));
+    this.nonceTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _multichainTrackingHelper, new (0, _chunkNRWEI43Qjs.MultichainTrackingHelper)({
+      isMultichainEnabled,
+      provider,
+      nonceTracker: this.nonceTracker,
+      incomingTransactionOptions: incomingTransactions,
+      findNetworkClientIdByChainId: (chainId) => {
+        return this.messagingSystem.call(
+          `NetworkController:findNetworkClientIdByChainId`,
+          chainId
+        );
+      },
+      getNetworkClientById: (networkClientId) => {
+        return this.messagingSystem.call(
+          `NetworkController:getNetworkClientById`,
+          networkClientId
+        );
+      },
+      getNetworkClientRegistry,
+      removeIncomingTransactionHelperListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).bind(this),
+      removePendingTransactionTrackerListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).bind(this),
+      createNonceTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).bind(this),
+      createIncomingTransactionHelper: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).bind(this),
+      createPendingTransactionTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).bind(this),
+      onNetworkStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "NetworkController:stateChange",
+          listener
+        );
+      }
+    }));
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).initialize();
+    const etherscanRemoteTransactionSource = new (0, _chunkF3CMU2DMjs.EtherscanRemoteTransactionSource)({
+      includeTokenTransfers: incomingTransactions.includeTokenTransfers
+    });
+    this.incomingTransactionHelper = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).call(this, {
+      blockTracker,
+      etherscanRemoteTransactionSource
+    });
+    this.pendingTransactionTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    this.gasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getGasFeeFlows, getGasFeeFlows_fn).call(this);
+    this.layer1GasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn).call(this);
+    const gasFeePoller = new (0, _chunkQEX3QMSLjs.GasFeePoller)({
+      // Default gas fee polling is not yet supported by the clients
+      gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+      getEthQuery: (chainId, networkClientId) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId,
+        chainId
+      }),
+      getGasFeeControllerEstimates: this.getGasFeeEstimates,
+      getTransactions: () => this.state.transactions,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      onStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "TransactionController:stateChange",
+          listener
+        );
+      }
+    });
+    gasFeePoller.hub.on(
+      "transaction-updated",
+      (transactionMeta) => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, transactionMeta, { skipHistory: true })
+    );
+    this.messagingSystem.subscribe(
+      "TransactionController:stateChange",
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _checkForPendingTransactionAndStartPolling)
+    );
+    onNetworkStateChange(() => {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Detected network change", this.getChainId());
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      this.onBootCleanup();
+    });
+    this.onBootCleanup();
+  }
+  failTransaction(transactionMeta, error, actionId) {
+    const newTransactionMeta = _lodash.merge.call(void 0, {}, transactionMeta, {
+      error: _chunkUGFBA4GVjs.normalizeTxError.call(void 0, error),
+      status: "failed" /* failed */
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionFailed`, {
+      actionId,
+      error: error.message,
+      transactionMeta: newTransactionMeta
+    });
+    this.updateTransaction(
+      newTransactionMeta,
+      "TransactionController#failTransaction - Add error message and set status to failed"
+    );
+    this.onTransactionStatusChange(newTransactionMeta);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      newTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      newTransactionMeta
+    );
+  }
+  async registryLookup(fourBytePrefix) {
+    const registryMethod = await this.registry.lookup(fourBytePrefix);
+    if (!registryMethod) {
+      return {
+        registryMethod: "",
+        parsedRegistryMethod: { name: void 0, args: void 0 }
+      };
+    }
+    const parsedRegistryMethod = this.registry.parse(registryMethod);
+    return { registryMethod, parsedRegistryMethod };
+  }
+  /**
+   * Stops polling and removes listeners to prepare the controller for garbage collection.
+   */
+  destroy() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopAllTracking, stopAllTracking_fn).call(this);
+  }
+  /**
+   * Handle new method data request.
+   *
+   * @param fourBytePrefix - The method prefix.
+   * @returns The method data object corresponding to the given signature prefix.
+   */
+  async handleMethodData(fourBytePrefix) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      const { methodData } = this.state;
+      const knownMethod = Object.keys(methodData).find(
+        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix
+      );
+      if (knownMethod) {
+        return methodData[fourBytePrefix];
+      }
+      const registry = await this.registryLookup(fourBytePrefix);
+      this.update((state) => {
+        state.methodData[fourBytePrefix] = registry;
+      });
+      return registry;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a new unapproved transaction to state. Parameters will be validated, a
+   * unique transaction id will be generated, and gas and gasPrice will be calculated
+   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
+   *
+   * @param txParams - Standard parameters for an Ethereum transaction.
+   * @param opts - Additional options to control how the transaction is added.
+   * @param opts.actionId - Unique ID to prevent duplicate requests.
+   * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+   * @param opts.method - RPC method that requested the transaction.
+   * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+   * @param opts.requireApproval - Whether the transaction requires approval by the user, defaults to true unless explicitly disabled.
+   * @param opts.securityAlertResponse - Response from security validator.
+   * @param opts.sendFlowHistory - The sendFlowHistory entries to add.
+   * @param opts.type - Type of transaction to add, such as 'cancel' or 'swap'.
+   * @param opts.swaps - Options for swaps transactions.
+   * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.
+   * @param opts.swaps.meta - Metadata for swap transaction.
+   * @param opts.networkClientId - The id of the network client for this transaction.
+   * @returns Object containing a promise resolving to the transaction hash if approved.
+   */
+  async addTransaction(txParams, {
+    actionId,
+    deviceConfirmedOn,
+    method,
+    origin,
+    requireApproval,
+    securityAlertResponse,
+    sendFlowHistory,
+    swaps = {},
+    type,
+    networkClientId
+  } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Adding transaction", txParams);
+    txParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, txParams);
+    if (networkClientId && !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).has(networkClientId)) {
+      throw new Error(
+        "The networkClientId for this transaction could not be found"
+      );
+    }
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(
+      networkClientId
+    );
+    _chunkVH47Q6TSjs.validateTxParams.call(void 0, txParams, isEIP1559Compatible);
+    if (origin) {
+      await _chunkVH47Q6TSjs.validateTransactionOrigin.call(void 0, 
+        await this.getPermittedAccounts(origin),
+        this.getSelectedAddress(),
+        txParams.from,
+        origin
+      );
+    }
+    const dappSuggestedGasFees = this.generateDappSuggestedGasFees(
+      txParams,
+      origin
+    );
+    const chainId = this.getChainId(networkClientId);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    const transactionType = type ?? (await _chunkHS277C77js.determineTransactionType.call(void 0, txParams, ethQuery)).type;
+    const existingTransactionMeta = this.getTransactionWithActionId(actionId);
+    let addedTransactionMeta = existingTransactionMeta ? _lodash.cloneDeep.call(void 0, existingTransactionMeta) : {
+      // Add actionId to txMeta to check if same actionId is seen again
+      actionId,
+      chainId,
+      dappSuggestedGasFees,
+      deviceConfirmedOn,
+      id: _uuid.v1.call(void 0, ),
+      origin,
+      securityAlertResponse,
+      status: "unapproved" /* unapproved */,
+      time: Date.now(),
+      txParams,
+      userEditedGasLimit: false,
+      verifiedOnBlockchain: false,
+      type: transactionType,
+      networkClientId
+    };
+    const getSimulationDataPromise = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getSimulationData, getSimulationData_fn).call(this, addedTransactionMeta);
+    await this.updateGasProperties(addedTransactionMeta);
+    if (!existingTransactionMeta) {
+      if (method && this.securityProviderRequest) {
+        const securityProviderResponse = await this.securityProviderRequest(
+          addedTransactionMeta,
+          method
+        );
+        addedTransactionMeta.securityProviderResponse = securityProviderResponse;
+      }
+      if (!this.isSendFlowHistoryDisabled) {
+        addedTransactionMeta.sendFlowHistory = sendFlowHistory ?? [];
+      }
+      if (!this.isHistoryDisabled) {
+        addedTransactionMeta = _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, addedTransactionMeta);
+      }
+      addedTransactionMeta = _chunk5OQ373JSjs.updateSwapsTransaction.call(void 0, 
+        addedTransactionMeta,
+        transactionType,
+        swaps,
+        {
+          isSwapsDisabled: this.isSwapsDisabled,
+          cancelTransaction: this.cancelTransaction.bind(this),
+          messenger: this.messagingSystem
+        }
+      );
+      this.addMetadata(addedTransactionMeta);
+      this.messagingSystem.publish(
+        `${controllerName}:unapprovedTransactionAdded`,
+        addedTransactionMeta
+      );
+      getSimulationDataPromise.then(async (simulationData) => {
+        await this.updateSimulationData(
+          addedTransactionMeta.id,
+          simulationData
+        );
+      });
+    }
+    return {
+      result: this.processApproval(addedTransactionMeta, {
+        isExisting: Boolean(existingTransactionMeta),
+        requireApproval,
+        actionId
+      }),
+      transactionMeta: addedTransactionMeta
+    };
+  }
+  startIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.start();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).startIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.stop();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopAllIncomingTransactionPolling() {
+    this.incomingTransactionHelper.stop();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllIncomingTransactionPolling();
+  }
+  async updateIncomingTransactions(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      await this.incomingTransactionHelper.update();
+      return;
+    }
+    await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).updateIncomingTransactions(
+      networkClientIds
+    );
+  }
+  /**
+   * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param gasValues - The gas values to use for the cancellation transaction.
+   * @param options - The options for the cancellation transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests.
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async stopTransaction(transactionId, gasValues, {
+    estimatedBaseFee,
+    actionId
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating cancel transaction", transactionId, gasValues);
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      CANCEL_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      CANCEL_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      CANCEL_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const newTxParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    } : {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      newTxParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = newTxParams.maxFeePerGas ?? newTxParams.gasPrice;
+    const oldFee = newTxParams.maxFeePerGas ? transactionMeta.txParams.maxFeePerGas : transactionMeta.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting cancel transaction", {
+      oldFee,
+      newFee,
+      txParams: newTxParams
+    });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const cancelTransactionMeta = {
+      actionId,
+      chainId: transactionMeta.chainId,
+      networkClientId: transactionMeta.networkClientId,
+      estimatedBaseFee,
+      hash,
+      id: _uuid.v1.call(void 0, ),
+      originalGasEstimate: transactionMeta.txParams.gas,
+      status: "submitted" /* submitted */,
+      time: Date.now(),
+      type: "cancel" /* cancel */,
+      txParams: newTxParams
+    };
+    this.addMetadata(cancelTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      cancelTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      cancelTransactionMeta
+    );
+  }
+  /**
+   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.
+   *
+   * @param transactionId - The ID of the transaction to speed up.
+   * @param gasValues - The gas values to use for the speed up transaction.
+   * @param options - The options for the speed up transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async speedUpTransaction(transactionId, gasValues, {
+    actionId,
+    estimatedBaseFee
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating speed up transaction", transactionId, gasValues);
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      SPEED_UP_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */
+    } : {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const transactionMetaWithRsv = await this.updateTransactionMetaRSV(
+      transactionMeta,
+      signedTx
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = txParams.maxFeePerGas ?? txParams.gasPrice;
+    const oldFee = txParams.maxFeePerGas ? transactionMetaWithRsv.txParams.maxFeePerGas : transactionMetaWithRsv.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting speed up transaction", { oldFee, newFee, txParams });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const baseTransactionMeta = {
+      ...transactionMetaWithRsv,
+      estimatedBaseFee,
+      id: _uuid.v1.call(void 0, ),
+      time: Date.now(),
+      hash,
+      actionId,
+      originalGasEstimate: transactionMeta.txParams.gas,
+      type: "retry" /* retry */,
+      originalType: transactionMeta.type
+    };
+    const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        maxFeePerGas: newMaxFeePerGas,
+        maxPriorityFeePerGas: newMaxPriorityFeePerGas
+      }
+    } : {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        gasPrice: newGasPrice
+      }
+    };
+    this.addMetadata(newTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:speedupTransactionAdded`,
+      newTransactionMeta
+    );
+  }
+  /**
+   * Estimates required gas for a given transaction.
+   *
+   * @param transaction - The transaction to estimate gas for.
+   * @param networkClientId - The network client id to use for the estimate.
+   * @returns The gas and gas price.
+   */
+  async estimateGas(transaction, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { estimatedGas, simulationFails } = await _chunkRQKICZYPjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    return { gas: estimatedGas, simulationFails };
+  }
+  /**
+   * Estimates required gas for a given transaction and add additional gas buffer with the given multiplier.
+   *
+   * @param transaction - The transaction params to estimate gas for.
+   * @param multiplier - The multiplier to use for the gas buffer.
+   * @param networkClientId - The network client id to use for the estimate.
+   */
+  async estimateGasBuffered(transaction, multiplier, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { blockGasLimit, estimatedGas, simulationFails } = await _chunkRQKICZYPjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    const gas = _chunkRQKICZYPjs.addGasBuffer.call(void 0, estimatedGas, blockGasLimit, multiplier);
+    return {
+      gas,
+      simulationFails
+    };
+  }
+  /**
+   * Updates an existing transaction in state.
+   *
+   * @param transactionMeta - The new transaction to store in state.
+   * @param note - A note or update reason to include in the transaction history.
+   */
+  updateTransaction(transactionMeta, note) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, transactionMeta, {
+      note,
+      skipHistory: this.isHistoryDisabled
+    });
+  }
+  /**
+   * Update the security alert response for a transaction.
+   *
+   * @param transactionId - ID of the transaction.
+   * @param securityAlertResponse - The new security alert response for the transaction.
+   */
+  updateSecurityAlertResponse(transactionId, securityAlertResponse) {
+    if (!securityAlertResponse) {
+      throw new Error(
+        "updateSecurityAlertResponse: securityAlertResponse should not be null"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update security alert response as no transaction metadata found`
+      );
+    }
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      securityAlertResponse
+    };
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updatesecurityAlertResponse - securityAlertResponse updated`
+    );
+  }
+  /**
+   * Removes all transactions from state, optionally based on the current network.
+   *
+   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the
+   * current network. If `true`, all transactions are wiped.
+   * @param address - If specified, only transactions originating from this address will be
+   * wiped on current network.
+   */
+  wipeTransactions(ignoreNetwork, address) {
+    if (ignoreNetwork && !address) {
+      this.update((state) => {
+        state.transactions = [];
+      });
+      return;
+    }
+    const currentChainId = this.getChainId();
+    const newTransactions = this.state.transactions.filter(
+      ({ chainId, txParams }) => {
+        const isMatchingNetwork = ignoreNetwork || chainId === currentChainId;
+        if (!isMatchingNetwork) {
+          return true;
+        }
+        const isMatchingAddress = !address || txParams.from?.toLowerCase() === address.toLowerCase();
+        return !isMatchingAddress;
+      }
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(newTransactions);
+    });
+  }
+  /**
+   * Adds external provided transaction to state as confirmed transaction.
+   *
+   * @param transactionMeta - TransactionMeta to add transactions.
+   * @param transactionReceipt - TransactionReceipt of the external transaction.
+   * @param baseFeePerGas - Base fee per gas of the external transaction.
+   */
+  async confirmExternalTransaction(transactionMeta, transactionReceipt, baseFeePerGas) {
+    const newTransactionMeta = this.addExternalTransaction(transactionMeta);
+    try {
+      const transactionId = newTransactionMeta.id;
+      const updatedTransactionMeta = {
+        ...newTransactionMeta,
+        status: "confirmed" /* confirmed */,
+        txReceipt: transactionReceipt
+      };
+      if (baseFeePerGas) {
+        updatedTransactionMeta.baseFeePerGas = baseFeePerGas;
+      }
+      this.markNonceDuplicatesDropped(transactionId);
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:confirmExternalTransaction - Add external transaction`
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      this.updatePostBalance(updatedTransactionMeta);
+      this.messagingSystem.publish(
+        `${controllerName}:transactionConfirmed`,
+        updatedTransactionMeta
+      );
+    } catch (error) {
+      console.error("Failed to confirm external transaction", error);
+    }
+  }
+  /**
+   * Append new send flow history to a transaction.
+   *
+   * @param transactionID - The ID of the transaction to update.
+   * @param currentSendFlowHistoryLength - The length of the current sendFlowHistory array.
+   * @param sendFlowHistoryToAdd - The sendFlowHistory entries to add.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionSendFlowHistory(transactionID, currentSendFlowHistoryLength, sendFlowHistoryToAdd) {
+    if (this.isSendFlowHistoryDisabled) {
+      throw new Error(
+        "Send flow history is disabled for the current transaction controller"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionID);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update send flow history as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionSendFlowHistory"
+    );
+    const sendFlowHistory = transactionMeta.sendFlowHistory ?? [];
+    if (currentSendFlowHistoryLength === sendFlowHistory.length) {
+      const updatedTransactionMeta = {
+        ...transactionMeta,
+        sendFlowHistory: [...sendFlowHistory, ...sendFlowHistoryToAdd]
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:updateTransactionSendFlowHistory - sendFlowHistory updated`
+      );
+    }
+    return this.getTransaction(transactionID);
+  }
+  /**
+   * Update the gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param gasValues - Gas values to update.
+   * @param gasValues.gas - Same as transaction.gasLimit.
+   * @param gasValues.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param gasValues.gasPrice - Price per gas for legacy transactions.
+   * @param gasValues.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @param gasValues.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param gasValues.estimateUsed - Which estimate level was used.
+   * @param gasValues.estimateSuggested - Which estimate level that the API suggested.
+   * @param gasValues.defaultGasEstimates - The default estimate for gas.
+   * @param gasValues.originalGasEstimate - Original estimate for gas.
+   * @param gasValues.userEditedGasLimit - The gas limit supplied by user.
+   * @param gasValues.userFeeLevel - Estimate level user selected.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionGasFees(transactionId, {
+    defaultGasEstimates,
+    estimateUsed,
+    estimateSuggested,
+    gas,
+    gasLimit,
+    gasPrice,
+    maxPriorityFeePerGas,
+    maxFeePerGas,
+    originalGasEstimate,
+    userEditedGasLimit,
+    userFeeLevel
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionGasFees"
+    );
+    let transactionGasFees = {
+      txParams: {
+        gas,
+        gasLimit,
+        gasPrice,
+        maxPriorityFeePerGas,
+        maxFeePerGas
+      },
+      defaultGasEstimates,
+      estimateUsed,
+      estimateSuggested,
+      originalGasEstimate,
+      userEditedGasLimit,
+      userFeeLevel
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionGasFees.txParams = _lodash.pickBy.call(void 0, transactionGasFees.txParams);
+    transactionGasFees = _lodash.pickBy.call(void 0, transactionGasFees);
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionGasFees);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updateTransactionGasFees - gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  /**
+   * Update the previous gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param previousGas - Previous gas values to update.
+   * @param previousGas.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param previousGas.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param previousGas.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @returns The updated transactionMeta.
+   */
+  updatePreviousGasParams(transactionId, {
+    gasLimit,
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updatePreviousGasParams");
+    const transactionPreviousGas = {
+      previousGas: {
+        gasLimit,
+        maxFeePerGas,
+        maxPriorityFeePerGas
+      }
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionPreviousGas.previousGas = _lodash.pickBy.call(void 0, 
+      transactionPreviousGas.previousGas
+    );
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionPreviousGas);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updatePreviousGasParams - Previous gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  async getNonceLock(address, networkClientId) {
+    return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(
+      address,
+      networkClientId
+    );
+  }
+  /**
+   * Updates the editable parameters of a transaction.
+   *
+   * @param txId - The ID of the transaction to update.
+   * @param params - The editable parameters to update.
+   * @param params.data - Data to pass with the transaction.
+   * @param params.gas - Maximum number of units of gas to use for the transaction.
+   * @param params.gasPrice - Price per gas for legacy transactions.
+   * @param params.from - Address to send the transaction from.
+   * @param params.to - Address to send the transaction to.
+   * @param params.value - Value associated with the transaction.
+   * @returns The updated transaction metadata.
+   */
+  async updateEditableParams(txId, {
+    data,
+    gas,
+    gasPrice,
+    from,
+    to,
+    value
+  }) {
+    const transactionMeta = this.getTransaction(txId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update editable params as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updateEditableParams");
+    const editableParams = {
+      txParams: {
+        data,
+        from,
+        to,
+        value,
+        gas,
+        gasPrice
+      }
+    };
+    editableParams.txParams = _lodash.pickBy.call(void 0, 
+      editableParams.txParams
+    );
+    const updatedTransaction = _lodash.merge.call(void 0, {}, transactionMeta, editableParams);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const { type } = await _chunkHS277C77js.determineTransactionType.call(void 0, 
+      updatedTransaction.txParams,
+      ethQuery
+    );
+    updatedTransaction.type = type;
+    await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+      ethQuery,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      transactionMeta: updatedTransaction
+    });
+    this.updateTransaction(
+      updatedTransaction,
+      `Update Editable Params for ${txId}`
+    );
+    return this.getTransaction(txId);
+  }
+  /**
+   * Signs and returns the raw transaction data for provided transaction params list.
+   *
+   * @param listOfTxParams - The list of transaction params to approve.
+   * @param opts - Options bag.
+   * @param opts.hasNonce - Whether the transactions already have a nonce.
+   * @returns The raw transactions.
+   */
+  async approveTransactionsWithSameNonce(listOfTxParams = [], { hasNonce } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Approving transactions with same nonce", {
+      transactions: listOfTxParams
+    });
+    if (listOfTxParams.length === 0) {
+      return "";
+    }
+    const initialTx = listOfTxParams[0];
+    const common = this.getCommonConfiguration(initialTx.chainId);
+    let networkClientId;
+    try {
+      networkClientId = this.messagingSystem.call(
+        `NetworkController:findNetworkClientIdByChainId`,
+        initialTx.chainId
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "failed to find networkClientId from chainId", err);
+    }
+    const initialTxAsEthTx = _tx.TransactionFactory.fromTxData(initialTx, {
+      common
+    });
+    const initialTxAsSerializedHex = _util.bufferToHex.call(void 0, initialTxAsEthTx.serialize());
+    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
+      return "";
+    }
+    this.inProcessOfSigning.add(initialTxAsSerializedHex);
+    let rawTransactions, nonceLock;
+    try {
+      const fromAddress = initialTx.from;
+      const requiresNonce = hasNonce !== true;
+      nonceLock = requiresNonce ? await this.getNonceLock(fromAddress, networkClientId) : void 0;
+      const nonce = nonceLock ? _utils.add0x.call(void 0, nonceLock.nextNonce.toString(16)) : initialTx.nonce;
+      if (nonceLock) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Using nonce from nonce tracker", nonce, nonceLock.nonceDetails);
+      }
+      rawTransactions = await Promise.all(
+        listOfTxParams.map((txParams) => {
+          txParams.nonce = nonce;
+          return this.signExternalTransaction(txParams.chainId, txParams);
+        })
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while signing transactions with same nonce", err);
+      throw err;
+    } finally {
+      nonceLock?.releaseLock();
+      this.inProcessOfSigning.delete(initialTxAsSerializedHex);
+    }
+    return rawTransactions;
+  }
+  /**
+   * Update a custodial transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param options - The custodial transaction options to update.
+   * @param options.errorMessage - The error message to be assigned in case transaction status update to failed.
+   * @param options.hash - The new hash value to be assigned.
+   * @param options.status - The new status value to be assigned.
+   */
+  updateCustodialTransaction(transactionId, {
+    errorMessage,
+    hash,
+    status
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update custodial transaction as no transaction metadata found`
+      );
+    }
+    if (!transactionMeta.custodyId) {
+      throw new Error("Transaction must be a custodian transaction");
+    }
+    if (status && ![
+      "submitted" /* submitted */,
+      "signed" /* signed */,
+      "failed" /* failed */
+    ].includes(status)) {
+      throw new Error(
+        `Cannot update custodial transaction with status: ${status}`
+      );
+    }
+    const updatedTransactionMeta = _lodash.merge.call(void 0, 
+      {},
+      transactionMeta,
+      _lodash.pickBy.call(void 0, { hash, status })
+    );
+    if (status === "submitted" /* submitted */) {
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+    }
+    if (status === "failed" /* failed */) {
+      updatedTransactionMeta.error = _chunkUGFBA4GVjs.normalizeTxError.call(void 0, new Error(errorMessage));
+    }
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updateCustodialTransaction - Custodial transaction updated`
+    );
+    if (["submitted" /* submitted */, "failed" /* failed */].includes(
+      status
+    )) {
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+    }
+  }
+  /**
+   * Creates approvals for all unapproved transactions persisted.
+   */
+  initApprovals() {
+    const chainId = this.getChainId();
+    const unapprovedTxs = this.state.transactions.filter(
+      (transaction) => transaction.status === "unapproved" /* unapproved */ && transaction.chainId === chainId && !transaction.isUserOperation
+    );
+    for (const txMeta of unapprovedTxs) {
+      this.processApproval(txMeta, {
+        shouldShowRequest: false
+      }).catch((error) => {
+        if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+          return;
+        }
+        console.error("Error during persisted transaction approval", error);
+      });
+    }
+  }
+  /**
+   * Search transaction metadata for matching entries.
+   *
+   * @param opts - Options bag.
+   * @param opts.searchCriteria - An object containing values or functions for transaction properties to filter transactions with.
+   * @param opts.initialList - The transactions to search. Defaults to the current state.
+   * @param opts.filterToCurrentNetwork - Whether to filter the results to the current network. Defaults to true.
+   * @param opts.limit - The maximum number of transactions to return. No limit by default.
+   * @returns An array of transactions matching the provided options.
+   */
+  getTransactions({
+    searchCriteria = {},
+    initialList,
+    filterToCurrentNetwork = true,
+    limit
+  } = {}) {
+    const chainId = this.getChainId();
+    const predicateMethods = _lodash.mapValues.call(void 0, searchCriteria, (predicate) => {
+      return typeof predicate === "function" ? predicate : (
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        (v) => v === predicate
+      );
+    });
+    const transactionsToFilter = initialList ?? this.state.transactions;
+    const filteredTransactions = _lodash.sortBy.call(void 0, 
+      _lodash.pickBy.call(void 0, transactionsToFilter, (transaction) => {
+        if (filterToCurrentNetwork && transaction.chainId !== chainId) {
+          return false;
+        }
+        for (const [key, predicate] of Object.entries(predicateMethods)) {
+          if (key in transaction.txParams) {
+            if (predicate(transaction.txParams[key]) === false) {
+              return false;
+            }
+          } else if (predicate(transaction[key]) === false) {
+            return false;
+          }
+        }
+        return true;
+      }),
+      "time"
+    );
+    if (limit !== void 0) {
+      const nonces = /* @__PURE__ */ new Set();
+      const txs = [];
+      for (let i = filteredTransactions.length - 1; i > -1; i--) {
+        const txMeta = filteredTransactions[i];
+        const { nonce } = txMeta.txParams;
+        if (!nonces.has(nonce)) {
+          if (nonces.size < limit) {
+            nonces.add(nonce);
+          } else {
+            continue;
+          }
+        }
+        txs.unshift(txMeta);
+      }
+      return txs;
+    }
+    return filteredTransactions;
+  }
+  async signExternalTransaction(chainId, transactionParams) {
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const normalizedTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionParams);
+    const type = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, normalizedTransactionParams) ? "0x2" /* feeMarket */ : "0x0" /* legacy */;
+    const updatedTransactionParams = {
+      ...normalizedTransactionParams,
+      type,
+      gasLimit: normalizedTransactionParams.gas,
+      chainId
+    };
+    const { from } = updatedTransactionParams;
+    const common = this.getCommonConfiguration(chainId);
+    const unsignedTransaction = _tx.TransactionFactory.fromTxData(
+      updatedTransactionParams,
+      { common }
+    );
+    const signedTransaction = await this.sign(unsignedTransaction, from);
+    const rawTransaction = _util.bufferToHex.call(void 0, signedTransaction.serialize());
+    return rawTransaction;
+  }
+  /**
+   * Removes unapproved transactions from state.
+   */
+  clearUnapprovedTransactions() {
+    const transactions = this.state.transactions.filter(
+      ({ status }) => status !== "unapproved" /* unapproved */
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+  }
+  /**
+   * Stop the signing process for a specific transaction.
+   * Throws an error causing the transaction status to be set to failed.
+   * @param transactionId - The ID of the transaction to stop signing.
+   */
+  abortTransactionSigning(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(`Cannot abort signing as no transaction metadata found`);
+    }
+    const abortCallback = this.signAbortCallbacks.get(transactionId);
+    if (!abortCallback) {
+      throw new Error(
+        `Cannot abort signing as transaction is not waiting for signing`
+      );
+    }
+    abortCallback();
+    this.signAbortCallbacks.delete(transactionId);
+  }
+  addMetadata(transactionMeta) {
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        transactionMeta
+      ]);
+    });
+  }
+  async updateGasProperties(transactionMeta) {
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(transactionMeta.networkClientId) && transactionMeta.txParams.type !== "0x0" /* legacy */;
+    const { networkClientId, chainId } = transactionMeta;
+    const isCustomNetwork = networkClientId ? this.messagingSystem.call(
+      `NetworkController:getNetworkClientById`,
+      networkClientId
+    ).configuration.type === _networkcontroller.NetworkClientType.Custom : this.getNetworkState().providerConfig.type === _controllerutils.NetworkType.rpc;
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    await _chunkRQKICZYPjs.updateGas.call(void 0, {
+      ethQuery,
+      chainId,
+      isCustomNetwork,
+      txMeta: transactionMeta
+    });
+    await _chunk5IHLDAOFjs.updateGasFees.call(void 0, {
+      eip1559: isEIP1559Compatible,
+      ethQuery,
+      gasFeeFlows: this.gasFeeFlows,
+      getGasFeeEstimates: this.getGasFeeEstimates,
+      getSavedGasFees: this.getSavedGasFees.bind(this),
+      txMeta: transactionMeta
+    });
+    await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+      ethQuery,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      transactionMeta
+    });
+  }
+  onBootCleanup() {
+    this.submitApprovedTransactions();
+  }
+  /**
+   * Force submit approved transactions for all chains.
+   */
+  submitApprovedTransactions() {
+    const approvedTransactions = this.state.transactions.filter(
+      (transaction) => transaction.status === "approved" /* approved */
+    );
+    for (const transactionMeta of approvedTransactions) {
+      if (this.beforeApproveOnInit(transactionMeta)) {
+        this.approveTransaction(transactionMeta.id).catch((error) => {
+          console.error("Error while submitting persisted transaction", error);
+        });
+      }
+    }
+  }
+  async processApproval(transactionMeta, {
+    isExisting = false,
+    requireApproval,
+    shouldShowRequest = true,
+    actionId
+  }) {
+    const transactionId = transactionMeta.id;
+    let resultCallbacks;
+    const { meta, isCompleted } = this.isTransactionCompleted(transactionId);
+    const finishedPromise = isCompleted ? Promise.resolve(meta) : this.waitForTransactionFinished(transactionId);
+    if (meta && !isExisting && !isCompleted) {
+      try {
+        if (requireApproval !== false) {
+          const acceptResult = await this.requestApproval(transactionMeta, {
+            shouldShowRequest
+          });
+          resultCallbacks = acceptResult.resultCallbacks;
+          const approvalValue = acceptResult.value;
+          const updatedTransaction = approvalValue?.txMeta;
+          if (updatedTransaction) {
+            _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating transaction with approval data", {
+              customNonce: updatedTransaction.customNonceValue,
+              params: updatedTransaction.txParams
+            });
+            this.updateTransaction(
+              updatedTransaction,
+              "TransactionController#processApproval - Updated with approval data"
+            );
+          }
+        }
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          const approvalResult = await this.approveTransaction(transactionId);
+          if (approvalResult === "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */ && resultCallbacks) {
+            resultCallbacks.success();
+          }
+          const updatedTransactionMeta = this.getTransaction(
+            transactionId
+          );
+          this.messagingSystem.publish(
+            `${controllerName}:transactionApproved`,
+            {
+              transactionMeta: updatedTransactionMeta,
+              actionId
+            }
+          );
+        }
+      } catch (error) {
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+            this.cancelTransaction(transactionId, actionId);
+            throw _rpcerrors.providerErrors.userRejectedRequest(
+              "MetaMask Tx Signature: User denied transaction signature."
+            );
+          } else {
+            this.failTransaction(meta, error, actionId);
+          }
+        }
+      }
+    }
+    const finalMeta = await finishedPromise;
+    switch (finalMeta?.status) {
+      case "failed" /* failed */:
+        resultCallbacks?.error(finalMeta.error);
+        throw _rpcerrors.rpcErrors.internal(finalMeta.error.message);
+      case "submitted" /* submitted */:
+        resultCallbacks?.success();
+        return finalMeta.hash;
+      default:
+        const internalError = _rpcerrors.rpcErrors.internal(
+          `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(
+            finalMeta || transactionId
+          )}`
+        );
+        resultCallbacks?.error(internalError);
+        throw internalError;
+    }
+  }
+  /**
+   * Approves a transaction and updates it's status in state. If this is not a
+   * retry transaction, a nonce will be generated. The transaction is signed
+   * using the sign configuration property, then published to the blockchain.
+   * A `<tx.id>:finished` hub event is fired after success or failure.
+   *
+   * @param transactionId - The ID of the transaction to approve.
+   */
+  async approveTransaction(transactionId) {
+    const { transactions } = this.state;
+    const releaseLock = await this.mutex.acquire();
+    const index = transactions.findIndex(({ id }) => transactionId === id);
+    const transactionMeta = transactions[index];
+    const updatedTransactionMeta = _lodash.cloneDeep.call(void 0, transactionMeta);
+    const {
+      txParams: { from },
+      networkClientId
+    } = transactionMeta;
+    let releaseNonceLock;
+    try {
+      if (!this.sign) {
+        releaseLock();
+        this.failTransaction(
+          transactionMeta,
+          new Error("No sign method defined.")
+        );
+        return "not-approved" /* NotApproved */;
+      } else if (!transactionMeta.chainId) {
+        releaseLock();
+        this.failTransaction(transactionMeta, new Error("No chainId defined."));
+        return "not-approved" /* NotApproved */;
+      }
+      if (this.inProcessOfSigning.has(transactionId)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping approval as signing in progress", transactionId);
+        return "not-approved" /* NotApproved */;
+      }
+      const [nonce, releaseNonce] = await _chunkZNZEJDOEjs.getNextNonce.call(void 0, 
+        transactionMeta,
+        (address) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(address, networkClientId)
+      );
+      releaseNonceLock = releaseNonce;
+      updatedTransactionMeta.status = "approved" /* approved */;
+      updatedTransactionMeta.txParams = {
+        ...updatedTransactionMeta.txParams,
+        nonce,
+        chainId: transactionMeta.chainId
+      };
+      const baseTxParams = {
+        ...updatedTransactionMeta.txParams,
+        gasLimit: updatedTransactionMeta.txParams.gas
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction approved"
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      const isEIP1559 = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, updatedTransactionMeta.txParams);
+      const txParams = isEIP1559 ? {
+        ...baseTxParams,
+        estimatedBaseFee: updatedTransactionMeta.txParams.estimatedBaseFee,
+        type: "0x2" /* feeMarket */
+      } : baseTxParams;
+      const rawTx = await this.signTransaction(
+        updatedTransactionMeta,
+        txParams
+      );
+      if (!this.beforePublish(updatedTransactionMeta)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping publishing transaction based on hook");
+        this.messagingSystem.publish(
+          `${controllerName}:transactionPublishingSkipped`,
+          updatedTransactionMeta
+        );
+        return "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */;
+      }
+      if (!rawTx) {
+        return "not-approved" /* NotApproved */;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      if (transactionMeta.type === "swap" /* swap */) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Determining pre-transaction balance");
+        const preTxBalance = await _controllerutils.query.call(void 0, ethQuery, "getBalance", [from]);
+        updatedTransactionMeta.preTxBalance = preTxBalance;
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+          "Updated pre-transaction balance",
+          updatedTransactionMeta.preTxBalance
+        );
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publishing transaction", txParams);
+      let { transactionHash: hash } = await this.publish(
+        transactionMeta,
+        rawTx
+      );
+      if (hash === void 0) {
+        hash = await this.publishTransaction(ethQuery, rawTx);
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publish successful", hash);
+      updatedTransactionMeta.hash = hash;
+      updatedTransactionMeta.status = "submitted" /* submitted */;
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction submitted"
+      );
+      this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+        transactionMeta: updatedTransactionMeta
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      return "approved" /* Approved */;
+    } catch (error) {
+      this.failTransaction(transactionMeta, error);
+      return "not-approved" /* NotApproved */;
+    } finally {
+      this.inProcessOfSigning.delete(transactionId);
+      releaseNonceLock?.();
+      releaseLock();
+    }
+  }
+  async publishTransaction(ethQuery, rawTransaction) {
+    return await _controllerutils.query.call(void 0, ethQuery, "sendRawTransaction", [rawTransaction]);
+  }
+  /**
+   * Cancels a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param actionId - The actionId passed from UI
+   */
+  cancelTransaction(transactionId, actionId) {
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    this.update((state) => {
+      const transactions = state.transactions.filter(
+        ({ id }) => id !== transactionId
+      );
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "rejected" /* rejected */
+    };
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      updatedTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      updatedTransactionMeta
+    );
+    this.messagingSystem.publish(`${controllerName}:transactionRejected`, {
+      transactionMeta: updatedTransactionMeta,
+      actionId
+    });
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Trim the amount of transactions that are set on the state. Checks
+   * if the length of the tx history is longer then desired persistence
+   * limit and then if it is removes the oldest confirmed or rejected tx.
+   * Pending or unapproved transactions will not be removed by this
+   * operation. For safety of presenting a fully functional transaction UI
+   * representation, this function will not break apart transactions with the
+   * same nonce, created on the same day, per network. Not accounting for
+   * transactions of the same nonce, same day and network combo can result in
+   * confusing or broken experiences in the UI.
+   *
+   * @param transactions - The transactions to be applied to the state.
+   * @returns The trimmed list of transactions.
+   */
+  trimTransactionsForState(transactions) {
+    const nonceNetworkSet = /* @__PURE__ */ new Set();
+    const txsToKeep = [...transactions].sort((a, b) => a.time > b.time ? -1 : 1).filter((tx) => {
+      const { chainId, status, txParams, time } = tx;
+      if (txParams) {
+        const key = `${String(txParams.nonce)}-${_controllerutils.convertHexToDecimal.call(void 0, 
+          chainId
+        )}-${new Date(time).toDateString()}`;
+        if (nonceNetworkSet.has(key)) {
+          return true;
+        } else if (nonceNetworkSet.size < _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit) || !this.isFinalState(status)) {
+          nonceNetworkSet.add(key);
+          return true;
+        }
+      }
+      return false;
+    });
+    txsToKeep.reverse();
+    return txsToKeep;
+  }
+  /**
+   * Determines if the transaction is in a final state.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isFinalState(status) {
+    return status === "rejected" /* rejected */ || status === "confirmed" /* confirmed */ || status === "failed" /* failed */;
+  }
+  /**
+   * Whether the transaction has at least completed all local processing.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isLocalFinalState(status) {
+    return [
+      "confirmed" /* confirmed */,
+      "failed" /* failed */,
+      "rejected" /* rejected */,
+      "submitted" /* submitted */
+    ].includes(status);
+  }
+  async requestApproval(txMeta, { shouldShowRequest }) {
+    const id = this.getApprovalId(txMeta);
+    const { origin } = txMeta;
+    const type = _controllerutils.ApprovalType.Transaction;
+    const requestData = { txId: txMeta.id };
+    return await this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id,
+        origin: origin || _controllerutils.ORIGIN_METAMASK,
+        type,
+        requestData,
+        expectsResult: true
+      },
+      shouldShowRequest
+    );
+  }
+  getTransaction(transactionId) {
+    const { transactions } = this.state;
+    return transactions.find(({ id }) => id === transactionId);
+  }
+  getApprovalId(txMeta) {
+    return String(txMeta.id);
+  }
+  isTransactionCompleted(transactionId) {
+    const transaction = this.getTransaction(transactionId);
+    if (!transaction) {
+      return { meta: void 0, isCompleted: false };
+    }
+    const isCompleted = this.isLocalFinalState(transaction.status);
+    return { meta: transaction, isCompleted };
+  }
+  getChainId(networkClientId) {
+    if (networkClientId) {
+      return this.messagingSystem.call(
+        `NetworkController:getNetworkClientById`,
+        networkClientId
+      ).configuration.chainId;
+    }
+    const { providerConfig } = this.getNetworkState();
+    return providerConfig.chainId;
+  }
+  prepareUnsignedEthTx(chainId, txParams) {
+    return _tx.TransactionFactory.fromTxData(txParams, {
+      freeze: false,
+      common: this.getCommonConfiguration(chainId)
+    });
+  }
+  /**
+   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
+   * specifying which chain, network, hardfork and EIPs to support for
+   * a transaction. By referencing this configuration, and analyzing the fields
+   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
+   * transaction type to use.
+   *
+   * @param chainId - The chainId to use for the configuration.
+   * @returns common configuration object
+   */
+  getCommonConfiguration(chainId) {
+    const customChainParams = {
+      chainId: parseInt(chainId, 16),
+      defaultHardfork: HARDFORK
+    };
+    return _common.Common.custom(customChainParams);
+  }
+  onIncomingTransactions({
+    added,
+    updated
+  }) {
+    this.update((state) => {
+      const { transactions: currentTransactions } = state;
+      const updatedTransactions = [
+        ...added,
+        ...currentTransactions.map((originalTransaction) => {
+          const updatedTransaction = updated.find(
+            ({ hash }) => hash === originalTransaction.hash
+          );
+          return updatedTransaction ?? originalTransaction;
+        })
+      ];
+      state.transactions = this.trimTransactionsForState(updatedTransactions);
+    });
+  }
+  onUpdatedLastFetchedBlockNumbers({
+    lastFetchedBlockNumbers,
+    blockNumber
+  }) {
+    this.update((state) => {
+      state.lastFetchedBlockNumbers = lastFetchedBlockNumbers;
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:incomingTransactionBlockReceived`,
+      blockNumber
+    );
+  }
+  generateDappSuggestedGasFees(txParams, origin) {
+    if (!origin || origin === _controllerutils.ORIGIN_METAMASK) {
+      return void 0;
+    }
+    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas, gas } = txParams;
+    if (gasPrice === void 0 && maxFeePerGas === void 0 && maxPriorityFeePerGas === void 0 && gas === void 0) {
+      return void 0;
+    }
+    const dappSuggestedGasFees = {};
+    if (gasPrice !== void 0) {
+      dappSuggestedGasFees.gasPrice = gasPrice;
+    } else if (maxFeePerGas !== void 0 || maxPriorityFeePerGas !== void 0) {
+      dappSuggestedGasFees.maxFeePerGas = maxFeePerGas;
+      dappSuggestedGasFees.maxPriorityFeePerGas = maxPriorityFeePerGas;
+    }
+    if (gas !== void 0) {
+      dappSuggestedGasFees.gas = gas;
+    }
+    return dappSuggestedGasFees;
+  }
+  /**
+   * Validates and adds external provided transaction to state.
+   *
+   * @param transactionMeta - Nominated external transaction to be added to state.
+   * @returns The new transaction.
+   */
+  addExternalTransaction(transactionMeta) {
+    const { chainId } = transactionMeta;
+    const { transactions } = this.state;
+    const fromAddress = transactionMeta?.txParams?.from;
+    const sameFromAndNetworkTransactions = transactions.filter(
+      (transaction) => transaction.txParams.from === fromAddress && transaction.chainId === chainId
+    );
+    const confirmedTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "confirmed" /* confirmed */
+    );
+    const pendingTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "submitted" /* submitted */
+    );
+    _chunk7LXE4KHVjs.validateConfirmedExternalTransaction.call(void 0, 
+      transactionMeta,
+      confirmedTxs,
+      pendingTxs
+    );
+    const newTransactionMeta = (transactionMeta.history ?? []).length === 0 && !this.isHistoryDisabled ? _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, transactionMeta) : transactionMeta;
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        newTransactionMeta
+      ]);
+    });
+    return newTransactionMeta;
+  }
+  /**
+   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
+   * in the transactions have the same nonce.
+   *
+   * @param transactionId - Used to identify original transaction.
+   */
+  markNonceDuplicatesDropped(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    const nonce = transactionMeta.txParams?.nonce;
+    const from = transactionMeta.txParams?.from;
+    const { chainId } = transactionMeta;
+    const sameNonceTransactions = this.state.transactions.filter(
+      (transaction) => transaction.id !== transactionId && transaction.txParams.from === from && transaction.txParams.nonce === nonce && transaction.chainId === chainId && transaction.type !== "incoming" /* incoming */
+    );
+    const sameNonceTransactionIds = sameNonceTransactions.map(
+      (transaction) => transaction.id
+    );
+    if (sameNonceTransactions.length === 0) {
+      return;
+    }
+    this.update((state) => {
+      for (const transaction of state.transactions) {
+        if (sameNonceTransactionIds.includes(transaction.id)) {
+          transaction.replacedBy = transactionMeta?.hash;
+          transaction.replacedById = transactionMeta?.id;
+        }
+      }
+    });
+    for (const transaction of this.state.transactions) {
+      if (sameNonceTransactionIds.includes(transaction.id) && transaction.status !== "failed" /* failed */) {
+        this.setTransactionStatusDropped(transaction);
+      }
+    }
+  }
+  /**
+   * Method to set transaction status to dropped.
+   *
+   * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.
+   */
+  setTransactionStatusDropped(transactionMeta) {
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "dropped" /* dropped */
+    };
+    this.messagingSystem.publish(`${controllerName}:transactionDropped`, {
+      transactionMeta: updatedTransactionMeta
+    });
+    this.updateTransaction(
+      updatedTransactionMeta,
+      "TransactionController#setTransactionStatusDropped - Transaction dropped"
+    );
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Get transaction with provided actionId.
+   *
+   * @param actionId - Unique ID to prevent duplicate requests
+   * @returns the filtered transaction
+   */
+  getTransactionWithActionId(actionId) {
+    return this.state.transactions.find(
+      (transaction) => actionId && transaction.actionId === actionId
+    );
+  }
+  async waitForTransactionFinished(transactionId) {
+    return new Promise((resolve) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).once(`${transactionId}:finished`, (txMeta) => {
+        resolve(txMeta);
+      });
+    });
+  }
+  /**
+   * Updates the r, s, and v properties of a TransactionMeta object
+   * with values from a signed transaction.
+   *
+   * @param transactionMeta - The TransactionMeta object to update.
+   * @param signedTx - The encompassing type for all transaction types containing r, s, and v values.
+   */
+  async updateTransactionMetaRSV(transactionMeta, signedTx) {
+    const transactionMetaWithRsv = _lodash.cloneDeep.call(void 0, transactionMeta);
+    for (const key of ["r", "s", "v"]) {
+      const value = signedTx[key];
+      if (value === void 0 || value === null) {
+        continue;
+      }
+      transactionMetaWithRsv[key] = _utils.add0x.call(void 0, value.toString(16));
+    }
+    return transactionMetaWithRsv;
+  }
+  async getEIP1559Compatibility(networkClientId) {
+    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility(networkClientId);
+    const currentAccountIsEIP1559Compatible = await this.getCurrentAccountEIP1559Compatibility();
+    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
+  }
+  async signTransaction(transactionMeta, txParams) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Signing transaction", txParams);
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    this.inProcessOfSigning.add(transactionMeta.id);
+    const signedTx = await new Promise((resolve, reject) => {
+      this.sign?.(
+        unsignedEthTx,
+        txParams.from,
+        ...this.getAdditionalSignArguments(transactionMeta)
+      ).then(resolve, reject);
+      this.signAbortCallbacks.set(
+        transactionMeta.id,
+        () => reject(new Error("Signing aborted by user"))
+      );
+    });
+    this.signAbortCallbacks.delete(transactionMeta.id);
+    if (!signedTx) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status as no signed transaction");
+      return void 0;
+    }
+    if (!this.afterSign(transactionMeta, signedTx)) {
+      this.updateTransaction(
+        transactionMeta,
+        "TransactionController#signTransaction - Update after sign"
+      );
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status based on hook");
+      return void 0;
+    }
+    const transactionMetaWithRsv = {
+      ...await this.updateTransactionMetaRSV(transactionMeta, signedTx),
+      status: "signed" /* signed */
+    };
+    this.updateTransaction(
+      transactionMetaWithRsv,
+      "TransactionController#approveTransaction - Transaction signed"
+    );
+    this.onTransactionStatusChange(transactionMetaWithRsv);
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const transactionMetaWithRawTx = _lodash.merge.call(void 0, {}, transactionMetaWithRsv, {
+      rawTx
+    });
+    this.updateTransaction(
+      transactionMetaWithRawTx,
+      "TransactionController#approveTransaction - RawTransaction added"
+    );
+    return rawTx;
+  }
+  onTransactionStatusChange(transactionMeta) {
+    this.messagingSystem.publish(`${controllerName}:transactionStatusUpdated`, {
+      transactionMeta
+    });
+  }
+  getNonceTrackerTransactions(status, address, chainId = this.getChainId()) {
+    return _chunkZNZEJDOEjs.getAndFormatTransactionsForNonceTracker.call(void 0, 
+      chainId,
+      address,
+      status,
+      this.state.transactions
+    );
+  }
+  onConfirmedTransaction(transactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Processing confirmed transaction", transactionMeta.id);
+    this.markNonceDuplicatesDropped(transactionMeta.id);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionConfirmed`,
+      transactionMeta
+    );
+    this.onTransactionStatusChange(transactionMeta);
+    this.updatePostBalance(transactionMeta);
+  }
+  async updatePostBalance(transactionMeta) {
+    try {
+      if (transactionMeta.type !== "swap" /* swap */) {
+        return;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      const { updatedTransactionMeta, approvalTransactionMeta } = await _chunk5OQ373JSjs.updatePostTransactionBalance.call(void 0, transactionMeta, {
+        ethQuery,
+        getTransaction: this.getTransaction.bind(this),
+        updateTransaction: this.updateTransaction.bind(this)
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:postTransactionBalanceUpdated`,
+        {
+          transactionMeta: updatedTransactionMeta,
+          approvalTransactionMeta
+        }
+      );
+    } catch (error) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while updating post transaction balance", error);
+    }
+  }
+  async publishTransactionForRetry(ethQuery, rawTx, transactionMeta) {
+    try {
+      const hash = await this.publishTransaction(ethQuery, rawTx);
+      return hash;
+    } catch (error) {
+      if (this.isTransactionAlreadyConfirmedError(error)) {
+        await this.pendingTransactionTracker.forceCheckTransaction(
+          transactionMeta
+        );
+        throw new Error("Previous transaction is already confirmed");
+      }
+      throw error;
+    }
+  }
+  /**
+   * Ensures that error is a nonce issue
+   *
+   * @param error - The error to check
+   * @returns Whether or not the error is a nonce issue
+   */
+  // TODO: Replace `any` with type
+  // Some networks are returning original error in the data field
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  isTransactionAlreadyConfirmedError(error) {
+    return error?.message?.includes("nonce too low") || error?.data?.message?.includes("nonce too low");
+  }
+  async updateSimulationData(transactionId, simulationData) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+        "Cannot update simulation data as transaction not found",
+        transactionId,
+        simulationData
+      );
+      return;
+    }
+    this.updateTransaction(
+      { ...transactionMeta, simulationData },
+      "TransactionController#updateSimulationData - Update simulation data"
+    );
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updated simulation data", transactionId, simulationData);
+  }
+};
+_internalEvents = new WeakMap();
+_incomingTransactionOptions = new WeakMap();
+_pendingTransactionOptions = new WeakMap();
+_transactionHistoryLimit = new WeakMap();
+_isSimulationEnabled = new WeakMap();
+_multichainTrackingHelper = new WeakMap();
+_createNonceTracker = new WeakSet();
+createNonceTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  return new (0, _noncetracker.NonceTracker)({
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    provider,
+    blockTracker,
+    getPendingTransactions: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn).bind(
+      this,
+      chainId
+    ),
+    getConfirmedTransactions: this.getNonceTrackerTransactions.bind(
+      this,
+      "confirmed" /* confirmed */
+    )
+  });
+};
+_createIncomingTransactionHelper = new WeakSet();
+createIncomingTransactionHelper_fn = function({
+  blockTracker,
+  etherscanRemoteTransactionSource,
+  chainId
+}) {
+  const incomingTransactionHelper = new (0, _chunkDTDTOMTBjs.IncomingTransactionHelper)({
+    blockTracker,
+    getCurrentAccount: this.getSelectedAddress,
+    getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+    getChainId: chainId ? () => chainId : this.getChainId.bind(this),
+    isEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).isEnabled,
+    queryEntireHistory: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).queryEntireHistory,
+    remoteTransactionSource: etherscanRemoteTransactionSource,
+    transactionLimit: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit),
+    updateTransactions: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).updateTransactions
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn).call(this, incomingTransactionHelper);
+  return incomingTransactionHelper;
+};
+_createPendingTransactionTracker = new WeakSet();
+createPendingTransactionTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  const ethQuery = new (0, _ethquery2.default)(provider);
+  const getChainId = chainId ? () => chainId : this.getChainId.bind(this);
+  const pendingTransactionTracker = new (0, _chunk5XBULBP2js.PendingTransactionTracker)({
+    approveTransaction: async (transactionId) => {
+      await this.approveTransaction(transactionId);
+    },
+    blockTracker,
+    getChainId,
+    getEthQuery: () => ethQuery,
+    getTransactions: () => this.state.transactions,
+    isResubmitEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pendingTransactionOptions).isResubmitEnabled,
+    getGlobalLock: () => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).acquireNonceLockForChainIdKey({
+      chainId: getChainId()
+    }),
+    publishTransaction: this.publishTransaction.bind(this),
+    hooks: {
+      beforeCheckPendingTransaction: this.beforeCheckPendingTransaction.bind(this),
+      beforePublish: this.beforePublish.bind(this)
+    }
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn).call(this, pendingTransactionTracker);
+  return pendingTransactionTracker;
+};
+_checkForPendingTransactionAndStartPolling = new WeakMap();
+_stopAllTracking = new WeakSet();
+stopAllTracking_fn = function() {
+  this.pendingTransactionTracker.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).call(this, this.pendingTransactionTracker);
+  this.incomingTransactionHelper.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).call(this, this.incomingTransactionHelper);
+  _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllTracking();
+};
+_removeIncomingTransactionHelperListeners = new WeakSet();
+removeIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.removeAllListeners("transactions");
+  incomingTransactionHelper.hub.removeAllListeners(
+    "updatedLastFetchedBlockNumbers"
+  );
+};
+_addIncomingTransactionHelperListeners = new WeakSet();
+addIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.on(
+    "transactions",
+    this.onIncomingTransactions.bind(this)
+  );
+  incomingTransactionHelper.hub.on(
+    "updatedLastFetchedBlockNumbers",
+    this.onUpdatedLastFetchedBlockNumbers.bind(this)
+  );
+};
+_removePendingTransactionTrackerListeners = new WeakSet();
+removePendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.removeAllListeners("transaction-confirmed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-dropped");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-failed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-updated");
+};
+_addPendingTransactionTrackerListeners = new WeakSet();
+addPendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.on(
+    "transaction-confirmed",
+    this.onConfirmedTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-dropped",
+    this.setTransactionStatusDropped.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-failed",
+    this.failTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-updated",
+    this.updateTransaction.bind(this)
+  );
+};
+_getNonceTrackerPendingTransactions = new WeakSet();
+getNonceTrackerPendingTransactions_fn = function(chainId, address) {
+  const standardPendingTransactions = this.getNonceTrackerTransactions(
+    "submitted" /* submitted */,
+    address,
+    chainId
+  );
+  const externalPendingTransactions = this.getExternalPendingTransactions(
+    address,
+    chainId
+  );
+  return [...standardPendingTransactions, ...externalPendingTransactions];
+};
+_getGasFeeFlows = new WeakSet();
+getGasFeeFlows_fn = function() {
+  return [new (0, _chunkFHG5GY6Fjs.LineaGasFeeFlow)(), new (0, _chunkPF3UOCRWjs.DefaultGasFeeFlow)()];
+};
+_getLayer1GasFeeFlows = new WeakSet();
+getLayer1GasFeeFlows_fn = function() {
+  return [];
+};
+_updateTransactionInternal = new WeakSet();
+updateTransactionInternal_fn = function(transactionMeta, { note, skipHistory }) {
+  const normalizedTransaction = {
+    ...transactionMeta,
+    txParams: _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionMeta.txParams)
+  };
+  _chunkVH47Q6TSjs.validateTxParams.call(void 0, normalizedTransaction.txParams);
+  const transactionWithUpdatedHistory = skipHistory === true ? normalizedTransaction : _chunkQP75SWIQjs.updateTransactionHistory.call(void 0, 
+    normalizedTransaction,
+    note ?? "Transaction updated"
+  );
+  this.update((state) => {
+    const index = state.transactions.findIndex(
+      ({ id }) => transactionMeta.id === id
+    );
+    state.transactions[index] = transactionWithUpdatedHistory;
+  });
+};
+_getSimulationData = new WeakSet();
+getSimulationData_fn = async function(transactionMeta) {
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isSimulationEnabled).call(this)) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping simulation as disabled");
+    return {
+      error: {
+        message: "Simulation disabled",
+        isReverted: false
+      },
+      tokenBalanceChanges: []
+    };
+  }
+  const { chainId, txParams } = transactionMeta;
+  const { from, to, value, data } = txParams;
+  const simulationData = await _chunkEAUE4RCUjs.getSimulationData.call(void 0, {
+    chainId,
+    from,
+    to,
+    value,
+    data
+  });
+  return simulationData;
+};
+
+
+
+
+
+
+
+exports.HARDFORK = HARDFORK; exports.CANCEL_RATE = CANCEL_RATE; exports.SPEED_UP_RATE = SPEED_UP_RATE; exports.ApprovalState = ApprovalState; exports.TransactionController = TransactionController;
+//# sourceMappingURL=chunk-AFM3ZOKZ.js.map
\ No newline at end of file
diff --git a/dist/chunk-BOZ2GRIU.js b/dist/chunk-BOZ2GRIU.js
new file mode 100644
index 0000000000000000000000000000000000000000..e9577a026ce1ace2bc46abe6a369c57d9469fb1e
--- /dev/null
+++ b/dist/chunk-BOZ2GRIU.js
@@ -0,0 +1,56 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkITDY6AIZjs = require('./chunk-ITDY6AIZ.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/simulation-api.ts
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "simulation-api");
+var RPC_METHOD = "infura_simulateTransactions";
+var BASE_URL = "https://tx-sentinel-{0}.api.cx.metamask.io/";
+var SUBDOMAIN_BY_CHAIN_ID = {
+  [_chunkITDY6AIZjs.CHAIN_IDS.MAINNET]: "ethereum-mainnet",
+  [_chunkITDY6AIZjs.CHAIN_IDS.GOERLI]: "ethereum-goerli",
+  [_chunkITDY6AIZjs.CHAIN_IDS.SEPOLIA]: "ethereum-sepolia",
+  [_chunkITDY6AIZjs.CHAIN_IDS.LINEA_MAINNET]: "linea-mainnet",
+  [_chunkITDY6AIZjs.CHAIN_IDS.LINEA_GOERLI]: "linea-goerli",
+  [_chunkITDY6AIZjs.CHAIN_IDS.ARBITRUM]: "arbitrum-mainnet",
+  [_chunkITDY6AIZjs.CHAIN_IDS.AVALANCHE]: "avalanche-mainnet",
+  [_chunkITDY6AIZjs.CHAIN_IDS.OPTIMISM]: "optimism-mainnet",
+  [_chunkITDY6AIZjs.CHAIN_IDS.POLYGON]: "polygon-mainnet",
+  [_chunkITDY6AIZjs.CHAIN_IDS.BSC]: "bsc-mainnet"
+};
+async function simulateTransactions(chainId, request) {
+  const url = getUrl(chainId);
+  log("Sending request", url, request);
+  const response = await fetch(url, {
+    method: "POST",
+    body: JSON.stringify({
+      id: "1",
+      jsonrpc: "2.0",
+      method: RPC_METHOD,
+      params: [request]
+    })
+  });
+  const responseJson = await response.json();
+  log("Received response", responseJson);
+  if (responseJson.error) {
+    throw responseJson.error;
+  }
+  return responseJson?.result;
+}
+function getUrl(chainId) {
+  const subdomain = SUBDOMAIN_BY_CHAIN_ID[chainId];
+  if (!subdomain) {
+    log("Chain is not supported", chainId);
+    throw new Error(`Chain is not supported: ${chainId}`);
+  }
+  return BASE_URL.replace("{0}", subdomain);
+}
+
+
+
+exports.simulateTransactions = simulateTransactions;
+//# sourceMappingURL=chunk-BOZ2GRIU.js.map
\ No newline at end of file
diff --git a/dist/chunk-EAUE4RCU.js b/dist/chunk-EAUE4RCU.js
new file mode 100644
index 0000000000000000000000000000000000000000..c2b41fd08910b8985ce017916cb4918549e1cae1
--- /dev/null
+++ b/dist/chunk-EAUE4RCU.js
@@ -0,0 +1,255 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkBOZ2GRIUjs = require('./chunk-BOZ2GRIU.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/simulation.ts
+var _abi = require('@ethersproject/abi');
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "simulation");
+async function getSimulationData(request) {
+  const { chainId, from, to, value, data } = request;
+  log("Getting simulation data", request);
+  try {
+    const response = await _chunkBOZ2GRIUjs.simulateTransactions.call(void 0, chainId, {
+      transactions: [{ from, to, value, data }],
+      withCallTrace: true,
+      withLogs: true
+    });
+    if (response.transactions?.[0]?.error) {
+      throw { message: response.transactions[0].error };
+    }
+    const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+    const events = getEvents(response);
+    log("Parsed events", events);
+    const tokenBalanceChanges = await getTokenBalanceChanges(request, events);
+    return {
+      nativeBalanceChange,
+      tokenBalanceChanges
+    };
+  } catch (error) {
+    log("Failed to get simulation data", error, request);
+    const rawError = error;
+    return {
+      tokenBalanceChanges: [],
+      error: {
+        code: rawError.code,
+        message: rawError.message,
+        isReverted: rawError.message?.includes("execution reverted") ?? false
+      }
+    };
+  }
+}
+function getNativeBalanceChange(userAddress, response) {
+  const transactionResponse = response.transactions[0];
+  if (!transactionResponse) {
+    return void 0;
+  }
+  const { stateDiff } = transactionResponse;
+  const previousBalance = stateDiff?.pre?.[userAddress]?.balance;
+  const newBalance = stateDiff?.post?.[userAddress]?.balance;
+  if (!previousBalance || !newBalance) {
+    return void 0;
+  }
+  return getSimulationBalanceChange(previousBalance, newBalance);
+}
+function getEvents(response) {
+  const logs = extractLogs(
+    response.transactions[0]?.callTrace ?? {}
+  );
+  log("Extracted logs", logs);
+  const erc20Interface = new (0, _abi.Interface)(_metamaskethabis.abiERC20);
+  const erc721Interface = new (0, _abi.Interface)(_metamaskethabis.abiERC721);
+  const erc1155Interface = new (0, _abi.Interface)(_metamaskethabis.abiERC1155);
+  return logs.map((currentLog) => {
+    const event = parseLog(
+      currentLog,
+      erc20Interface,
+      erc721Interface,
+      erc1155Interface
+    );
+    if (!event) {
+      log("Failed to parse log", currentLog);
+      return void 0;
+    }
+    const inputs = event.abi.find((e) => e.name === event.name)?.inputs;
+    if (!inputs) {
+      log("Failed to find inputs for event", event);
+      return void 0;
+    }
+    const args = parseEventArgs(event.args, inputs);
+    return {
+      contractAddress: currentLog.address,
+      tokenStandard: event.standard,
+      name: event.name,
+      args,
+      abi: event.abi
+    };
+  }).filter((e) => e !== void 0);
+}
+function parseEventArgs(args, abiInputs) {
+  return args.reduce((result, arg, index) => {
+    const name = abiInputs[index].name.replace("_", "");
+    const value = parseEventArgValue(arg);
+    result[name] = value;
+    return result;
+  }, {});
+}
+function parseEventArgValue(value) {
+  if (Array.isArray(value)) {
+    return value.map(parseEventArgValue);
+  }
+  return (value.toHexString?.() ?? value).toLowerCase();
+}
+async function getTokenBalanceChanges(request, events) {
+  const balanceTransactionsByToken = getTokenBalanceTransactions(
+    request,
+    events
+  );
+  const balanceTransactions = [...balanceTransactionsByToken.values()];
+  log("Generated balance transactions", balanceTransactions);
+  if (!balanceTransactions.length) {
+    return [];
+  }
+  const response = await _chunkBOZ2GRIUjs.simulateTransactions.call(void 0, request.chainId, {
+    transactions: [...balanceTransactions, request, ...balanceTransactions]
+  });
+  log("Balance simulation response", response);
+  if (response.transactions.length !== balanceTransactions.length * 2 + 1) {
+    throw new Error("Invalid response from simulation API");
+  }
+  return [...balanceTransactionsByToken.keys()].map((token, index) => {
+    const previousBalance = normalizeReturnValue(
+      response.transactions[index].return
+    );
+    const newBalance = normalizeReturnValue(
+      response.transactions[index + balanceTransactions.length + 1].return
+    );
+    const balanceChange = getSimulationBalanceChange(
+      previousBalance,
+      newBalance
+    );
+    if (!balanceChange) {
+      return void 0;
+    }
+    return {
+      ...token,
+      ...balanceChange
+    };
+  }).filter((change) => change !== void 0);
+}
+function getTokenBalanceTransactions(request, events) {
+  const tokenKeys = /* @__PURE__ */ new Set();
+  return events.reduce((result, event) => {
+    if (!["Transfer", "TransferSingle", "TransferBatch"].includes(event.name) || ![event.args.from, event.args.to].includes(request.from)) {
+      log("Ignoring event", event);
+      return result;
+    }
+    let tokenIds = [void 0];
+    if (event.tokenStandard === "erc721" /* erc721 */) {
+      tokenIds = [event.args.tokenId];
+    }
+    if (event.tokenStandard === "erc1155" /* erc1155 */ && event.name === "TransferSingle") {
+      tokenIds = [event.args.id];
+    }
+    if (event.tokenStandard === "erc1155" /* erc1155 */ && event.name === "TransferBatch") {
+      tokenIds = event.args.ids;
+    }
+    log("Extracted token ids", tokenIds);
+    for (const tokenId of tokenIds) {
+      const simulationToken = {
+        address: event.contractAddress,
+        standard: event.tokenStandard,
+        id: tokenId
+      };
+      const tokenKey = JSON.stringify(simulationToken);
+      if (tokenKeys.has(tokenKey)) {
+        log(
+          "Ignoring additional event with same contract and token ID",
+          simulationToken
+        );
+        continue;
+      }
+      tokenKeys.add(tokenKey);
+      const parameters = [request.from];
+      if (event.tokenStandard === "erc1155" /* erc1155 */) {
+        parameters.push(tokenId);
+      }
+      result.set(simulationToken, {
+        from: request.from,
+        to: event.contractAddress,
+        data: new (0, _abi.Interface)(event.abi).encodeFunctionData(
+          "balanceOf",
+          parameters
+        )
+      });
+    }
+    return result;
+  }, /* @__PURE__ */ new Map());
+}
+function parseLog(eventLog, erc20, erc721, erc1155) {
+  const abisByStandard = [
+    {
+      abi: _metamaskethabis.abiERC20,
+      contractInterface: erc20,
+      standard: "erc20" /* erc20 */
+    },
+    {
+      abi: _metamaskethabis.abiERC721,
+      contractInterface: erc721,
+      standard: "erc721" /* erc721 */
+    },
+    {
+      abi: _metamaskethabis.abiERC1155,
+      contractInterface: erc1155,
+      standard: "erc1155" /* erc1155 */
+    }
+  ];
+  for (const { abi, contractInterface, standard } of abisByStandard) {
+    try {
+      return {
+        ...contractInterface.parseLog(eventLog),
+        abi,
+        standard
+      };
+    } catch (e) {
+      continue;
+    }
+  }
+  return void 0;
+}
+function extractLogs(call) {
+  const logs = call.logs ?? [];
+  const nestedCalls = call.calls ?? [];
+  return [
+    ...logs,
+    ...nestedCalls.map((nestedCall) => extractLogs(nestedCall)).flat()
+  ];
+}
+function getSimulationBalanceChange(previousBalance, newBalance) {
+  const differenceBN = _controllerutils.hexToBN.call(void 0, newBalance).sub(_controllerutils.hexToBN.call(void 0, previousBalance));
+  const isDecrease = differenceBN.isNeg();
+  const difference = _controllerutils.toHex.call(void 0, differenceBN.abs());
+  if (differenceBN.isZero()) {
+    log("Balance change is zero");
+    return void 0;
+  }
+  return {
+    previousBalance,
+    newBalance,
+    difference,
+    isDecrease
+  };
+}
+function normalizeReturnValue(value) {
+  return _controllerutils.toHex.call(void 0, _controllerutils.hexToBN.call(void 0, value));
+}
+
+
+
+exports.getSimulationData = getSimulationData;
+//# sourceMappingURL=chunk-EAUE4RCU.js.map
\ No newline at end of file
diff --git a/dist/chunk-FHG5GY6F.js b/dist/chunk-FHG5GY6F.js
new file mode 100644
index 0000000000000000000000000000000000000000..5bdbbc258b9a0805e33e7f4170789e74fad7e652
--- /dev/null
+++ b/dist/chunk-FHG5GY6F.js
@@ -0,0 +1,121 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkPF3UOCRWjs = require('./chunk-PF3UOCRW.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunkVEJ3MIZGjs = require('./chunk-VEJ3MIZG.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/LineaGasFeeFlow.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "linea-gas-fee-flow");
+var LINEA_CHAIN_IDS = [
+  _controllerutils.ChainId["linea-mainnet"],
+  _controllerutils.ChainId["linea-goerli"],
+  _controllerutils.ChainId["linea-sepolia"]
+];
+var BASE_FEE_MULTIPLIERS = {
+  low: 1,
+  medium: 1.35,
+  high: 1.7
+};
+var PRIORITY_FEE_MULTIPLIERS = {
+  low: 1,
+  medium: 1.05,
+  high: 1.1
+};
+var _getLineaGasFees, getLineaGasFees_fn, _getLineaResponse, getLineaResponse_fn, _getValuesFromMultipliers, getValuesFromMultipliers_fn, _getMaxFees, getMaxFees_fn, _feesToString, feesToString_fn;
+var LineaGasFeeFlow = class {
+  constructor() {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLineaGasFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLineaResponse);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getValuesFromMultipliers);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getMaxFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _feesToString);
+  }
+  matchesTransaction(transactionMeta) {
+    return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+  }
+  async getGasFees(request) {
+    try {
+      return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLineaGasFees, getLineaGasFees_fn).call(this, request);
+    } catch (error) {
+      log("Using default flow as fallback due to error", error);
+      return new (0, _chunkPF3UOCRWjs.DefaultGasFeeFlow)().getGasFees(request);
+    }
+  }
+};
+_getLineaGasFees = new WeakSet();
+getLineaGasFees_fn = async function(request) {
+  const { ethQuery, transactionMeta } = request;
+  const lineaResponse = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLineaResponse, getLineaResponse_fn).call(this, transactionMeta, ethQuery);
+  log("Received Linea response", lineaResponse);
+  const baseFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getValuesFromMultipliers, getValuesFromMultipliers_fn).call(this, lineaResponse.baseFeePerGas, BASE_FEE_MULTIPLIERS);
+  log("Generated base fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, baseFees));
+  const priorityFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getValuesFromMultipliers, getValuesFromMultipliers_fn).call(this, lineaResponse.priorityFeePerGas, PRIORITY_FEE_MULTIPLIERS);
+  log("Generated priority fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, priorityFees));
+  const maxFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getMaxFees, getMaxFees_fn).call(this, baseFees, priorityFees);
+  log("Generated max fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, maxFees));
+  const estimates = Object.values(_chunkVEJ3MIZGjs.GasFeeEstimateLevel).reduce(
+    (result, level) => ({
+      ...result,
+      [level]: {
+        maxFeePerGas: _controllerutils.toHex.call(void 0, maxFees[level]),
+        maxPriorityFeePerGas: _controllerutils.toHex.call(void 0, priorityFees[level])
+      }
+    }),
+    {}
+  );
+  return { estimates };
+};
+_getLineaResponse = new WeakSet();
+getLineaResponse_fn = function(transactionMeta, ethQuery) {
+  return _controllerutils.query.call(void 0, ethQuery, "linea_estimateGas", [
+    {
+      from: transactionMeta.txParams.from,
+      to: transactionMeta.txParams.to,
+      value: transactionMeta.txParams.value,
+      input: transactionMeta.txParams.data,
+      // Required in request but no impact on response.
+      gasPrice: "0x100000000"
+    }
+  ]);
+};
+_getValuesFromMultipliers = new WeakSet();
+getValuesFromMultipliers_fn = function(value, multipliers) {
+  const base = _controllerutils.hexToBN.call(void 0, value);
+  const low = base.muln(multipliers.low);
+  const medium = base.muln(multipliers.medium);
+  const high = base.muln(multipliers.high);
+  return {
+    low,
+    medium,
+    high
+  };
+};
+_getMaxFees = new WeakSet();
+getMaxFees_fn = function(baseFees, priorityFees) {
+  return {
+    low: baseFees.low.add(priorityFees.low),
+    medium: baseFees.medium.add(priorityFees.medium),
+    high: baseFees.high.add(priorityFees.high)
+  };
+};
+_feesToString = new WeakSet();
+feesToString_fn = function(fees) {
+  return Object.values(_chunkVEJ3MIZGjs.GasFeeEstimateLevel).map(
+    (level) => fees[level].toString(10)
+  );
+};
+
+
+
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+//# sourceMappingURL=chunk-FHG5GY6F.js.map
\ No newline at end of file
diff --git a/dist/chunk-PF3UOCRW.js b/dist/chunk-PF3UOCRW.js
new file mode 100644
index 0000000000000000000000000000000000000000..7719c384ed9f9fc8bdf08b3759866b733aefe285
--- /dev/null
+++ b/dist/chunk-PF3UOCRW.js
@@ -0,0 +1,90 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunk5IHLDAOFjs = require('./chunk-5IHLDAOF.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunkVEJ3MIZGjs = require('./chunk-VEJ3MIZG.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/DefaultGasFeeFlow.ts
+var _gasfeecontroller = require('@metamask/gas-fee-controller');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "default-gas-fee-flow");
+var _getEstimateLevel, getEstimateLevel_fn, _getFeeMarketLevel, getFeeMarketLevel_fn, _getLegacyLevel, getLegacyLevel_fn;
+var DefaultGasFeeFlow = class {
+  constructor() {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getEstimateLevel);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getFeeMarketLevel);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLegacyLevel);
+  }
+  matchesTransaction(_transactionMeta) {
+    return true;
+  }
+  async getGasFees(request) {
+    const { getGasFeeControllerEstimates, transactionMeta } = request;
+    const { networkClientId } = transactionMeta;
+    const { gasEstimateType, gasFeeEstimates } = await getGasFeeControllerEstimates({ networkClientId });
+    if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+      log("Using fee market estimates", gasFeeEstimates);
+    } else if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.LEGACY) {
+      log("Using legacy estimates", gasFeeEstimates);
+    } else {
+      throw new Error(`'No gas fee estimates available`);
+    }
+    const estimates = Object.values(_chunkVEJ3MIZGjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getEstimateLevel, getEstimateLevel_fn).call(this, {
+          gasEstimateType,
+          gasFeeEstimates,
+          level
+        })
+      }),
+      {}
+    );
+    return { estimates };
+  }
+};
+_getEstimateLevel = new WeakSet();
+getEstimateLevel_fn = function({
+  gasEstimateType,
+  gasFeeEstimates,
+  level
+}) {
+  if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+    return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getFeeMarketLevel, getFeeMarketLevel_fn).call(this, gasFeeEstimates, level);
+  }
+  return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLegacyLevel, getLegacyLevel_fn).call(this, gasFeeEstimates, level);
+};
+_getFeeMarketLevel = new WeakSet();
+getFeeMarketLevel_fn = function(gasFeeEstimates, level) {
+  const maxFeePerGas = _chunk5IHLDAOFjs.gweiDecimalToWeiHex.call(void 0, 
+    gasFeeEstimates[level].suggestedMaxFeePerGas
+  );
+  const maxPriorityFeePerGas = _chunk5IHLDAOFjs.gweiDecimalToWeiHex.call(void 0, 
+    gasFeeEstimates[level].suggestedMaxPriorityFeePerGas
+  );
+  return {
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  };
+};
+_getLegacyLevel = new WeakSet();
+getLegacyLevel_fn = function(gasFeeEstimates, level) {
+  const gasPrice = _chunk5IHLDAOFjs.gweiDecimalToWeiHex.call(void 0, gasFeeEstimates[level]);
+  return {
+    maxFeePerGas: gasPrice,
+    maxPriorityFeePerGas: gasPrice
+  };
+};
+
+
+
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+//# sourceMappingURL=chunk-PF3UOCRW.js.map
\ No newline at end of file
diff --git a/dist/chunk-QEX3QMSL.js b/dist/chunk-QEX3QMSL.js
new file mode 100644
index 0000000000000000000000000000000000000000..d455304eb6d7d559de45a28aff4431598b16cb54
--- /dev/null
+++ b/dist/chunk-QEX3QMSL.js
@@ -0,0 +1,182 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkR7NJVDWNjs = require('./chunk-R7NJVDWN.js');
+
+
+var _chunkTZTP4JVAjs = require('./chunk-TZTP4JVA.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/helpers/GasFeePoller.ts
+var _utils = require('@metamask/utils');
+var _events = require('events'); var _events2 = _interopRequireDefault(_events);
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "gas-fee-poller");
+var INTERVAL_MILLISECONDS = 1e4;
+var _gasFeeFlows, _getEthQuery, _getGasFeeControllerEstimates, _getTransactions, _layer1GasFeeFlows, _timeout, _running, _start, start_fn, _stop, stop_fn, _onTimeout, onTimeout_fn, _updateTransactionGasFeeEstimates, updateTransactionGasFeeEstimates_fn, _updateTransactionSuggestedFees, updateTransactionSuggestedFees_fn, _updateTransactionLayer1GasFee, updateTransactionLayer1GasFee_fn, _getUnapprovedTransactions, getUnapprovedTransactions_fn;
+var GasFeePoller = class {
+  /**
+   * Constructs a new instance of the GasFeePoller.
+   * @param options - The options for this instance.
+   * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+   * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+   * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+   * @param options.getTransactions - Callback to obtain the transaction data.
+   * @param options.layer1GasFeeFlows - The layer 1 gas fee flows to use to obtain suitable layer 1 gas fees.
+   * @param options.onStateChange - Callback to register a listener for controller state changes.
+   */
+  constructor({
+    gasFeeFlows,
+    getEthQuery,
+    getGasFeeControllerEstimates,
+    getTransactions,
+    layer1GasFeeFlows,
+    onStateChange
+  }) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _start);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stop);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onTimeout);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionGasFeeEstimates);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionSuggestedFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionLayer1GasFee);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getUnapprovedTransactions);
+    this.hub = new (0, _events2.default)();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _gasFeeFlows, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getEthQuery, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getGasFeeControllerEstimates, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getTransactions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _layer1GasFeeFlows, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _timeout, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _running, false);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _gasFeeFlows, gasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _layer1GasFeeFlows, layer1GasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getEthQuery, getEthQuery);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getGasFeeControllerEstimates, getGasFeeControllerEstimates);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getTransactions, getTransactions);
+    onStateChange(() => {
+      const unapprovedTransactions = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getUnapprovedTransactions, getUnapprovedTransactions_fn).call(this);
+      if (unapprovedTransactions.length) {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _start, start_fn).call(this);
+      } else {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stop, stop_fn).call(this);
+      }
+    });
+  }
+};
+_gasFeeFlows = new WeakMap();
+_getEthQuery = new WeakMap();
+_getGasFeeControllerEstimates = new WeakMap();
+_getTransactions = new WeakMap();
+_layer1GasFeeFlows = new WeakMap();
+_timeout = new WeakMap();
+_running = new WeakMap();
+_start = new WeakSet();
+start_fn = function() {
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _running)) {
+    return;
+  }
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTimeout, onTimeout_fn).call(this);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _running, true);
+  log("Started polling");
+};
+_stop = new WeakSet();
+stop_fn = function() {
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _running)) {
+    return;
+  }
+  clearTimeout(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _timeout));
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _timeout, void 0);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _running, false);
+  log("Stopped polling");
+};
+_onTimeout = new WeakSet();
+onTimeout_fn = async function() {
+  await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionGasFeeEstimates, updateTransactionGasFeeEstimates_fn).call(this);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _timeout, setTimeout(() => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTimeout, onTimeout_fn).call(this), INTERVAL_MILLISECONDS));
+};
+_updateTransactionGasFeeEstimates = new WeakSet();
+updateTransactionGasFeeEstimates_fn = async function() {
+  const unapprovedTransactions = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getUnapprovedTransactions, getUnapprovedTransactions_fn).call(this);
+  log("Found unapproved transactions", {
+    count: unapprovedTransactions.length
+  });
+  await Promise.all(
+    unapprovedTransactions.flatMap((tx) => [
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionSuggestedFees, updateTransactionSuggestedFees_fn).call(this, tx),
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionLayer1GasFee, updateTransactionLayer1GasFee_fn).call(this, tx)
+    ])
+  );
+};
+_updateTransactionSuggestedFees = new WeakSet();
+updateTransactionSuggestedFees_fn = async function(transactionMeta) {
+  const { chainId, networkClientId } = transactionMeta;
+  const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getEthQuery).call(this, chainId, networkClientId);
+  const gasFeeFlow = _chunkTZTP4JVAjs.getGasFeeFlow.call(void 0, transactionMeta, _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _gasFeeFlows));
+  if (!gasFeeFlow) {
+    log("No gas fee flow found", transactionMeta.id);
+  } else {
+    log(
+      "Found gas fee flow",
+      gasFeeFlow.constructor.name,
+      transactionMeta.id
+    );
+  }
+  const request = {
+    ethQuery,
+    getGasFeeControllerEstimates: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getGasFeeControllerEstimates),
+    transactionMeta
+  };
+  let gasFeeEstimates;
+  if (gasFeeFlow) {
+    try {
+      const response = await gasFeeFlow.getGasFees(request);
+      gasFeeEstimates = response.estimates;
+    } catch (error) {
+      log("Failed to get suggested gas fees", transactionMeta.id, error);
+    }
+  }
+  if (!gasFeeEstimates && transactionMeta.gasFeeEstimatesLoaded) {
+    return;
+  }
+  const updatedTransactionMeta = {
+    ...transactionMeta,
+    gasFeeEstimates,
+    gasFeeEstimatesLoaded: true
+  };
+  this.hub.emit("transaction-updated", updatedTransactionMeta);
+  log("Updated suggested gas fees", {
+    gasFeeEstimates: updatedTransactionMeta.gasFeeEstimates,
+    transaction: updatedTransactionMeta.id
+  });
+};
+_updateTransactionLayer1GasFee = new WeakSet();
+updateTransactionLayer1GasFee_fn = async function(transactionMeta) {
+  const { chainId, networkClientId } = transactionMeta;
+  const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getEthQuery).call(this, chainId, networkClientId);
+  await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+    ethQuery,
+    layer1GasFeeFlows: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _layer1GasFeeFlows),
+    transactionMeta
+  });
+  if (transactionMeta.layer1GasFee === void 0) {
+    return;
+  }
+  this.hub.emit("transaction-updated", transactionMeta);
+};
+_getUnapprovedTransactions = new WeakSet();
+getUnapprovedTransactions_fn = function() {
+  return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getTransactions).call(this).filter(
+    (tx) => tx.status === "unapproved" /* unapproved */
+  );
+};
+
+
+
+exports.GasFeePoller = GasFeePoller;
+//# sourceMappingURL=chunk-QEX3QMSL.js.map
\ No newline at end of file
diff --git a/dist/chunk-TZTP4JVA.js b/dist/chunk-TZTP4JVA.js
new file mode 100644
index 0000000000000000000000000000000000000000..3fdf72e49f5db74f3fabf9f24fbfe9393c9ec1cc
--- /dev/null
+++ b/dist/chunk-TZTP4JVA.js
@@ -0,0 +1,62 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkVEJ3MIZGjs = require('./chunk-VEJ3MIZG.js');
+
+// src/utils/gas-flow.ts
+var _controllerutils = require('@metamask/controller-utils');
+
+
+var _gasfeecontroller = require('@metamask/gas-fee-controller');
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+  return gasFeeFlows.find(
+    (gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta)
+  );
+}
+function mergeGasFeeEstimates({
+  gasFeeControllerEstimateType,
+  gasFeeControllerEstimates,
+  transactionGasFeeEstimates
+}) {
+  if (gasFeeControllerEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+    return Object.values(_chunkVEJ3MIZGjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: mergeFeeMarketEstimate(
+          gasFeeControllerEstimates[level],
+          transactionGasFeeEstimates[level]
+        )
+      }),
+      { ...gasFeeControllerEstimates }
+    );
+  }
+  if (gasFeeControllerEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.LEGACY) {
+    return Object.values(_chunkVEJ3MIZGjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: getLegacyEstimate(transactionGasFeeEstimates[level])
+      }),
+      {}
+    );
+  }
+  return gasFeeControllerEstimates;
+}
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+  return {
+    ...gasFeeControllerEstimate,
+    suggestedMaxFeePerGas: _controllerutils.weiHexToGweiDec.call(void 0, 
+      transactionGasFeeEstimate.maxFeePerGas
+    ),
+    suggestedMaxPriorityFeePerGas: _controllerutils.weiHexToGweiDec.call(void 0, 
+      transactionGasFeeEstimate.maxPriorityFeePerGas
+    )
+  };
+}
+function getLegacyEstimate(transactionGasFeeEstimate) {
+  return _controllerutils.weiHexToGweiDec.call(void 0, transactionGasFeeEstimate.maxFeePerGas);
+}
+
+
+
+
+exports.getGasFeeFlow = getGasFeeFlow; exports.mergeGasFeeEstimates = mergeGasFeeEstimates;
+//# sourceMappingURL=chunk-TZTP4JVA.js.map
\ No newline at end of file
diff --git a/dist/chunk-VEJ3MIZG.js b/dist/chunk-VEJ3MIZG.js
new file mode 100644
index 0000000000000000000000000000000000000000..cbbbb7018c24bb9b56ae50ba89a3906974c371ef
--- /dev/null
+++ b/dist/chunk-VEJ3MIZG.js
@@ -0,0 +1,76 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/types.ts
+var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
+  TransactionStatus2["approved"] = "approved";
+  TransactionStatus2["cancelled"] = "cancelled";
+  TransactionStatus2["confirmed"] = "confirmed";
+  TransactionStatus2["dropped"] = "dropped";
+  TransactionStatus2["failed"] = "failed";
+  TransactionStatus2["rejected"] = "rejected";
+  TransactionStatus2["signed"] = "signed";
+  TransactionStatus2["submitted"] = "submitted";
+  TransactionStatus2["unapproved"] = "unapproved";
+  return TransactionStatus2;
+})(TransactionStatus || {});
+var WalletDevice = /* @__PURE__ */ ((WalletDevice2) => {
+  WalletDevice2["MM_MOBILE"] = "metamask_mobile";
+  WalletDevice2["MM_EXTENSION"] = "metamask_extension";
+  WalletDevice2["OTHER"] = "other_device";
+  return WalletDevice2;
+})(WalletDevice || {});
+var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
+  TransactionType2["cancel"] = "cancel";
+  TransactionType2["contractInteraction"] = "contractInteraction";
+  TransactionType2["deployContract"] = "contractDeployment";
+  TransactionType2["ethDecrypt"] = "eth_decrypt";
+  TransactionType2["ethGetEncryptionPublicKey"] = "eth_getEncryptionPublicKey";
+  TransactionType2["incoming"] = "incoming";
+  TransactionType2["personalSign"] = "personal_sign";
+  TransactionType2["retry"] = "retry";
+  TransactionType2["simpleSend"] = "simpleSend";
+  TransactionType2["sign"] = "eth_sign";
+  TransactionType2["signTypedData"] = "eth_signTypedData";
+  TransactionType2["smart"] = "smart";
+  TransactionType2["swap"] = "swap";
+  TransactionType2["swapApproval"] = "swapApproval";
+  TransactionType2["tokenMethodApprove"] = "approve";
+  TransactionType2["tokenMethodSafeTransferFrom"] = "safetransferfrom";
+  TransactionType2["tokenMethodTransfer"] = "transfer";
+  TransactionType2["tokenMethodTransferFrom"] = "transferfrom";
+  TransactionType2["tokenMethodSetApprovalForAll"] = "setapprovalforall";
+  return TransactionType2;
+})(TransactionType || {});
+var TransactionEnvelopeType = /* @__PURE__ */ ((TransactionEnvelopeType2) => {
+  TransactionEnvelopeType2["legacy"] = "0x0";
+  TransactionEnvelopeType2["accessList"] = "0x1";
+  TransactionEnvelopeType2["feeMarket"] = "0x2";
+  return TransactionEnvelopeType2;
+})(TransactionEnvelopeType || {});
+var UserFeeLevel = /* @__PURE__ */ ((UserFeeLevel2) => {
+  UserFeeLevel2["CUSTOM"] = "custom";
+  UserFeeLevel2["DAPP_SUGGESTED"] = "dappSuggested";
+  UserFeeLevel2["MEDIUM"] = "medium";
+  return UserFeeLevel2;
+})(UserFeeLevel || {});
+var GasFeeEstimateLevel = /* @__PURE__ */ ((GasFeeEstimateLevel2) => {
+  GasFeeEstimateLevel2["low"] = "low";
+  GasFeeEstimateLevel2["medium"] = "medium";
+  GasFeeEstimateLevel2["high"] = "high";
+  return GasFeeEstimateLevel2;
+})(GasFeeEstimateLevel || {});
+var SimulationTokenStandard = /* @__PURE__ */ ((SimulationTokenStandard2) => {
+  SimulationTokenStandard2["erc20"] = "erc20";
+  SimulationTokenStandard2["erc721"] = "erc721";
+  SimulationTokenStandard2["erc1155"] = "erc1155";
+  return SimulationTokenStandard2;
+})(SimulationTokenStandard || {});
+
+
+
+
+
+
+
+
+
+exports.TransactionStatus = TransactionStatus; exports.WalletDevice = WalletDevice; exports.TransactionType = TransactionType; exports.TransactionEnvelopeType = TransactionEnvelopeType; exports.UserFeeLevel = UserFeeLevel; exports.GasFeeEstimateLevel = GasFeeEstimateLevel; exports.SimulationTokenStandard = SimulationTokenStandard;
+//# sourceMappingURL=chunk-VEJ3MIZG.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
index 3612294fc10df5b3f522b7aba4c2c38a35a4edea..5df79a781177e44255a67b5ba3c6f7427ca14c72 100644
--- a/dist/gas-flows/DefaultGasFeeFlow.js
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -1,15 +1,15 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkTXVH44HMjs = require('../chunk-TXVH44HM.js');
-require('../chunk-QPNEFZB3.js');
+var _chunkPF3UOCRWjs = require('../chunk-PF3UOCRW.js');
+require('../chunk-5IHLDAOF.js');
 require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-O7H2MC7R.js');
+require('../chunk-TZTP4JVA.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.DefaultGasFeeFlow = _chunkTXVH44HMjs.DefaultGasFeeFlow;
+exports.DefaultGasFeeFlow = _chunkPF3UOCRWjs.DefaultGasFeeFlow;
 //# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
index 7ed21145148f95813f7a4189374e88cebd467078..06c67aa2fc05daedbfcde80db54494bedb8f86a0 100644
--- a/dist/gas-flows/LineaGasFeeFlow.js
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -1,16 +1,16 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkCQBXHAYRjs = require('../chunk-CQBXHAYR.js');
-require('../chunk-TXVH44HM.js');
-require('../chunk-QPNEFZB3.js');
+var _chunkFHG5GY6Fjs = require('../chunk-FHG5GY6F.js');
+require('../chunk-PF3UOCRW.js');
+require('../chunk-5IHLDAOF.js');
 require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-O7H2MC7R.js');
+require('../chunk-TZTP4JVA.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.LineaGasFeeFlow = _chunkCQBXHAYRjs.LineaGasFeeFlow;
+exports.LineaGasFeeFlow = _chunkFHG5GY6Fjs.LineaGasFeeFlow;
 //# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/EtherscanRemoteTransactionSource.js b/dist/helpers/EtherscanRemoteTransactionSource.js
index 079e726a934c10b04eb5e6cc751fdec8b604f21b..99317792556323428a5409e9aecf1a9f13ca3b37 100644
--- a/dist/helpers/EtherscanRemoteTransactionSource.js
+++ b/dist/helpers/EtherscanRemoteTransactionSource.js
@@ -4,7 +4,7 @@ var _chunkF3CMU2DMjs = require('../chunk-F3CMU2DM.js');
 require('../chunk-CXXGL43K.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/helpers/GasFeePoller.js b/dist/helpers/GasFeePoller.js
index d693329df526bbde638f7913b3d93b851dd536f2..9f5a47c2d9ea640b7472dd6f537c776f2a8a4b3b 100644
--- a/dist/helpers/GasFeePoller.js
+++ b/dist/helpers/GasFeePoller.js
@@ -1,12 +1,12 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkBILEZLATjs = require('../chunk-BILEZLAT.js');
+var _chunkQEX3QMSLjs = require('../chunk-QEX3QMSL.js');
 require('../chunk-R7NJVDWN.js');
-require('../chunk-O7H2MC7R.js');
+require('../chunk-TZTP4JVA.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.GasFeePoller = _chunkBILEZLATjs.GasFeePoller;
+exports.GasFeePoller = _chunkQEX3QMSLjs.GasFeePoller;
 //# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/dist/helpers/MultichainTrackingHelper.js b/dist/helpers/MultichainTrackingHelper.js
index 59b25659bc2b95d591e216a3e2ccc98a84485d91..cbbb4f8ce0e4ba3a5b07dd69f5662bbae0884e78 100644
--- a/dist/helpers/MultichainTrackingHelper.js
+++ b/dist/helpers/MultichainTrackingHelper.js
@@ -5,7 +5,7 @@ require('../chunk-F3CMU2DM.js');
 require('../chunk-CXXGL43K.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/helpers/PendingTransactionTracker.js b/dist/helpers/PendingTransactionTracker.js
index 8db5cde60a2fb1c4a96b3e805a275d911428d10a..f840b51300552d19bd2499d9f51c565aa589546e 100644
--- a/dist/helpers/PendingTransactionTracker.js
+++ b/dist/helpers/PendingTransactionTracker.js
@@ -2,7 +2,7 @@
 
 var _chunk5XBULBP2js = require('../chunk-5XBULBP2.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/index.js b/dist/index.js
index 40ead10dfa45e4c1840fdec2ae4e6ffb4dbf453e..73d119bc6b0c8dd28d9c827717ff616bd60ca888 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -2,25 +2,25 @@
 
 
 
-var _chunkQDIYZX5Vjs = require('./chunk-QDIYZX5V.js');
+var _chunkAFM3ZOKZjs = require('./chunk-AFM3ZOKZ.js');
 require('./chunk-VH47Q6TS.js');
 require('./chunk-RQKICZYP.js');
 require('./chunk-QP75SWIQ.js');
 require('./chunk-ZNZEJDOE.js');
-require('./chunk-WXQZIUNW.js');
-require('./chunk-4S25HUCL.js');
+require('./chunk-EAUE4RCU.js');
+require('./chunk-BOZ2GRIU.js');
 
 
 var _chunkHS277C77js = require('./chunk-HS277C77.js');
-require('./chunk-BILEZLAT.js');
+require('./chunk-QEX3QMSL.js');
 require('./chunk-R7NJVDWN.js');
 require('./chunk-DTDTOMTB.js');
 require('./chunk-NRWEI43Q.js');
 require('./chunk-5XBULBP2.js');
 require('./chunk-7LXE4KHV.js');
-require('./chunk-CQBXHAYR.js');
-require('./chunk-TXVH44HM.js');
-require('./chunk-QPNEFZB3.js');
+require('./chunk-FHG5GY6F.js');
+require('./chunk-PF3UOCRW.js');
+require('./chunk-5IHLDAOF.js');
 require('./chunk-5OQ373JS.js');
 
 
@@ -28,7 +28,7 @@ require('./chunk-5OQ373JS.js');
 var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
 
 
-var _chunkO7H2MC7Rjs = require('./chunk-O7H2MC7R.js');
+var _chunkTZTP4JVAjs = require('./chunk-TZTP4JVA.js');
 require('./chunk-F3CMU2DM.js');
 require('./chunk-CXXGL43K.js');
 require('./chunk-ITDY6AIZ.js');
@@ -39,7 +39,8 @@ require('./chunk-S6VGOPUY.js');
 
 
 
-var _chunkW3GAOR7Yjs = require('./chunk-W3GAOR7Y.js');
+
+var _chunkVEJ3MIZGjs = require('./chunk-VEJ3MIZG.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -54,5 +55,6 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.CANCEL_RATE = _chunkQDIYZX5Vjs.CANCEL_RATE; exports.HARDFORK = _chunkQDIYZX5Vjs.HARDFORK; exports.TransactionController = _chunkQDIYZX5Vjs.TransactionController; exports.TransactionEnvelopeType = _chunkW3GAOR7Yjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkW3GAOR7Yjs.TransactionStatus; exports.TransactionType = _chunkW3GAOR7Yjs.TransactionType; exports.UserFeeLevel = _chunkW3GAOR7Yjs.UserFeeLevel; exports.WalletDevice = _chunkW3GAOR7Yjs.WalletDevice; exports.determineTransactionType = _chunkHS277C77js.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkO7H2MC7Rjs.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
+
+exports.CANCEL_RATE = _chunkAFM3ZOKZjs.CANCEL_RATE; exports.HARDFORK = _chunkAFM3ZOKZjs.HARDFORK; exports.SimulationTokenStandard = _chunkVEJ3MIZGjs.SimulationTokenStandard; exports.TransactionController = _chunkAFM3ZOKZjs.TransactionController; exports.TransactionEnvelopeType = _chunkVEJ3MIZGjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkVEJ3MIZGjs.TransactionStatus; exports.TransactionType = _chunkVEJ3MIZGjs.TransactionType; exports.UserFeeLevel = _chunkVEJ3MIZGjs.UserFeeLevel; exports.WalletDevice = _chunkVEJ3MIZGjs.WalletDevice; exports.determineTransactionType = _chunkHS277C77js.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkTZTP4JVAjs.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types/TransactionController.d.ts b/dist/types/TransactionController.d.ts
index 9e6fa51ca24e08ca851f89c7a780f10f7d15473b..09b1ebe22f6f269223e8531d80d5fbcde8815b84 100644
--- a/dist/types/TransactionController.d.ts
+++ b/dist/types/TransactionController.d.ts
@@ -8,7 +8,7 @@ import type { BlockTracker, NetworkClientId, NetworkController, NetworkControlle
 import type { Hex } from '@metamask/utils';
 import type { NonceLock, Transaction as NonceTrackerTransaction } from 'nonce-tracker';
 import type { IncomingTransactionOptions } from './helpers/IncomingTransactionHelper';
-import type { SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse } from './types';
+import type { SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse, SimulationData } from './types';
 import { TransactionType, TransactionStatus } from './types';
 export declare const HARDFORK = Hardfork.London;
 /**
@@ -803,6 +803,7 @@ export declare class TransactionController extends BaseController<typeof control
      * @returns Whether or not the error is a nonce issue
      */
     private isTransactionAlreadyConfirmedError;
+    updateSimulationData(transactionId: string, simulationData: SimulationData): Promise<void>;
 }
 export {};
 //# sourceMappingURL=TransactionController.d.ts.map
\ No newline at end of file
diff --git a/dist/types/index.d.ts b/dist/types/index.d.ts
index ac3c3f9130202f10f57ed9a1510396b119be2446..dc15f5bc02197848f07db3c3f0a16bd70693336f 100644
--- a/dist/types/index.d.ts
+++ b/dist/types/index.d.ts
@@ -1,7 +1,7 @@
 export type { FeeMarketEIP1559Values, GasPriceValue, MethodData, Result, TransactionControllerActions, TransactionControllerEvents, TransactionControllerGetStateAction, TransactionControllerIncomingTransactionBlockReceivedEvent, TransactionControllerPostTransactionBalanceUpdatedEvent, TransactionControllerSpeedupTransactionAddedEvent, TransactionControllerState, TransactionControllerStateChangeEvent, TransactionControllerTransactionApprovedEvent, TransactionControllerTransactionConfirmedEvent, TransactionControllerTransactionDroppedEvent, TransactionControllerTransactionFailedEvent, TransactionControllerTransactionFinishedEvent, TransactionControllerTransactionNewSwapApprovalEvent, TransactionControllerTransactionNewSwapEvent, TransactionControllerTransactionPublishingSkipped, TransactionControllerTransactionRejectedEvent, TransactionControllerTransactionStatusUpdatedEvent, TransactionControllerTransactionSubmittedEvent, TransactionControllerUnapprovedTransactionAddedEvent, TransactionControllerMessenger, } from './TransactionController';
 export { HARDFORK, CANCEL_RATE, TransactionController, } from './TransactionController';
-export type { DappSuggestedGasFees, DefaultGasEstimates, InferTransactionTypeResult, Log, RemoteTransactionSource, RemoteTransactionSourceRequest, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, } from './types';
-export { TransactionEnvelopeType, TransactionStatus, TransactionType, UserFeeLevel, WalletDevice, } from './types';
+export type { DappSuggestedGasFees, DefaultGasEstimates, InferTransactionTypeResult, Log, RemoteTransactionSource, RemoteTransactionSourceRequest, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, SimulationBalanceChange, SimulationData, SimulationError, SimulationToken, SimulationTokenBalanceChange, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, } from './types';
+export { SimulationTokenStandard, TransactionEnvelopeType, TransactionStatus, TransactionType, UserFeeLevel, WalletDevice, } from './types';
 export type { EtherscanTransactionMeta } from './utils/etherscan';
 export { determineTransactionType } from './utils/transaction-type';
 export { mergeGasFeeEstimates } from './utils/gas-flow';
diff --git a/dist/types/types.d.ts b/dist/types/types.d.ts
index abbb9ed126c5740cec1b959c71f1c126c5e9bd1e..88ee5ee83a530d6ada91aeee4c1110cb94352d19 100644
--- a/dist/types/types.d.ts
+++ b/dist/types/types.d.ts
@@ -883,8 +883,19 @@ export declare type SimulationToken = {
 };
 /** Simulation data concerning a change to the a token balance. */
 export declare type SimulationTokenBalanceChange = SimulationToken & SimulationBalanceChange;
+/** Error data for a failed simulation. */
+export declare type SimulationError = {
+    /** Error code to identify the error type. */
+    code?: number;
+    /** Error message to describe the error. */
+    message?: string;
+    /** Whether the error is due to the transaction being reverted. */
+    isReverted: boolean;
+};
 /** Simulation data for a transaction. */
 export declare type SimulationData = {
+    /** Error data if the simulation failed or the transaction reverted. */
+    error?: SimulationError;
     /** Data concerning a change to the user's native balance. */
     nativeBalanceChange?: SimulationBalanceChange;
     /** Data concerning a change to the user's token balances. */
diff --git a/dist/types/utils/simulation-api.d.ts b/dist/types/utils/simulation-api.d.ts
index 38b464f05c8a1a00b27736e7b560a19233f58052..36cba9f5ea6d0c0c5efe028e0278a8c07175a2f2 100644
--- a/dist/types/utils/simulation-api.d.ts
+++ b/dist/types/utils/simulation-api.d.ts
@@ -73,16 +73,18 @@ export declare type SimulationResponseStateDiff = {
 };
 /** Response from the simulation API for a single transaction. */
 export declare type SimulationResponseTransaction = {
+    /** An error message indicating the transaction could not be simulated. */
+    error?: string;
     /** Return value of the transaction, such as the balance if calling balanceOf. */
     return: Hex;
     /** Hierarchy of call data including nested calls and logs. */
-    callTrace: SimulationResponseCallTrace;
+    callTrace?: SimulationResponseCallTrace;
     /** Changes to the blockchain state. */
-    stateDiff: {
+    stateDiff?: {
         /** Initial blockchain state before the transaction. */
-        pre: SimulationResponseStateDiff;
+        pre?: SimulationResponseStateDiff;
         /** Updated blockchain state after the transaction. */
-        post: SimulationResponseStateDiff;
+        post?: SimulationResponseStateDiff;
     };
 };
 /** Response from the simulation API. */
diff --git a/dist/types/utils/simulation.d.ts b/dist/types/utils/simulation.d.ts
index 62f760ef2cfb9d88ced279e82527a04ef1c487ce..e2a95017835deecfe0bdeda893db541e3d715878 100644
--- a/dist/types/utils/simulation.d.ts
+++ b/dist/types/utils/simulation.d.ts
@@ -17,5 +17,5 @@ export declare type GetSimulationDataRequest = {
  * @param request.data - The data of the transaction.
  * @returns The simulation data.
  */
-export declare function getSimulationData(request: GetSimulationDataRequest): Promise<SimulationData | undefined>;
+export declare function getSimulationData(request: GetSimulationDataRequest): Promise<SimulationData>;
 //# sourceMappingURL=simulation.d.ts.map
\ No newline at end of file
diff --git a/dist/types.js b/dist/types.js
index 200084d2e8f3f9d3957be70cee9714435bbdf052..4681145a4c8401b0416cd6d7bd26b5c148f9ae9c 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -6,7 +6,7 @@
 
 
 
-var _chunkW3GAOR7Yjs = require('./chunk-W3GAOR7Y.js');
+var _chunkVEJ3MIZGjs = require('./chunk-VEJ3MIZG.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -16,5 +16,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.GasFeeEstimateLevel = _chunkW3GAOR7Yjs.GasFeeEstimateLevel; exports.SimulationTokenStandard = _chunkW3GAOR7Yjs.SimulationTokenStandard; exports.TransactionEnvelopeType = _chunkW3GAOR7Yjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkW3GAOR7Yjs.TransactionStatus; exports.TransactionType = _chunkW3GAOR7Yjs.TransactionType; exports.UserFeeLevel = _chunkW3GAOR7Yjs.UserFeeLevel; exports.WalletDevice = _chunkW3GAOR7Yjs.WalletDevice;
+exports.GasFeeEstimateLevel = _chunkVEJ3MIZGjs.GasFeeEstimateLevel; exports.SimulationTokenStandard = _chunkVEJ3MIZGjs.SimulationTokenStandard; exports.TransactionEnvelopeType = _chunkVEJ3MIZGjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkVEJ3MIZGjs.TransactionStatus; exports.TransactionType = _chunkVEJ3MIZGjs.TransactionType; exports.UserFeeLevel = _chunkVEJ3MIZGjs.UserFeeLevel; exports.WalletDevice = _chunkVEJ3MIZGjs.WalletDevice;
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/external-transactions.js b/dist/utils/external-transactions.js
index 7491a8cb7222a5a342b55b328d8f7ec42b706f05..524f59603cb60faf4451064bff0878100f617a71 100644
--- a/dist/utils/external-transactions.js
+++ b/dist/utils/external-transactions.js
@@ -1,7 +1,7 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 var _chunk7LXE4KHVjs = require('../chunk-7LXE4KHV.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index 27a126065d6edd4ef0cf5a64ca05b8f1b3f2c349..0d3bf72112715845fc61c7c6cdf1ef7342a07d92 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -1,16 +1,16 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunkQPNEFZB3js = require('../chunk-QPNEFZB3.js');
+var _chunk5IHLDAOFjs = require('../chunk-5IHLDAOF.js');
 require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-O7H2MC7R.js');
+require('../chunk-TZTP4JVA.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.gweiDecimalToWeiHex = _chunkQPNEFZB3js.gweiDecimalToWeiHex; exports.updateGasFees = _chunkQPNEFZB3js.updateGasFees;
+exports.gweiDecimalToWeiHex = _chunk5IHLDAOFjs.gweiDecimalToWeiHex; exports.updateGasFees = _chunk5IHLDAOFjs.updateGasFees;
 //# sourceMappingURL=gas-fees.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.js b/dist/utils/gas-flow.js
index 6cab898f0ccb9ea9932467c031ef8cd982b65120..c05f8bd04bc5b6bf708f757b558e4b8da19aec7e 100644
--- a/dist/utils/gas-flow.js
+++ b/dist/utils/gas-flow.js
@@ -1,11 +1,11 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunkO7H2MC7Rjs = require('../chunk-O7H2MC7R.js');
-require('../chunk-W3GAOR7Y.js');
+var _chunkTZTP4JVAjs = require('../chunk-TZTP4JVA.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.getGasFeeFlow = _chunkO7H2MC7Rjs.getGasFeeFlow; exports.mergeGasFeeEstimates = _chunkO7H2MC7Rjs.mergeGasFeeEstimates;
+exports.getGasFeeFlow = _chunkTZTP4JVAjs.getGasFeeFlow; exports.mergeGasFeeEstimates = _chunkTZTP4JVAjs.mergeGasFeeEstimates;
 //# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.js b/dist/utils/simulation-api.js
index 7c8da7b027b93cdf5c7ac65b8671a7eb155827df..8a9144c27741e7ac4d0708d75b9427a38ea9a69f 100644
--- a/dist/utils/simulation-api.js
+++ b/dist/utils/simulation-api.js
@@ -1,10 +1,10 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunk4S25HUCLjs = require('../chunk-4S25HUCL.js');
+var _chunkBOZ2GRIUjs = require('../chunk-BOZ2GRIU.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.simulateTransactions = _chunk4S25HUCLjs.simulateTransactions;
+exports.simulateTransactions = _chunkBOZ2GRIUjs.simulateTransactions;
 //# sourceMappingURL=simulation-api.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
index e072847885c25d9ef7300b2c234c0c17eccbe53d..6d288d8a18b1595da5a729fccd5a03d146595e4a 100644
--- a/dist/utils/simulation.js
+++ b/dist/utils/simulation.js
@@ -1,12 +1,12 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkWXQZIUNWjs = require('../chunk-WXQZIUNW.js');
-require('../chunk-4S25HUCL.js');
+var _chunkEAUE4RCUjs = require('../chunk-EAUE4RCU.js');
+require('../chunk-BOZ2GRIU.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.getSimulationData = _chunkWXQZIUNWjs.getSimulationData;
+exports.getSimulationData = _chunkEAUE4RCUjs.getSimulationData;
 //# sourceMappingURL=simulation.js.map
\ No newline at end of file
diff --git a/dist/utils/swaps.js b/dist/utils/swaps.js
index 61d099dc60077cc237c968d94428a99abc73bb97..6e39ece23481e1f71555a0bc2d4255a2acfd9eb3 100644
--- a/dist/utils/swaps.js
+++ b/dist/utils/swaps.js
@@ -10,7 +10,7 @@ var _chunk5OQ373JSjs = require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/transaction-type.js b/dist/utils/transaction-type.js
index 7e99ee6a5067a745e91466c084eb1164dbd22764..57b2b92ce30d01786028328fcce2590308b8b96a 100644
--- a/dist/utils/transaction-type.js
+++ b/dist/utils/transaction-type.js
@@ -2,7 +2,7 @@
 
 
 var _chunkHS277C77js = require('../chunk-HS277C77.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/utils.js b/dist/utils/utils.js
index 7fd8437ca1d0681ac4c2011df41220b01a2d33fe..1da62658e169a9cccb006fe49d408d152b485656 100644
--- a/dist/utils/utils.js
+++ b/dist/utils/utils.js
@@ -13,7 +13,7 @@
 
 
 var _chunkUGFBA4GVjs = require('../chunk-UGFBA4GV.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/validation.js b/dist/utils/validation.js
index 4146ba1387d9ffb8955befd3fef044c742b6561e..fd4d1520cac009cc6dbeb558433b9a638b8480a4 100644
--- a/dist/utils/validation.js
+++ b/dist/utils/validation.js
@@ -3,7 +3,7 @@
 
 var _chunkVH47Q6TSjs = require('../chunk-VH47Q6TS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-W3GAOR7Y.js');
+require('../chunk-VEJ3MIZG.js');
 require('../chunk-Z4BLTVTB.js');
 
 
