diff --git a/dist/TransactionController.d.ts b/dist/TransactionController.d.ts
index 470ed9065fa18ab5ce5b0c5fb3d3101faa6263d1..c9400c196854c82d20c33d2b802027ac833698fc 100644
--- a/dist/TransactionController.d.ts
+++ b/dist/TransactionController.d.ts
@@ -103,6 +103,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly registry;
     private readonly provider;
     private readonly mutex;
+    private readonly gasFeeFlows;
     private readonly getSavedGasFees;
     private readonly getNetworkState;
     private readonly getCurrentAccountEIP1559Compatibility;
@@ -117,6 +118,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly pendingTransactionTracker;
     private readonly cancelMultiplier;
     private readonly speedUpMultiplier;
+    private readonly signAbortCallbacks;
     private readonly afterSign;
     private readonly beforeApproveOnInit;
     private readonly beforeCheckPendingTransaction;
@@ -478,6 +480,12 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * Removes unapproved transactions from state.
      */
     clearUnapprovedTransactions(): void;
+    /**
+     * Stop the signing process for a specific transaction.
+     * Throws an error causing the transaction status to be set to failed.
+     * @param transactionId - The ID of the transaction to stop signing.
+     */
+    abortTransactionSigning(transactionId: string): void;
     private addMetadata;
     private updateGasProperties;
     private getCurrentChainTransactionsByStatus;
@@ -596,6 +604,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private getNonceTrackerTransactions;
     private onConfirmedTransaction;
     private updatePostBalance;
+    private getGasFeeFlows;
 }
 export {};
 //# sourceMappingURL=TransactionController.d.ts.map
\ No newline at end of file
diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 890cd7037609021a855937360b58f724c08cf274..079fe6a445c69aff6e7d0deb4688a71fb12faff3 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -26,7 +26,11 @@ const events_1 = require("events");
 const lodash_1 = require("lodash");
 const nonce_tracker_1 = require("nonce-tracker");
 const uuid_1 = require("uuid");
+const DefaultGasFeeFlow_1 = require("./gas-flows/DefaultGasFeeFlow");
+const LineaGasFeeFlow_1 = require("./gas-flows/LineaGasFeeFlow");
+const TestGasFeeFlow_1 = require("./gas-flows/TestGasFeeFlow");
 const EtherscanRemoteTransactionSource_1 = require("./helpers/EtherscanRemoteTransactionSource");
+const GasFeePoller_1 = require("./helpers/GasFeePoller");
 const IncomingTransactionHelper_1 = require("./helpers/IncomingTransactionHelper");
 const PendingTransactionTracker_1 = require("./helpers/PendingTransactionTracker");
 const logger_1 = require("./logger");
@@ -100,6 +104,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         super(config, state);
         this.inProcessOfSigning = new Set();
         this.mutex = new async_mutex_1.Mutex();
+        this.signAbortCallbacks = new Map();
         /**
          * EventEmitter instance used to listen to specific transactional events
          */
@@ -191,6 +196,19 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             },
         });
         this.addPendingTransactionTrackerListeners();
+        this.gasFeeFlows = this.getGasFeeFlows();
+        const gasFeePoller = new GasFeePoller_1.GasFeePoller({
+            // Default gas fee polling is not yet supported by the clients
+            gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+            getChainIds: () => [this.getChainId()],
+            getEthQuery: () => this.ethQuery,
+            getGasFeeControllerEstimates: this.getGasFeeEstimates,
+            getTransactions: () => this.state.transactions,
+            onStateChange: (listener) => {
+                this.subscribe(listener);
+            },
+        });
+        gasFeePoller.hub.on('transaction-updated', this.updateTransaction.bind(this));
         onNetworkStateChange(() => {
             (0, logger_1.projectLogger)('Detected network change', this.getChainId());
             this.onBootCleanup();
@@ -1034,6 +1052,23 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         const transactions = this.state.transactions.filter(({ status }) => status !== types_1.TransactionStatus.unapproved);
         this.update({ transactions: this.trimTransactionsForState(transactions) });
     }
+    /**
+     * Stop the signing process for a specific transaction.
+     * Throws an error causing the transaction status to be set to failed.
+     * @param transactionId - The ID of the transaction to stop signing.
+     */
+    abortTransactionSigning(transactionId) {
+        const transactionMeta = this.getTransaction(transactionId);
+        if (!transactionMeta) {
+            throw new Error(`Cannot abort signing as no transaction metadata found`);
+        }
+        const abortCallback = this.signAbortCallbacks.get(transactionId);
+        if (!abortCallback) {
+            throw new Error(`Cannot abort signing as transaction is not waiting for signing`);
+        }
+        abortCallback();
+        this.signAbortCallbacks.delete(transactionId);
+    }
     addMetadata(transactionMeta) {
         const { transactions } = this.state;
         transactions.push(transactionMeta);
@@ -1052,8 +1087,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             yield (0, gas_fees_1.updateGasFees)({
                 eip1559: isEIP1559Compatible,
                 ethQuery: this.ethQuery,
+                gasFeeFlows: this.gasFeeFlows,
+                getGasFeeEstimates: this.getGasFeeEstimates,
                 getSavedGasFees: this.getSavedGasFees.bind(this, chainId),
-                getGasFeeEstimates: this.getGasFeeEstimates.bind(this),
                 txMeta: transactionMeta,
             });
         });
@@ -1547,12 +1583,16 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         this.pendingTransactionTracker.hub.on('transaction-updated', this.updateTransaction.bind(this));
     }
     signTransaction(transactionMeta, txParams) {
-        var _a;
         return __awaiter(this, void 0, void 0, function* () {
             (0, logger_1.projectLogger)('Signing transaction', txParams);
             const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
             this.inProcessOfSigning.add(transactionMeta.id);
-            const signedTx = yield ((_a = this.sign) === null || _a === void 0 ? void 0 : _a.call(this, unsignedEthTx, txParams.from, ...this.getAdditionalSignArguments(transactionMeta)));
+            const signedTx = yield new Promise((resolve, reject) => {
+                var _a;
+                (_a = this.sign) === null || _a === void 0 ? void 0 : _a.call(this, unsignedEthTx, txParams.from, ...this.getAdditionalSignArguments(transactionMeta)).then(resolve, reject);
+                this.signAbortCallbacks.set(transactionMeta.id, () => reject(new Error('Signing aborted by user')));
+            });
+            this.signAbortCallbacks.delete(transactionMeta.id);
             if (!signedTx) {
                 (0, logger_1.projectLogger)('Skipping signed status as no signed transaction');
                 return undefined;
@@ -1616,6 +1656,13 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             }
         });
     }
+    getGasFeeFlows() {
+        return [
+            new LineaGasFeeFlow_1.LineaGasFeeFlow(),
+            new TestGasFeeFlow_1.TestGasFeeFlow(),
+            new DefaultGasFeeFlow_1.DefaultGasFeeFlow(),
+        ];
+    }
 }
 exports.TransactionController = TransactionController;
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/gas/AbstractGasFlow.d.ts b/dist/gas/AbstractGasFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fa097a86860782ba2db396bce78d55437a941b4c
--- /dev/null
+++ b/dist/gas/AbstractGasFlow.d.ts
@@ -0,0 +1,19 @@
+import type EthQuery from '@metamask/eth-query';
+import type { ProviderConfig } from '@metamask/network-controller';
+import type { TransactionMeta } from '../types';
+export declare type GasFlowRequest = {
+    eip1559: boolean;
+    ethQuery: EthQuery;
+    providerConfig: ProviderConfig;
+    txMeta: TransactionMeta;
+};
+export declare type GasFlowResponse = {
+    gas: string;
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    gasPrice?: string;
+};
+export declare abstract class AbstractGasFlow {
+    abstract getSuggestedGas(request: GasFlowRequest): Promise<GasFlowResponse>;
+}
+//# sourceMappingURL=AbstractGasFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas/AbstractGasFlow.js b/dist/gas/AbstractGasFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..3f99c476c84ea41446f50f6c07ec53e5135a862a
--- /dev/null
+++ b/dist/gas/AbstractGasFlow.js
@@ -0,0 +1,7 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.AbstractGasFlow = void 0;
+class AbstractGasFlow {
+}
+exports.AbstractGasFlow = AbstractGasFlow;
+//# sourceMappingURL=AbstractGasFlow.js.map
\ No newline at end of file
diff --git a/dist/gas/flows/DefaultGasFlow.d.ts b/dist/gas/flows/DefaultGasFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0fc8fe0d52a88f348702761034ef0c3832ef84f0
--- /dev/null
+++ b/dist/gas/flows/DefaultGasFlow.d.ts
@@ -0,0 +1,15 @@
+/// <reference types="debug" />
+import { type GasFeeState } from '@metamask/gas-fee-controller';
+import type { GasFlowRequest, GasFlowResponse } from '../AbstractGasFlow';
+import { AbstractGasFlow } from '../AbstractGasFlow';
+export declare const log: import("debug").Debugger;
+export declare const FIXED_GAS = "0x5208";
+export declare const DEFAULT_GAS_MULTIPLIER = 1.5;
+export declare class DefaultGasFlow extends AbstractGasFlow {
+    #private;
+    constructor({ getGasFeeControllerEstimates, }: {
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+    });
+    getSuggestedGas(request: GasFlowRequest): Promise<GasFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas/flows/DefaultGasFlow.js b/dist/gas/flows/DefaultGasFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..77ac8c54ca1b0cb988c080e83d0b5725264d5adf
--- /dev/null
+++ b/dist/gas/flows/DefaultGasFlow.js
@@ -0,0 +1,176 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFlow_instances, _DefaultGasFlow_getGasFeeControllerEstimates, _DefaultGasFlow_getGas, _DefaultGasFlow_getGasFees, _DefaultGasFlow_estimateGas, _DefaultGasFlow_addGasBuffer, _DefaultGasFlow_requiresFixedGas, _DefaultGasFlow_getCode, _DefaultGasFlow_getLatestBlock, _DefaultGasFlow_gweiDecimalToWeiHex;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFlow = exports.DEFAULT_GAS_MULTIPLIER = exports.FIXED_GAS = exports.log = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const ethereumjs_util_1 = require("ethereumjs-util");
+const constants_1 = require("../../constants");
+const logger_1 = require("../../logger");
+const AbstractGasFlow_1 = require("../AbstractGasFlow");
+exports.log = (0, logger_1.createModuleLogger)(logger_1.projectLogger, 'gas-flow-default');
+exports.FIXED_GAS = '0x5208';
+exports.DEFAULT_GAS_MULTIPLIER = 1.5;
+class DefaultGasFlow extends AbstractGasFlow_1.AbstractGasFlow {
+    constructor({ getGasFeeControllerEstimates, }) {
+        super();
+        _DefaultGasFlow_instances.add(this);
+        _DefaultGasFlow_getGasFeeControllerEstimates.set(this, void 0);
+        __classPrivateFieldSet(this, _DefaultGasFlow_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+    }
+    getSuggestedGas(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const gas = yield __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_getGas).call(this, request);
+            const suggestedGasFees = yield __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_getGasFees).call(this, request);
+            return Object.assign({ gas }, suggestedGasFees);
+        });
+    }
+}
+exports.DefaultGasFlow = DefaultGasFlow;
+_DefaultGasFlow_getGasFeeControllerEstimates = new WeakMap(), _DefaultGasFlow_instances = new WeakSet(), _DefaultGasFlow_getGas = function _DefaultGasFlow_getGas(request) {
+    var _a;
+    return __awaiter(this, void 0, void 0, function* () {
+        const { txMeta, providerConfig } = request;
+        if (yield __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_requiresFixedGas).call(this, request)) {
+            (0, exports.log)('Using fixed value', exports.FIXED_GAS);
+            return exports.FIXED_GAS;
+        }
+        const { blockGasLimit, estimatedGas } = yield __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_estimateGas).call(this, txMeta.txParams, request.ethQuery);
+        if (providerConfig.type === controller_utils_1.NetworkType.rpc) {
+            (0, exports.log)('Using original estimate as custom network');
+            return estimatedGas;
+        }
+        const bufferMultiplier = (_a = constants_1.GAS_BUFFER_CHAIN_OVERRIDES[providerConfig.chainId]) !== null && _a !== void 0 ? _a : exports.DEFAULT_GAS_MULTIPLIER;
+        const bufferedGas = __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_addGasBuffer).call(this, estimatedGas, blockGasLimit, bufferMultiplier);
+        return bufferedGas;
+    });
+}, _DefaultGasFlow_getGasFees = function _DefaultGasFlow_getGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { eip1559, ethQuery } = request;
+        try {
+            const { gasFeeEstimates, gasEstimateType } = yield __classPrivateFieldGet(this, _DefaultGasFlow_getGasFeeControllerEstimates, "f").call(this);
+            if (eip1559 && gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {}, } = gasFeeEstimates;
+                if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
+                    return {
+                        maxFeePerGas: __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_gweiDecimalToWeiHex).call(this, suggestedMaxFeePerGas),
+                        maxPriorityFeePerGas: __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_gweiDecimalToWeiHex).call(this, suggestedMaxPriorityFeePerGas),
+                    };
+                }
+            }
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                // The LEGACY type includes low, medium and high estimates of
+                // gas price values.
+                return {
+                    gasPrice: __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates.medium),
+                };
+            }
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
+                // The ETH_GASPRICE type just includes a single gas price property,
+                // which we can assume was retrieved from eth_gasPrice
+                return {
+                    gasPrice: __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates.gasPrice),
+                };
+            }
+        }
+        catch (error) {
+            (0, exports.log)('Failed to get suggested gas fees', error);
+        }
+        const gasPriceDecimal = (yield (0, controller_utils_1.query)(ethQuery, 'gasPrice'));
+        const gasPrice = gasPriceDecimal
+            ? (0, ethereumjs_util_1.addHexPrefix)(gasPriceDecimal.toString(16))
+            : undefined;
+        return { gasPrice };
+    });
+}, _DefaultGasFlow_estimateGas = function _DefaultGasFlow_estimateGas(txParams, ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const request = Object.assign({}, txParams);
+        const { data, value } = request;
+        const { gasLimit: gasLimitHex, number: blockNumber } = yield __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_getLatestBlock).call(this, ethQuery);
+        const gasLimitBN = (0, controller_utils_1.hexToBN)(gasLimitHex);
+        request.data = data ? (0, ethereumjs_util_1.addHexPrefix)(data) : data;
+        request.gas = (0, controller_utils_1.BNToHex)((0, controller_utils_1.fractionBN)(gasLimitBN, 19, 20));
+        request.value = value || '0x0';
+        let estimatedGas = request.gas;
+        let simulationFails;
+        try {
+            estimatedGas = yield (0, controller_utils_1.query)(ethQuery, 'estimateGas', [request]);
+            // TODO: Replace `any` with type
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        }
+        catch (error) {
+            simulationFails = {
+                reason: error.message,
+                errorKey: error.errorKey,
+                debug: {
+                    blockNumber,
+                    blockGasLimit: gasLimitHex,
+                },
+            };
+            (0, exports.log)('Estimation failed', Object.assign(Object.assign({}, simulationFails), { fallback: estimatedGas }));
+        }
+        return {
+            blockGasLimit: gasLimitHex,
+            estimatedGas,
+            simulationFails,
+        };
+    });
+}, _DefaultGasFlow_addGasBuffer = function _DefaultGasFlow_addGasBuffer(estimatedGas, blockGasLimit, multiplier) {
+    const estimatedGasBN = (0, controller_utils_1.hexToBN)(estimatedGas);
+    const maxGasBN = (0, controller_utils_1.hexToBN)(blockGasLimit).muln(0.9);
+    const paddedGasBN = estimatedGasBN.muln(multiplier);
+    if (estimatedGasBN.gt(maxGasBN)) {
+        const estimatedGasHex = (0, ethereumjs_util_1.addHexPrefix)(estimatedGas);
+        (0, exports.log)('Using estimated value', estimatedGasHex);
+        return estimatedGasHex;
+    }
+    if (paddedGasBN.lt(maxGasBN)) {
+        const paddedHex = (0, ethereumjs_util_1.addHexPrefix)((0, controller_utils_1.BNToHex)(paddedGasBN));
+        (0, exports.log)('Using padded estimate', paddedHex, multiplier);
+        return paddedHex;
+    }
+    const maxHex = (0, ethereumjs_util_1.addHexPrefix)((0, controller_utils_1.BNToHex)(maxGasBN));
+    (0, exports.log)('Using 90% of block gas limit', maxHex);
+    return maxHex;
+}, _DefaultGasFlow_requiresFixedGas = function _DefaultGasFlow_requiresFixedGas({ ethQuery, txMeta, providerConfig, }) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const isCustomNetwork = providerConfig.type === controller_utils_1.NetworkType.rpc;
+        const { txParams: { to, data }, } = txMeta;
+        if (isCustomNetwork || !to || data) {
+            return false;
+        }
+        const code = yield __classPrivateFieldGet(this, _DefaultGasFlow_instances, "m", _DefaultGasFlow_getCode).call(this, ethQuery, to);
+        return !code || code === '0x';
+    });
+}, _DefaultGasFlow_getCode = function _DefaultGasFlow_getCode(ethQuery, address) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(ethQuery, 'getCode', [address]);
+    });
+}, _DefaultGasFlow_getLatestBlock = function _DefaultGasFlow_getLatestBlock(ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield (0, controller_utils_1.query)(ethQuery, 'getBlockByNumber', ['latest', false]);
+    });
+}, _DefaultGasFlow_gweiDecimalToWeiHex = function _DefaultGasFlow_gweiDecimalToWeiHex(value) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(value));
+};
+//# sourceMappingURL=DefaultGasFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/AbstractGasFlow.d.ts b/dist/gas-flows/AbstractGasFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..54184779871e7e78b304135d4f70eaf4a87b2f6a
--- /dev/null
+++ b/dist/gas-flows/AbstractGasFlow.d.ts
@@ -0,0 +1,27 @@
+import type EthQuery from '@metamask/eth-query';
+import type { ProviderConfig } from '@metamask/network-controller';
+import type { TransactionMeta } from '../types';
+export declare type GasFlowRequest = {
+    eip1559: boolean;
+    ethQuery: EthQuery;
+    providerConfig: ProviderConfig;
+    txMeta: TransactionMeta;
+};
+export declare type GasFlowFeeLevelResponse = {
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    gasPrice?: string;
+};
+export declare type GasFlowResponse = {
+    gas: string;
+    gasFees: {
+        low: GasFlowFeeLevelResponse;
+        medium: GasFlowFeeLevelResponse;
+        high: GasFlowFeeLevelResponse;
+    };
+};
+export declare abstract class AbstractGasFlow {
+    abstract matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    abstract getSuggestedGas(request: GasFlowRequest): Promise<GasFlowResponse>;
+}
+//# sourceMappingURL=AbstractGasFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/AbstractGasFlow.js b/dist/gas-flows/AbstractGasFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..3f99c476c84ea41446f50f6c07ec53e5135a862a
--- /dev/null
+++ b/dist/gas-flows/AbstractGasFlow.js
@@ -0,0 +1,7 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.AbstractGasFlow = void 0;
+class AbstractGasFlow {
+}
+exports.AbstractGasFlow = AbstractGasFlow;
+//# sourceMappingURL=AbstractGasFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.d.ts b/dist/gas-flows/DefaultGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..325802b3bdecba22343ebacc0c07d0ea087bce52
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+export declare class DefaultGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..78385500028d2571b73b7d6e84170aad386075c7
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -0,0 +1,83 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFeeFlow_instances, _DefaultGasFeeFlow_getFeeMarketGasFees, _DefaultGasFeeFlow_getLegacyGasFees, _DefaultGasFeeFlow_getFeeMarketLevel, _DefaultGasFeeFlow_getLegacyLevel, _DefaultGasFeeFlow_gweiDecimalToWeiHex;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'default-gas-fee-flow');
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+class DefaultGasFeeFlow {
+    constructor() {
+        _DefaultGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { getGasFeeControllerEstimates } = request;
+            const response = yield getGasFeeControllerEstimates();
+            if (response.gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketGasFees).call(this, response.gasFeeEstimates);
+            }
+            else if (response.gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyGasFees).call(this, response.gasFeeEstimates);
+            }
+            throw new Error('No gas fee estimates available');
+        });
+    }
+}
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+_DefaultGasFeeFlow_instances = new WeakSet(), _DefaultGasFeeFlow_getFeeMarketGasFees = function _DefaultGasFeeFlow_getFeeMarketGasFees(gasFeeEstimates) {
+    log('Using fee market estimates', gasFeeEstimates);
+    return {
+        estimates: {
+            low: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, 'low'),
+            medium: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, 'medium'),
+            high: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, 'high'),
+        },
+    };
+}, _DefaultGasFeeFlow_getLegacyGasFees = function _DefaultGasFeeFlow_getLegacyGasFees(gasFeeEstimates) {
+    log('Using legacy estimates', gasFeeEstimates);
+    return {
+        estimates: {
+            low: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, 'low'),
+            medium: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, 'medium'),
+            high: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, 'high'),
+        },
+    };
+}, _DefaultGasFeeFlow_getFeeMarketLevel = function _DefaultGasFeeFlow_getFeeMarketLevel(gasFeeEstimates, level) {
+    const maxFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxFeePerGas);
+    const maxPriorityFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxPriorityFeePerGas);
+    return {
+        maxFeePerGas,
+        maxPriorityFeePerGas,
+    };
+}, _DefaultGasFeeFlow_getLegacyLevel = function _DefaultGasFeeFlow_getLegacyLevel(gasFeeEstimates, level) {
+    const gasPrice = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level]);
+    return {
+        maxFeePerGas: gasPrice,
+        maxPriorityFeePerGas: gasPrice,
+    };
+}, _DefaultGasFeeFlow_gweiDecimalToWeiHex = function _DefaultGasFeeFlow_gweiDecimalToWeiHex(gweiDecimal) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(gweiDecimal));
+};
+//# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFlow.d.ts b/dist/gas-flows/DefaultGasFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..675a7b289d59d9758e473ff54741e74e9c9d7d82
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFlow.d.ts
@@ -0,0 +1 @@
+//# sourceMappingURL=DefaultGasFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFlow.js b/dist/gas-flows/DefaultGasFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..bd27989f25f3f5c38bdab936cac317dd72baf176
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFlow.js
@@ -0,0 +1,197 @@
+"use strict";
+// import {
+//   BNToHex,
+//   NetworkType,
+//   fractionBN,
+//   gweiDecToWEIBN,
+//   hexToBN,
+//   query,
+//   toHex,
+// } from '@metamask/controller-utils';
+// import type EthQuery from '@metamask/eth-query';
+// import {
+//   GAS_ESTIMATE_TYPES,
+//   type GasFeeState,
+// } from '@metamask/gas-fee-controller';
+// import { addHexPrefix } from 'ethereumjs-util';
+// import { GAS_BUFFER_CHAIN_OVERRIDES } from '../constants';
+// import { createModuleLogger, projectLogger } from '../logger';
+// import type { TransactionMeta, TransactionParams } from '../types';
+// import type { GasFlowRequest, GasFlowResponse } from './AbstractGasFlow';
+// import { AbstractGasFlow } from './AbstractGasFlow';
+// export const log = createModuleLogger(projectLogger, 'gas-flow-default');
+// export const FIXED_GAS = '0x5208';
+// export const DEFAULT_GAS_MULTIPLIER = 1.5;
+// export class DefaultGasFlow extends AbstractGasFlow {
+//   #getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+//   constructor({
+//     getGasFeeControllerEstimates,
+//   }: {
+//     getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+//   }) {
+//     super();
+//     this.#getGasFeeControllerEstimates = getGasFeeControllerEstimates;
+//   }
+//   matchesTransaction(_transactionMeta: TransactionMeta): boolean {
+//     return true;
+//   }
+//   async getSuggestedGas(request: GasFlowRequest): Promise<GasFlowResponse> {
+//     const gas = await this.#getGas(request);
+//     const suggestedGasFees = await this.#getGasFees(request);
+//     return { gas, ...suggestedGasFees };
+//   }
+//   async #getGas(request: GasFlowRequest): Promise<string> {
+//     const { txMeta, providerConfig } = request;
+//     if (await this.#requiresFixedGas(request)) {
+//       log('Using fixed value', FIXED_GAS);
+//       return FIXED_GAS;
+//     }
+//     const { blockGasLimit, estimatedGas } = await this.#estimateGas(
+//       txMeta.txParams,
+//       request.ethQuery,
+//     );
+//     if (providerConfig.type === NetworkType.rpc) {
+//       log('Using original estimate as custom network');
+//       return estimatedGas;
+//     }
+//     const bufferMultiplier =
+//       GAS_BUFFER_CHAIN_OVERRIDES[
+//         providerConfig.chainId as keyof typeof GAS_BUFFER_CHAIN_OVERRIDES
+//       ] ?? DEFAULT_GAS_MULTIPLIER;
+//     const bufferedGas = this.#addGasBuffer(
+//       estimatedGas,
+//       blockGasLimit,
+//       bufferMultiplier,
+//     );
+//     return bufferedGas;
+//   }
+//   async #getGasFees(request: GasFlowRequest): Promise<{
+//     maxFeePerGas?: string | undefined;
+//     maxPriorityFeePerGas?: string | undefined;
+//     gasPrice?: string | undefined;
+//   }> {
+//     const { eip1559, ethQuery } = request;
+//     try {
+//       const { gasFeeEstimates, gasEstimateType } =
+//         await this.#getGasFeeControllerEstimates();
+//       if (eip1559 && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
+//         const {
+//           medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {},
+//         } = gasFeeEstimates;
+//         if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
+//           return {
+//             maxFeePerGas: this.#gweiDecimalToWeiHex(suggestedMaxFeePerGas),
+//             maxPriorityFeePerGas: this.#gweiDecimalToWeiHex(
+//               suggestedMaxPriorityFeePerGas,
+//             ),
+//           };
+//         }
+//       }
+//       if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
+//         // The LEGACY type includes low, medium and high estimates of
+//         // gas price values.
+//         return {
+//           gasPrice: this.#gweiDecimalToWeiHex(gasFeeEstimates.medium),
+//         };
+//       }
+//       if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
+//         // The ETH_GASPRICE type just includes a single gas price property,
+//         // which we can assume was retrieved from eth_gasPrice
+//         return {
+//           gasPrice: this.#gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),
+//         };
+//       }
+//     } catch (error) {
+//       log('Failed to get suggested gas fees', error);
+//     }
+//     const gasPriceDecimal = (await query(ethQuery, 'gasPrice')) as number;
+//     const gasPrice = gasPriceDecimal
+//       ? addHexPrefix(gasPriceDecimal.toString(16))
+//       : undefined;
+//     return { gasPrice };
+//   }
+//   async #estimateGas(txParams: TransactionParams, ethQuery: EthQuery) {
+//     const request = { ...txParams };
+//     const { data, value } = request;
+//     const { gasLimit: gasLimitHex, number: blockNumber } =
+//       await this.#getLatestBlock(ethQuery);
+//     const gasLimitBN = hexToBN(gasLimitHex);
+//     request.data = data ? addHexPrefix(data) : data;
+//     request.gas = BNToHex(fractionBN(gasLimitBN, 19, 20));
+//     request.value = value || '0x0';
+//     let estimatedGas = request.gas;
+//     let simulationFails;
+//     try {
+//       estimatedGas = await query(ethQuery, 'estimateGas', [request]);
+//       // TODO: Replace `any` with type
+//       // eslint-disable-next-line @typescript-eslint/no-explicit-any
+//     } catch (error: any) {
+//       simulationFails = {
+//         reason: error.message,
+//         errorKey: error.errorKey,
+//         debug: {
+//           blockNumber,
+//           blockGasLimit: gasLimitHex,
+//         },
+//       };
+//       log('Estimation failed', { ...simulationFails, fallback: estimatedGas });
+//     }
+//     return {
+//       blockGasLimit: gasLimitHex,
+//       estimatedGas,
+//       simulationFails,
+//     };
+//   }
+//   #addGasBuffer(
+//     estimatedGas: string,
+//     blockGasLimit: string,
+//     multiplier: number,
+//   ) {
+//     const estimatedGasBN = hexToBN(estimatedGas);
+//     const maxGasBN = hexToBN(blockGasLimit).muln(0.9);
+//     const paddedGasBN = estimatedGasBN.muln(multiplier);
+//     if (estimatedGasBN.gt(maxGasBN)) {
+//       const estimatedGasHex = addHexPrefix(estimatedGas);
+//       log('Using estimated value', estimatedGasHex);
+//       return estimatedGasHex;
+//     }
+//     if (paddedGasBN.lt(maxGasBN)) {
+//       const paddedHex = addHexPrefix(BNToHex(paddedGasBN));
+//       log('Using padded estimate', paddedHex, multiplier);
+//       return paddedHex;
+//     }
+//     const maxHex = addHexPrefix(BNToHex(maxGasBN));
+//     log('Using 90% of block gas limit', maxHex);
+//     return maxHex;
+//   }
+//   async #requiresFixedGas({
+//     ethQuery,
+//     txMeta,
+//     providerConfig,
+//   }: GasFlowRequest): Promise<boolean> {
+//     const isCustomNetwork = providerConfig.type === NetworkType.rpc;
+//     const {
+//       txParams: { to, data },
+//     } = txMeta;
+//     if (isCustomNetwork || !to || data) {
+//       return false;
+//     }
+//     const code = await this.#getCode(ethQuery, to);
+//     return !code || code === '0x';
+//   }
+//   async #getCode(
+//     ethQuery: EthQuery,
+//     address: string,
+//   ): Promise<string | undefined> {
+//     return await query(ethQuery, 'getCode', [address]);
+//   }
+//   async #getLatestBlock(
+//     ethQuery: EthQuery,
+//   ): Promise<{ gasLimit: string; number: string }> {
+//     return await query(ethQuery, 'getBlockByNumber', ['latest', false]);
+//   }
+//   #gweiDecimalToWeiHex(value: string) {
+//     return toHex(gweiDecToWEIBN(value));
+//   }
+// }
+//# sourceMappingURL=DefaultGasFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.d.ts b/dist/gas-flows/LineaGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..69f2e71643131a073dd87eafedbea2520b989506
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - The GasFeeController to provide the priority fee deltas based on recent block analysis.
+ */
+export declare class LineaGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=LineaGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..13e4685b99e1fd2e1bdff42f5efa530414da8fe7
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -0,0 +1,128 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _LineaGasFeeFlow_instances, _LineaGasFeeFlow_getLineaResponse, _LineaGasFeeFlow_getBaseFees, _LineaGasFeeFlow_getPriorityFees, _LineaGasFeeFlow_getMaxFees, _LineaGasFeeFlow_logDifferencesToGasFeeController;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.LineaGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'linea-gas-fee-flow');
+const ONE_GWEI_IN_WEI = 1e9;
+const LINEA_CHAIN_IDS = [
+    controller_utils_1.ChainId['linea-mainnet'],
+    controller_utils_1.ChainId['linea-goerli'],
+];
+const BASE_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.35,
+    high: 1.7,
+};
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - The GasFeeController to provide the priority fee deltas based on recent block analysis.
+ */
+class LineaGasFeeFlow {
+    constructor() {
+        _LineaGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(transactionMeta) {
+        return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { ethQuery, getGasFeeControllerEstimates, transactionMeta } = request;
+            const lineaResponse = yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaResponse).call(this, transactionMeta, ethQuery);
+            log('Received Linea response', lineaResponse);
+            const gasFeeControllerEstimates = yield getGasFeeControllerEstimates();
+            log('Received gas fee controller estimates', gasFeeControllerEstimates);
+            if (gasFeeControllerEstimates.gasEstimateType !==
+                gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                throw new Error('No gas fee estimates available');
+            }
+            const baseFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getBaseFees).call(this, lineaResponse);
+            const priorityFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getPriorityFees).call(this, lineaResponse, gasFeeControllerEstimates.gasFeeEstimates);
+            const maxFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getMaxFees).call(this, baseFees, priorityFees);
+            log('Calculated Linea fees', { baseFees, priorityFees, maxFees });
+            __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_logDifferencesToGasFeeController).call(this, maxFees, gasFeeControllerEstimates.gasFeeEstimates);
+            return {
+                estimates: {
+                    low: {
+                        maxFeePerGas: (0, controller_utils_1.toHex)(maxFees.low),
+                        maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees.low),
+                    },
+                    medium: {
+                        maxFeePerGas: (0, controller_utils_1.toHex)(maxFees.medium),
+                        maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees.medium),
+                    },
+                    high: {
+                        maxFeePerGas: (0, controller_utils_1.toHex)(maxFees.high),
+                        maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees.high),
+                    },
+                },
+            };
+        });
+    }
+}
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+_LineaGasFeeFlow_instances = new WeakSet(), _LineaGasFeeFlow_getLineaResponse = function _LineaGasFeeFlow_getLineaResponse(transactionMeta, ethQuery) {
+    return (0, controller_utils_1.query)(ethQuery, 'linea_estimateGas', [
+        {
+            from: transactionMeta.txParams.from,
+            to: transactionMeta.txParams.to,
+            value: transactionMeta.txParams.value,
+            input: transactionMeta.txParams.data,
+            gasPrice: '0x100000000',
+        },
+    ]);
+}, _LineaGasFeeFlow_getBaseFees = function _LineaGasFeeFlow_getBaseFees(lineaResponse) {
+    const baseFeeLow = (0, controller_utils_1.hexToBN)(lineaResponse.baseFeePerGas);
+    const baseFeeMedium = baseFeeLow.muln(BASE_FEE_MULTIPLIERS.medium);
+    const baseFeeHigh = baseFeeLow.muln(BASE_FEE_MULTIPLIERS.high);
+    return {
+        low: baseFeeLow,
+        medium: baseFeeMedium,
+        high: baseFeeHigh,
+    };
+}, _LineaGasFeeFlow_getPriorityFees = function _LineaGasFeeFlow_getPriorityFees(lineaResponse, gasFeeEstimates) {
+    const mediumPriorityIncrease = (0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.medium.suggestedMaxPriorityFeePerGas).sub((0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.low.suggestedMaxPriorityFeePerGas));
+    const highPriorityIncrease = (0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.high.suggestedMaxPriorityFeePerGas).sub((0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.medium.suggestedMaxPriorityFeePerGas));
+    const priorityFeeLow = (0, controller_utils_1.hexToBN)(lineaResponse.priorityFeePerGas);
+    const priorityFeeMedium = priorityFeeLow.add(mediumPriorityIncrease);
+    const priorityFeeHigh = priorityFeeMedium.add(highPriorityIncrease);
+    return {
+        low: priorityFeeLow,
+        medium: priorityFeeMedium,
+        high: priorityFeeHigh,
+    };
+}, _LineaGasFeeFlow_getMaxFees = function _LineaGasFeeFlow_getMaxFees(baseFees, priorityFees) {
+    return {
+        low: baseFees.low.add(priorityFees.low),
+        medium: baseFees.medium.add(priorityFees.medium),
+        high: baseFees.high.add(priorityFees.high),
+    };
+}, _LineaGasFeeFlow_logDifferencesToGasFeeController = function _LineaGasFeeFlow_logDifferencesToGasFeeController(maxFees, gasFeeControllerEstimates) {
+    const calculateDifference = (level) => {
+        const newMaxFeeWeiDec = maxFees[level].toNumber();
+        const newMaxFeeGweiDec = newMaxFeeWeiDec / ONE_GWEI_IN_WEI;
+        const oldMaxFeeGweiDec = parseFloat(gasFeeControllerEstimates[level].suggestedMaxFeePerGas);
+        const percentDifference = (newMaxFeeGweiDec / oldMaxFeeGweiDec - 1) * 100;
+        return `${percentDifference > 0 ? '+' : ''}${percentDifference.toFixed(2)}%`;
+    };
+    log('Difference to gas fee controller', calculateDifference('low'), calculateDifference('medium'), calculateDifference('high'));
+};
+//# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/TestGasFeeFlow.d.ts b/dist/gas-flows/TestGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..775672bd4ef3f3167047e28050c058a627d1255e
--- /dev/null
+++ b/dist/gas-flows/TestGasFeeFlow.d.ts
@@ -0,0 +1,7 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+export declare class TestGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=TestGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/TestGasFeeFlow.js b/dist/gas-flows/TestGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..d2f0932db8670b654e9fe163510018dd5558dfac
--- /dev/null
+++ b/dist/gas-flows/TestGasFeeFlow.js
@@ -0,0 +1,64 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var _TestGasFeeFlow_instances, _TestGasFeeFlow_increment, _TestGasFeeFlow_getFeeLevel;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.TestGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const MULTIPLIER = 10e17;
+const LEVEL_INCREMENTS = {
+    low: 0,
+    medium: 1,
+    high: 2,
+};
+class TestGasFeeFlow {
+    constructor() {
+        _TestGasFeeFlow_instances.add(this);
+        _TestGasFeeFlow_increment.set(this, 0);
+    }
+    matchesTransaction(transactionMeta) {
+        return transactionMeta.chainId === controller_utils_1.ChainId.sepolia;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { transactionMeta } = request;
+            __classPrivateFieldSet(this, _TestGasFeeFlow_increment, __classPrivateFieldGet(this, _TestGasFeeFlow_increment, "f") + 1, "f");
+            const gas = (0, controller_utils_1.hexToBN)(transactionMeta.txParams.gas).toNumber();
+            return {
+                estimates: {
+                    low: __classPrivateFieldGet(this, _TestGasFeeFlow_instances, "m", _TestGasFeeFlow_getFeeLevel).call(this, 'low', gas),
+                    medium: __classPrivateFieldGet(this, _TestGasFeeFlow_instances, "m", _TestGasFeeFlow_getFeeLevel).call(this, 'medium', gas),
+                    high: __classPrivateFieldGet(this, _TestGasFeeFlow_instances, "m", _TestGasFeeFlow_getFeeLevel).call(this, 'high', gas),
+                },
+            };
+        });
+    }
+}
+exports.TestGasFeeFlow = TestGasFeeFlow;
+_TestGasFeeFlow_increment = new WeakMap(), _TestGasFeeFlow_instances = new WeakSet(), _TestGasFeeFlow_getFeeLevel = function _TestGasFeeFlow_getFeeLevel(level, gas) {
+    const maxFeePerGas = Math.floor(((__classPrivateFieldGet(this, _TestGasFeeFlow_increment, "f") + LEVEL_INCREMENTS[level]) * MULTIPLIER) / gas);
+    const maxPriorityFeePerGas = Math.floor(maxFeePerGas * 0.2);
+    return {
+        maxFeePerGas: (0, controller_utils_1.toHex)(maxFeePerGas),
+        maxPriorityFeePerGas: (0, controller_utils_1.toHex)(maxPriorityFeePerGas),
+    };
+};
+//# sourceMappingURL=TestGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/TestGasFlow.d.ts b/dist/gas-flows/TestGasFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..28157abe1f4bfee93fc54f29a2a471f295563eab
--- /dev/null
+++ b/dist/gas-flows/TestGasFlow.d.ts
@@ -0,0 +1,9 @@
+import type { TransactionMeta } from '../types';
+import type { GasFlowRequest, GasFlowResponse } from './AbstractGasFlow';
+import { AbstractGasFlow } from './AbstractGasFlow';
+export declare class TestGasFlow extends AbstractGasFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getSuggestedGas(_request: GasFlowRequest): Promise<GasFlowResponse>;
+}
+//# sourceMappingURL=TestGasFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/TestGasFlow.js b/dist/gas-flows/TestGasFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..c154323971d2aecceeb8e138b66c69bf3049e789
--- /dev/null
+++ b/dist/gas-flows/TestGasFlow.js
@@ -0,0 +1,57 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var _TestGasFlow_increment;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.TestGasFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const AbstractGasFlow_1 = require("./AbstractGasFlow");
+const LEVEL_MULTIPLIERS = {
+    low: 1,
+    medium: 1.5,
+    high: 2,
+};
+class TestGasFlow extends AbstractGasFlow_1.AbstractGasFlow {
+    constructor() {
+        super(...arguments);
+        _TestGasFlow_increment.set(this, 0);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getSuggestedGas(_request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            __classPrivateFieldSet(this, _TestGasFlow_increment, __classPrivateFieldGet(this, _TestGasFlow_increment, "f") + 1, "f");
+            const gas = (0, controller_utils_1.toHex)(1000 + __classPrivateFieldGet(this, _TestGasFlow_increment, "f"));
+            const gasFees = ['low', 'medium', 'high'].reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: {
+                    maxPriorityFeePerGas: (0, controller_utils_1.toHex)(Math.floor(__classPrivateFieldGet(this, _TestGasFlow_increment, "f") * 0.2 * LEVEL_MULTIPLIERS[level])),
+                    maxFeePerGas: (0, controller_utils_1.toHex)(Math.floor(__classPrivateFieldGet(this, _TestGasFlow_increment, "f") * LEVEL_MULTIPLIERS[level])),
+                } })), {});
+            return {
+                gas,
+                gasFees,
+            };
+        });
+    }
+}
+exports.TestGasFlow = TestGasFlow;
+_TestGasFlow_increment = new WeakMap();
+//# sourceMappingURL=TestGasFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.d.ts b/dist/helpers/GasFeePoller.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2544727d4c3800ad78679448b7d7a66689964a08
--- /dev/null
+++ b/dist/helpers/GasFeePoller.d.ts
@@ -0,0 +1,33 @@
+/// <reference types="node" />
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import type { Hex } from '@metamask/utils';
+import EventEmitter from 'events';
+import type { GasFeeFlow } from '../types';
+import { type TransactionMeta } from '../types';
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+export declare class GasFeePoller {
+    #private;
+    hub: EventEmitter;
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }: {
+        gasFeeFlows: GasFeeFlow[];
+        getChainIds: () => Hex[];
+        getEthQuery: () => EthQuery;
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+        getTransactions: () => TransactionMeta[];
+        onStateChange: (listener: () => void) => void;
+    });
+}
+//# sourceMappingURL=GasFeePoller.d.ts.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.js b/dist/helpers/GasFeePoller.js
new file mode 100644
index 0000000000000000000000000000000000000000..d1cab141f99c3efc95336c93d2a41014071fee91
--- /dev/null
+++ b/dist/helpers/GasFeePoller.js
@@ -0,0 +1,142 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _GasFeePoller_instances, _GasFeePoller_gasFeeFlows, _GasFeePoller_getChainIds, _GasFeePoller_getEthQuery, _GasFeePoller_getGasFeeControllerEstimates, _GasFeePoller_getTransactions, _GasFeePoller_timeout, _GasFeePoller_running, _GasFeePoller_start, _GasFeePoller_stop, _GasFeePoller_onTimeout, _GasFeePoller_updateUnapprovedTransactions, _GasFeePoller_updateTransactionSuggestedFees, _GasFeePoller_getUnapprovedTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeePoller = void 0;
+const utils_1 = require("@metamask/utils");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_flow_1 = require("../utils/gas-flow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-poller');
+const INTERVAL_MILLISECONDS = 10000;
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+class GasFeePoller {
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }) {
+        _GasFeePoller_instances.add(this);
+        this.hub = new events_1.default();
+        _GasFeePoller_gasFeeFlows.set(this, void 0);
+        _GasFeePoller_getChainIds.set(this, void 0);
+        _GasFeePoller_getEthQuery.set(this, void 0);
+        _GasFeePoller_getGasFeeControllerEstimates.set(this, void 0);
+        _GasFeePoller_getTransactions.set(this, void 0);
+        _GasFeePoller_timeout.set(this, void 0);
+        _GasFeePoller_running.set(this, false);
+        __classPrivateFieldSet(this, _GasFeePoller_gasFeeFlows, gasFeeFlows, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getChainIds, getChainIds, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getTransactions, getTransactions, "f");
+        onStateChange(() => {
+            const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+            if (unapprovedTransactions.length) {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_stop).call(this);
+            }
+        });
+    }
+}
+exports.GasFeePoller = GasFeePoller;
+_GasFeePoller_gasFeeFlows = new WeakMap(), _GasFeePoller_getChainIds = new WeakMap(), _GasFeePoller_getEthQuery = new WeakMap(), _GasFeePoller_getGasFeeControllerEstimates = new WeakMap(), _GasFeePoller_getTransactions = new WeakMap(), _GasFeePoller_timeout = new WeakMap(), _GasFeePoller_running = new WeakMap(), _GasFeePoller_instances = new WeakSet(), _GasFeePoller_start = function _GasFeePoller_start() {
+    if (__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    // Intentionally not awaiting since this starts the timeout chain.
+    // eslint-disable-next-line @typescript-eslint/no-floating-promises
+    __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this);
+    __classPrivateFieldSet(this, _GasFeePoller_running, true, "f");
+    log('Started polling');
+}, _GasFeePoller_stop = function _GasFeePoller_stop() {
+    if (!__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    clearTimeout(__classPrivateFieldGet(this, _GasFeePoller_timeout, "f"));
+    __classPrivateFieldSet(this, _GasFeePoller_timeout, undefined, "f");
+    __classPrivateFieldSet(this, _GasFeePoller_running, false, "f");
+    log('Stopped polling');
+}, _GasFeePoller_onTimeout = function _GasFeePoller_onTimeout() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateUnapprovedTransactions).call(this);
+        // eslint-disable-next-line @typescript-eslint/no-misused-promises
+        __classPrivateFieldSet(this, _GasFeePoller_timeout, setTimeout(() => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this), INTERVAL_MILLISECONDS), "f");
+    });
+}, _GasFeePoller_updateUnapprovedTransactions = function _GasFeePoller_updateUnapprovedTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+        log('Found unapproved transactions', {
+            count: unapprovedTransactions.length,
+        });
+        const ethQuery = __classPrivateFieldGet(this, _GasFeePoller_getEthQuery, "f").call(this);
+        for (const transactionMeta of unapprovedTransactions) {
+            yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateTransactionSuggestedFees).call(this, transactionMeta, ethQuery);
+        }
+    });
+}, _GasFeePoller_updateTransactionSuggestedFees = function _GasFeePoller_updateTransactionSuggestedFees(transactionMeta, ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(transactionMeta, __classPrivateFieldGet(this, _GasFeePoller_gasFeeFlows, "f"));
+        if (!gasFeeFlow) {
+            log('Skipping update as no gas fee flow found', transactionMeta.id);
+            return;
+        }
+        log('Found gas fee flow', gasFeeFlow.constructor.name, transactionMeta.id);
+        const request = {
+            ethQuery,
+            getGasFeeControllerEstimates: __classPrivateFieldGet(this, _GasFeePoller_getGasFeeControllerEstimates, "f"),
+            transactionMeta,
+        };
+        try {
+            const response = yield gasFeeFlow.getGasFees(request);
+            transactionMeta.gasFeeEstimates = response.estimates;
+        }
+        catch (error) {
+            log('Failed to get suggested gas fees', transactionMeta.id, error);
+            return;
+        }
+        this.hub.emit('transaction-updated', transactionMeta, 'GasFeePoller - Suggested gas fees updated');
+        log('Updated suggested gas fees', {
+            gasFeeEstimates: transactionMeta.gasFeeEstimates,
+            transaction: transactionMeta.id,
+        });
+    });
+}, _GasFeePoller_getUnapprovedTransactions = function _GasFeePoller_getUnapprovedTransactions() {
+    const chainIds = __classPrivateFieldGet(this, _GasFeePoller_getChainIds, "f").call(this);
+    return __classPrivateFieldGet(this, _GasFeePoller_getTransactions, "f").call(this).filter((tx) => chainIds.includes(tx.chainId) &&
+        tx.status === types_1.TransactionStatus.unapproved);
+};
+//# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 365c05b9c144b70bd2d52b568fb377e32d427c36..6d820055872191629c360a580b36e02b4c788533 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -3,4 +3,5 @@ export type { EtherscanTransactionMeta } from './utils/etherscan';
 export { isEIP1559Transaction } from './utils/utils';
 export * from './types';
 export { determineTransactionType } from './utils/transaction-type';
+export { mergeGasFeeControllerAndTransactionGasFeeEstimates } from './utils/gas-flow';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index ab09b74aed5d901cb106652da553935a35ac1b47..c4cfa43d5b94d05913a8dfe597427d1b3d734858 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -14,11 +14,13 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
+exports.mergeGasFeeControllerAndTransactionGasFeeEstimates = exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils/utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
 __exportStar(require("./types"), exports);
 var transaction_type_1 = require("./utils/transaction-type");
 Object.defineProperty(exports, "determineTransactionType", { enumerable: true, get: function () { return transaction_type_1.determineTransactionType; } });
+var gas_flow_1 = require("./utils/gas-flow");
+Object.defineProperty(exports, "mergeGasFeeControllerAndTransactionGasFeeEstimates", { enumerable: true, get: function () { return gas_flow_1.mergeGasFeeControllerAndTransactionGasFeeEstimates; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types.d.ts b/dist/types.d.ts
index d80d057d48112d9047fc6fe419c132c44a53c509..d7bcd6823dfb462b8d2d6f18cb1bc60966afc2e3 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -1,4 +1,6 @@
 import type { AccessList } from '@ethereumjs/tx';
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
 import type { Hex } from '@metamask/utils';
 import type { Operation } from 'fast-json-patch';
 export declare type Events = {
@@ -285,6 +287,7 @@ declare type TransactionMetaBase = {
      * The time the transaction was submitted to the network, in Unix epoch time (ms).
      */
     submittedTime?: number;
+    gasFeeEstimates?: GasFeeEstimates;
     /**
      * The symbol of the token being swapped.
      */
@@ -799,5 +802,50 @@ export declare type SecurityAlertResponse = {
     result_type: string;
     providerRequestsCount?: Record<string, number>;
 };
+/** Gas fee estimates for a specific priority level. */
+export declare type GasFeeEstimatesLevel = {
+    /** Maximum amount to pay per gas. */
+    maxFeePerGas: Hex;
+    /** Maximum amount per gas to give to the validator as an incentive. */
+    maxPriorityFeePerGas: Hex;
+};
+/** Gas fee estimates for a transaction. */
+export declare type GasFeeEstimates = {
+    /** The gas fee estimate for a low priority transaction. */
+    low: GasFeeEstimatesLevel;
+    /** The gas fee estimate for a medium priority transaction. */
+    medium: GasFeeEstimatesLevel;
+    /** The gas fee estimate for a high priority transaction. */
+    high: GasFeeEstimatesLevel;
+};
+/** Request to a gas fee flow to obtain gas fee estimates. */
+export declare type GasFeeFlowRequest = {
+    /** An EthQuery instance to enable queries to the associated RPC provider. */
+    ethQuery: EthQuery;
+    /** Callback to get the GasFeeController estimates. */
+    getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+    /** The metadata of the transaction to obtain estimates for. */
+    transactionMeta: TransactionMeta;
+};
+/** Response from a gas fee flow containing gas fee estimates. */
+export declare type GasFeeFlowResponse = {
+    /** The gas fee estimates for the transaction. */
+    estimates: GasFeeEstimates;
+};
+/** A method of obtaining gas fee estimates for a specific transaction. */
+export declare type GasFeeFlow = {
+    /**
+     * Determine if the gas fee flow supports the specified transaction.
+     * @param transactionMeta - The transaction metadata.
+     * @returns Whether the gas fee flow supports the transaction.
+     */
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    /**
+     * Get gas fee estimates for a specific transaction.
+     * @param request - The gas fee flow request.
+     * @returns The gas fee flow response containing the gas fee estimates.
+     */
+    getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.d.ts b/dist/utils/gas-fees.d.ts
index 9ed9fddd65c4f6504aa018c793d6a4915873b4bc..ef16e4846f259fc7bf1de6d2bd08278be06e1156 100644
--- a/dist/utils/gas-fees.d.ts
+++ b/dist/utils/gas-fees.d.ts
@@ -1,31 +1,24 @@
 import type EthQuery from '@metamask/eth-query';
 import type { GasFeeState } from '@metamask/gas-fee-controller';
-import type { SavedGasFees, TransactionParams, TransactionMeta } from '../types';
+import type { SavedGasFees, TransactionParams, TransactionMeta, GasFeeFlow } from '../types';
 export declare type UpdateGasFeesRequest = {
     eip1559: boolean;
     ethQuery: EthQuery;
+    gasFeeFlows: GasFeeFlow[];
     getSavedGasFees: () => SavedGasFees | undefined;
     getGasFeeEstimates: () => Promise<GasFeeState>;
     txMeta: TransactionMeta;
 };
 export declare type GetGasFeeRequest = UpdateGasFeesRequest & {
-    savedGasFees?: SavedGasFees;
     initialParams: TransactionParams;
-    suggestedGasFees: Awaited<ReturnType<typeof getSuggestedGasFees>>;
+    savedGasFees?: SavedGasFees;
+    suggestedGasFees: SuggestedGasFees;
+};
+declare type SuggestedGasFees = {
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    gasPrice?: string;
 };
 export declare function updateGasFees(request: UpdateGasFeesRequest): Promise<void>;
-declare function getSuggestedGasFees(request: UpdateGasFeesRequest): Promise<{
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-    gasPrice?: undefined;
-} | {
-    maxFeePerGas: `0x${string}`;
-    maxPriorityFeePerGas: `0x${string}`;
-    gasPrice?: undefined;
-} | {
-    gasPrice: string | undefined;
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-}>;
 export {};
 //# sourceMappingURL=gas-fees.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index 823fa99ce6763695231177916fd41a20b1c31fdb..16296d2e012c33eb20cd5b172b5ac91bb246785e 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -12,11 +12,11 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.updateGasFees = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
-const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
 const utils_1 = require("@metamask/utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const logger_1 = require("../logger");
 const types_1 = require("../types");
+const gas_flow_1 = require("./gas-flow");
 const swaps_1 = require("./swaps");
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fees');
 function updateGasFees(request) {
@@ -27,8 +27,8 @@ function updateGasFees(request) {
         const savedGasFees = isSwap ? undefined : request.getSavedGasFees();
         const suggestedGasFees = yield getSuggestedGasFees(request);
         log('Suggested gas fees', suggestedGasFees);
-        const getGasFeeRequest = Object.assign(Object.assign({}, request), { savedGasFees,
-            initialParams,
+        const getGasFeeRequest = Object.assign(Object.assign({}, request), { initialParams,
+            savedGasFees,
             suggestedGasFees });
         txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
         txMeta.txParams.maxPriorityFeePerGas =
@@ -118,6 +118,10 @@ function getGasPrice(request) {
         log('Using gasPrice from request', initialParams.gasPrice);
         return initialParams.gasPrice;
     }
+    if (suggestedGasFees.maxFeePerGas) {
+        log('Using suggested maxFeePerGas', suggestedGasFees.maxFeePerGas);
+        return suggestedGasFees.maxFeePerGas;
+    }
     if (suggestedGasFees.gasPrice) {
         log('Using suggested gasPrice', suggestedGasFees.gasPrice);
         return suggestedGasFees.gasPrice;
@@ -163,38 +167,21 @@ function updateDefaultGasEstimates(txMeta) {
 }
 function getSuggestedGasFees(request) {
     return __awaiter(this, void 0, void 0, function* () {
-        const { eip1559, ethQuery, getGasFeeEstimates, txMeta } = request;
+        const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
         if ((!eip1559 && txMeta.txParams.gasPrice) ||
             (eip1559 &&
                 txMeta.txParams.maxFeePerGas &&
                 txMeta.txParams.maxPriorityFeePerGas)) {
             return {};
         }
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(txMeta, gasFeeFlows);
         try {
-            const { gasFeeEstimates, gasEstimateType } = yield getGasFeeEstimates();
-            if (eip1559 && gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
-                const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {}, } = gasFeeEstimates;
-                if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
-                    return {
-                        maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),
-                        maxPriorityFeePerGas: gweiDecimalToWeiHex(suggestedMaxPriorityFeePerGas),
-                    };
-                }
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
-                // The LEGACY type includes low, medium and high estimates of
-                // gas price values.
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.medium),
-                };
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
-                // The ETH_GASPRICE type just includes a single gas price property,
-                // which we can assume was retrieved from eth_gasPrice
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),
-                };
-            }
+            const response = yield gasFeeFlow.getGasFees({
+                ethQuery,
+                getGasFeeControllerEstimates: getGasFeeEstimates,
+                transactionMeta: txMeta,
+            });
+            return response.estimates.medium;
         }
         catch (error) {
             log('Failed to get suggested gas fees', error);
diff --git a/dist/utils/gas-flow.d.ts b/dist/utils/gas-flow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0327c3b0329dc48068074f609c51a22f51c50883
--- /dev/null
+++ b/dist/utils/gas-flow.d.ts
@@ -0,0 +1,19 @@
+import { type GasFeeState } from '@metamask/gas-fee-controller';
+import type { GasFeeEstimates as TransactionGasFeeEstimates, GasFeeFlow, TransactionMeta } from '../types';
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+export declare function getGasFeeFlow(transactionMeta: TransactionMeta, gasFeeFlows: GasFeeFlow[]): GasFeeFlow | undefined;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param gasFeeControllerEstimateType - The gas fee estimate type from the gas fee controller.
+ * @param gasFeeControllerEstimates - The gas fee estimates from the GasFeeController.
+ * @param transactionGasFeeEstimates - The gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+export declare function mergeGasFeeControllerAndTransactionGasFeeEstimates(gasFeeControllerEstimateType: GasFeeState['gasEstimateType'], gasFeeControllerEstimates: GasFeeState['gasFeeEstimates'], transactionGasFeeEstimates: TransactionGasFeeEstimates): GasFeeState['gasFeeEstimates'];
+//# sourceMappingURL=gas-flow.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.js b/dist/utils/gas-flow.js
new file mode 100644
index 0000000000000000000000000000000000000000..a22f3b76647186ac1f96448ba6a18033ee82c521
--- /dev/null
+++ b/dist/utils/gas-flow.js
@@ -0,0 +1,56 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.mergeGasFeeControllerAndTransactionGasFeeEstimates = exports.getGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+    return gasFeeFlows.find((gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta));
+}
+exports.getGasFeeFlow = getGasFeeFlow;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param gasFeeControllerEstimateType - The gas fee estimate type from the gas fee controller.
+ * @param gasFeeControllerEstimates - The gas fee estimates from the GasFeeController.
+ * @param transactionGasFeeEstimates - The gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+function mergeGasFeeControllerAndTransactionGasFeeEstimates(gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates) {
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        const gasFeeControllerFeeMarketEstimates = gasFeeControllerEstimates;
+        return Object.assign(Object.assign({}, gasFeeControllerFeeMarketEstimates), { low: mergeFeeMarketEstimate(gasFeeControllerFeeMarketEstimates.low, transactionGasFeeEstimates.low), medium: mergeFeeMarketEstimate(gasFeeControllerFeeMarketEstimates.medium, transactionGasFeeEstimates.medium), high: mergeFeeMarketEstimate(gasFeeControllerFeeMarketEstimates.high, transactionGasFeeEstimates.high) });
+    }
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+        return {
+            low: getLegacyEstimate(transactionGasFeeEstimates.low),
+            medium: getLegacyEstimate(transactionGasFeeEstimates.medium),
+            high: getLegacyEstimate(transactionGasFeeEstimates.high),
+        };
+    }
+    return gasFeeControllerEstimates;
+}
+exports.mergeGasFeeControllerAndTransactionGasFeeEstimates = mergeGasFeeControllerAndTransactionGasFeeEstimates;
+/**
+ * Merge a specific priority level of EIP-1559 gas fee estimates.
+ * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The merged gas fee estimate.
+ */
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+    return Object.assign(Object.assign({}, gasFeeControllerEstimate), { suggestedMaxFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas), suggestedMaxPriorityFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxPriorityFeePerGas) });
+}
+/**
+ * Generate a specific priority level for a legacy gas fee estimate.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The legacy gas fee estimate.
+ */
+function getLegacyEstimate(transactionGasFeeEstimate) {
+    return (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas);
+}
+//# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
