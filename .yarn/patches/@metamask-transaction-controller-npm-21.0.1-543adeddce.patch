diff --git a/dist/TransactionController.d.ts b/dist/TransactionController.d.ts
index 470ed9065fa18ab5ce5b0c5fb3d3101faa6263d1..c9400c196854c82d20c33d2b802027ac833698fc 100644
--- a/dist/TransactionController.d.ts
+++ b/dist/TransactionController.d.ts
@@ -103,6 +103,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly registry;
     private readonly provider;
     private readonly mutex;
+    private readonly gasFeeFlows;
     private readonly getSavedGasFees;
     private readonly getNetworkState;
     private readonly getCurrentAccountEIP1559Compatibility;
@@ -117,6 +118,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly pendingTransactionTracker;
     private readonly cancelMultiplier;
     private readonly speedUpMultiplier;
+    private readonly signAbortCallbacks;
     private readonly afterSign;
     private readonly beforeApproveOnInit;
     private readonly beforeCheckPendingTransaction;
@@ -478,6 +480,12 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * Removes unapproved transactions from state.
      */
     clearUnapprovedTransactions(): void;
+    /**
+     * Stop the signing process for a specific transaction.
+     * Throws an error causing the transaction status to be set to failed.
+     * @param transactionId - The ID of the transaction to stop signing.
+     */
+    abortTransactionSigning(transactionId: string): void;
     private addMetadata;
     private updateGasProperties;
     private getCurrentChainTransactionsByStatus;
@@ -596,6 +604,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private getNonceTrackerTransactions;
     private onConfirmedTransaction;
     private updatePostBalance;
+    private getGasFeeFlows;
 }
 export {};
 //# sourceMappingURL=TransactionController.d.ts.map
\ No newline at end of file
diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 890cd7037609021a855937360b58f724c08cf274..0d9b553440a07369cc691514cad1d0c2d97dff1a 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -26,7 +26,10 @@ const events_1 = require("events");
 const lodash_1 = require("lodash");
 const nonce_tracker_1 = require("nonce-tracker");
 const uuid_1 = require("uuid");
+const DefaultGasFeeFlow_1 = require("./gas-flows/DefaultGasFeeFlow");
+const LineaGasFeeFlow_1 = require("./gas-flows/LineaGasFeeFlow");
 const EtherscanRemoteTransactionSource_1 = require("./helpers/EtherscanRemoteTransactionSource");
+const GasFeePoller_1 = require("./helpers/GasFeePoller");
 const IncomingTransactionHelper_1 = require("./helpers/IncomingTransactionHelper");
 const PendingTransactionTracker_1 = require("./helpers/PendingTransactionTracker");
 const logger_1 = require("./logger");
@@ -100,6 +103,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         super(config, state);
         this.inProcessOfSigning = new Set();
         this.mutex = new async_mutex_1.Mutex();
+        this.signAbortCallbacks = new Map();
         /**
          * EventEmitter instance used to listen to specific transactional events
          */
@@ -191,6 +195,19 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             },
         });
         this.addPendingTransactionTrackerListeners();
+        this.gasFeeFlows = this.getGasFeeFlows();
+        const gasFeePoller = new GasFeePoller_1.GasFeePoller({
+            // Default gas fee polling is not yet supported by the clients
+            gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+            getChainIds: () => [this.getChainId()],
+            getEthQuery: () => this.ethQuery,
+            getGasFeeControllerEstimates: this.getGasFeeEstimates,
+            getTransactions: () => this.state.transactions,
+            onStateChange: (listener) => {
+                this.subscribe(listener);
+            },
+        });
+        gasFeePoller.hub.on('transaction-updated', this.updateTransaction.bind(this));
         onNetworkStateChange(() => {
             (0, logger_1.projectLogger)('Detected network change', this.getChainId());
             this.onBootCleanup();
@@ -1034,6 +1051,23 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         const transactions = this.state.transactions.filter(({ status }) => status !== types_1.TransactionStatus.unapproved);
         this.update({ transactions: this.trimTransactionsForState(transactions) });
     }
+    /**
+     * Stop the signing process for a specific transaction.
+     * Throws an error causing the transaction status to be set to failed.
+     * @param transactionId - The ID of the transaction to stop signing.
+     */
+    abortTransactionSigning(transactionId) {
+        const transactionMeta = this.getTransaction(transactionId);
+        if (!transactionMeta) {
+            throw new Error(`Cannot abort signing as no transaction metadata found`);
+        }
+        const abortCallback = this.signAbortCallbacks.get(transactionId);
+        if (!abortCallback) {
+            throw new Error(`Cannot abort signing as transaction is not waiting for signing`);
+        }
+        abortCallback();
+        this.signAbortCallbacks.delete(transactionId);
+    }
     addMetadata(transactionMeta) {
         const { transactions } = this.state;
         transactions.push(transactionMeta);
@@ -1052,8 +1086,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             yield (0, gas_fees_1.updateGasFees)({
                 eip1559: isEIP1559Compatible,
                 ethQuery: this.ethQuery,
+                gasFeeFlows: this.gasFeeFlows,
+                getGasFeeEstimates: this.getGasFeeEstimates,
                 getSavedGasFees: this.getSavedGasFees.bind(this, chainId),
-                getGasFeeEstimates: this.getGasFeeEstimates.bind(this),
                 txMeta: transactionMeta,
             });
         });
@@ -1547,12 +1582,16 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         this.pendingTransactionTracker.hub.on('transaction-updated', this.updateTransaction.bind(this));
     }
     signTransaction(transactionMeta, txParams) {
-        var _a;
         return __awaiter(this, void 0, void 0, function* () {
             (0, logger_1.projectLogger)('Signing transaction', txParams);
             const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
             this.inProcessOfSigning.add(transactionMeta.id);
-            const signedTx = yield ((_a = this.sign) === null || _a === void 0 ? void 0 : _a.call(this, unsignedEthTx, txParams.from, ...this.getAdditionalSignArguments(transactionMeta)));
+            const signedTx = yield new Promise((resolve, reject) => {
+                var _a;
+                (_a = this.sign) === null || _a === void 0 ? void 0 : _a.call(this, unsignedEthTx, txParams.from, ...this.getAdditionalSignArguments(transactionMeta)).then(resolve, reject);
+                this.signAbortCallbacks.set(transactionMeta.id, () => reject(new Error('Signing aborted by user')));
+            });
+            this.signAbortCallbacks.delete(transactionMeta.id);
             if (!signedTx) {
                 (0, logger_1.projectLogger)('Skipping signed status as no signed transaction');
                 return undefined;
@@ -1616,6 +1655,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             }
         });
     }
+    getGasFeeFlows() {
+        return [new LineaGasFeeFlow_1.LineaGasFeeFlow(), new DefaultGasFeeFlow_1.DefaultGasFeeFlow()];
+    }
 }
 exports.TransactionController = TransactionController;
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.d.ts b/dist/gas-flows/DefaultGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..325802b3bdecba22343ebacc0c07d0ea087bce52
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+export declare class DefaultGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..78385500028d2571b73b7d6e84170aad386075c7
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -0,0 +1,83 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFeeFlow_instances, _DefaultGasFeeFlow_getFeeMarketGasFees, _DefaultGasFeeFlow_getLegacyGasFees, _DefaultGasFeeFlow_getFeeMarketLevel, _DefaultGasFeeFlow_getLegacyLevel, _DefaultGasFeeFlow_gweiDecimalToWeiHex;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'default-gas-fee-flow');
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+class DefaultGasFeeFlow {
+    constructor() {
+        _DefaultGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { getGasFeeControllerEstimates } = request;
+            const response = yield getGasFeeControllerEstimates();
+            if (response.gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketGasFees).call(this, response.gasFeeEstimates);
+            }
+            else if (response.gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyGasFees).call(this, response.gasFeeEstimates);
+            }
+            throw new Error('No gas fee estimates available');
+        });
+    }
+}
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+_DefaultGasFeeFlow_instances = new WeakSet(), _DefaultGasFeeFlow_getFeeMarketGasFees = function _DefaultGasFeeFlow_getFeeMarketGasFees(gasFeeEstimates) {
+    log('Using fee market estimates', gasFeeEstimates);
+    return {
+        estimates: {
+            low: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, 'low'),
+            medium: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, 'medium'),
+            high: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, 'high'),
+        },
+    };
+}, _DefaultGasFeeFlow_getLegacyGasFees = function _DefaultGasFeeFlow_getLegacyGasFees(gasFeeEstimates) {
+    log('Using legacy estimates', gasFeeEstimates);
+    return {
+        estimates: {
+            low: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, 'low'),
+            medium: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, 'medium'),
+            high: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, 'high'),
+        },
+    };
+}, _DefaultGasFeeFlow_getFeeMarketLevel = function _DefaultGasFeeFlow_getFeeMarketLevel(gasFeeEstimates, level) {
+    const maxFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxFeePerGas);
+    const maxPriorityFeePerGas = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level].suggestedMaxPriorityFeePerGas);
+    return {
+        maxFeePerGas,
+        maxPriorityFeePerGas,
+    };
+}, _DefaultGasFeeFlow_getLegacyLevel = function _DefaultGasFeeFlow_getLegacyLevel(gasFeeEstimates, level) {
+    const gasPrice = __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_gweiDecimalToWeiHex).call(this, gasFeeEstimates[level]);
+    return {
+        maxFeePerGas: gasPrice,
+        maxPriorityFeePerGas: gasPrice,
+    };
+}, _DefaultGasFeeFlow_gweiDecimalToWeiHex = function _DefaultGasFeeFlow_gweiDecimalToWeiHex(gweiDecimal) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(gweiDecimal));
+};
+//# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.d.ts b/dist/gas-flows/LineaGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..69f2e71643131a073dd87eafedbea2520b989506
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - The GasFeeController to provide the priority fee deltas based on recent block analysis.
+ */
+export declare class LineaGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=LineaGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..f4834e6ed03938ca27046dc2e0244af9fdc3f43c
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -0,0 +1,139 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _LineaGasFeeFlow_instances, _LineaGasFeeFlow_getLineaGasFees, _LineaGasFeeFlow_getLineaResponse, _LineaGasFeeFlow_getBaseFees, _LineaGasFeeFlow_getPriorityFees, _LineaGasFeeFlow_getMaxFees, _LineaGasFeeFlow_logDifferencesToGasFeeController;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.LineaGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const DefaultGasFeeFlow_1 = require("./DefaultGasFeeFlow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'linea-gas-fee-flow');
+const ONE_GWEI_IN_WEI = 1e9;
+const LINEA_CHAIN_IDS = [
+    controller_utils_1.ChainId['linea-mainnet'],
+    controller_utils_1.ChainId['linea-goerli'],
+];
+const BASE_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.35,
+    high: 1.7,
+};
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - The GasFeeController to provide the priority fee deltas based on recent block analysis.
+ */
+class LineaGasFeeFlow {
+    constructor() {
+        _LineaGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(transactionMeta) {
+        return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                return yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaGasFees).call(this, request);
+            }
+            catch (error) {
+                log('Using default flow as fallback due to error', error);
+                return new DefaultGasFeeFlow_1.DefaultGasFeeFlow().getGasFees(request);
+            }
+        });
+    }
+}
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+_LineaGasFeeFlow_instances = new WeakSet(), _LineaGasFeeFlow_getLineaGasFees = function _LineaGasFeeFlow_getLineaGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { ethQuery, getGasFeeControllerEstimates, transactionMeta } = request;
+        const lineaResponse = yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaResponse).call(this, transactionMeta, ethQuery);
+        log('Received Linea response', lineaResponse);
+        const gasFeeControllerEstimates = yield getGasFeeControllerEstimates();
+        log('Received gas fee controller estimates', gasFeeControllerEstimates);
+        if (gasFeeControllerEstimates.gasEstimateType !==
+            gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+            throw new Error('No gas fee estimates available');
+        }
+        const baseFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getBaseFees).call(this, lineaResponse);
+        const priorityFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getPriorityFees).call(this, lineaResponse, gasFeeControllerEstimates.gasFeeEstimates);
+        const maxFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getMaxFees).call(this, baseFees, priorityFees);
+        __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_logDifferencesToGasFeeController).call(this, maxFees, gasFeeControllerEstimates.gasFeeEstimates);
+        return {
+            estimates: {
+                low: {
+                    maxFeePerGas: (0, controller_utils_1.toHex)(maxFees.low),
+                    maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees.low),
+                },
+                medium: {
+                    maxFeePerGas: (0, controller_utils_1.toHex)(maxFees.medium),
+                    maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees.medium),
+                },
+                high: {
+                    maxFeePerGas: (0, controller_utils_1.toHex)(maxFees.high),
+                    maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees.high),
+                },
+            },
+        };
+    });
+}, _LineaGasFeeFlow_getLineaResponse = function _LineaGasFeeFlow_getLineaResponse(transactionMeta, ethQuery) {
+    return (0, controller_utils_1.query)(ethQuery, 'linea_estimateGas', [
+        {
+            from: transactionMeta.txParams.from,
+            to: transactionMeta.txParams.to,
+            value: transactionMeta.txParams.value,
+            input: transactionMeta.txParams.data,
+            gasPrice: '0x100000000',
+        },
+    ]);
+}, _LineaGasFeeFlow_getBaseFees = function _LineaGasFeeFlow_getBaseFees(lineaResponse) {
+    const baseFeeLow = (0, controller_utils_1.hexToBN)(lineaResponse.baseFeePerGas);
+    const baseFeeMedium = baseFeeLow.muln(BASE_FEE_MULTIPLIERS.medium);
+    const baseFeeHigh = baseFeeLow.muln(BASE_FEE_MULTIPLIERS.high);
+    return {
+        low: baseFeeLow,
+        medium: baseFeeMedium,
+        high: baseFeeHigh,
+    };
+}, _LineaGasFeeFlow_getPriorityFees = function _LineaGasFeeFlow_getPriorityFees(lineaResponse, gasFeeEstimates) {
+    const mediumPriorityIncrease = (0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.medium.suggestedMaxPriorityFeePerGas).sub((0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.low.suggestedMaxPriorityFeePerGas));
+    const highPriorityIncrease = (0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.high.suggestedMaxPriorityFeePerGas).sub((0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates.medium.suggestedMaxPriorityFeePerGas));
+    const priorityFeeLow = (0, controller_utils_1.hexToBN)(lineaResponse.priorityFeePerGas);
+    const priorityFeeMedium = priorityFeeLow.add(mediumPriorityIncrease);
+    const priorityFeeHigh = priorityFeeMedium.add(highPriorityIncrease);
+    return {
+        low: priorityFeeLow,
+        medium: priorityFeeMedium,
+        high: priorityFeeHigh,
+    };
+}, _LineaGasFeeFlow_getMaxFees = function _LineaGasFeeFlow_getMaxFees(baseFees, priorityFees) {
+    return {
+        low: baseFees.low.add(priorityFees.low),
+        medium: baseFees.medium.add(priorityFees.medium),
+        high: baseFees.high.add(priorityFees.high),
+    };
+}, _LineaGasFeeFlow_logDifferencesToGasFeeController = function _LineaGasFeeFlow_logDifferencesToGasFeeController(maxFees, gasFeeControllerEstimates) {
+    const calculateDifference = (level) => {
+        const newMaxFeeWeiDec = maxFees[level].toNumber();
+        const newMaxFeeGweiDec = newMaxFeeWeiDec / ONE_GWEI_IN_WEI;
+        const oldMaxFeeGweiDec = parseFloat(gasFeeControllerEstimates[level].suggestedMaxFeePerGas);
+        const percentDifference = (newMaxFeeGweiDec / oldMaxFeeGweiDec - 1) * 100;
+        /* istanbul ignore next */
+        return `${percentDifference > 0 ? '+' : ''}${percentDifference.toFixed(2)}%`;
+    };
+    log('Difference to gas fee controller', calculateDifference('low'), calculateDifference('medium'), calculateDifference('high'));
+};
+//# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.d.ts b/dist/helpers/GasFeePoller.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2544727d4c3800ad78679448b7d7a66689964a08
--- /dev/null
+++ b/dist/helpers/GasFeePoller.d.ts
@@ -0,0 +1,33 @@
+/// <reference types="node" />
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import type { Hex } from '@metamask/utils';
+import EventEmitter from 'events';
+import type { GasFeeFlow } from '../types';
+import { type TransactionMeta } from '../types';
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+export declare class GasFeePoller {
+    #private;
+    hub: EventEmitter;
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }: {
+        gasFeeFlows: GasFeeFlow[];
+        getChainIds: () => Hex[];
+        getEthQuery: () => EthQuery;
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+        getTransactions: () => TransactionMeta[];
+        onStateChange: (listener: () => void) => void;
+    });
+}
+//# sourceMappingURL=GasFeePoller.d.ts.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.js b/dist/helpers/GasFeePoller.js
new file mode 100644
index 0000000000000000000000000000000000000000..dc4be7bdbb600d8c2fe631eb216201d155cec67e
--- /dev/null
+++ b/dist/helpers/GasFeePoller.js
@@ -0,0 +1,140 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _GasFeePoller_instances, _GasFeePoller_gasFeeFlows, _GasFeePoller_getChainIds, _GasFeePoller_getEthQuery, _GasFeePoller_getGasFeeControllerEstimates, _GasFeePoller_getTransactions, _GasFeePoller_timeout, _GasFeePoller_running, _GasFeePoller_start, _GasFeePoller_stop, _GasFeePoller_onTimeout, _GasFeePoller_updateUnapprovedTransactions, _GasFeePoller_updateTransactionSuggestedFees, _GasFeePoller_getUnapprovedTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeePoller = void 0;
+const utils_1 = require("@metamask/utils");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_flow_1 = require("../utils/gas-flow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-poller');
+const INTERVAL_MILLISECONDS = 10000;
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+class GasFeePoller {
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getChainIds - Callback to specify the chain IDs to monitor.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getChainIds, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }) {
+        _GasFeePoller_instances.add(this);
+        this.hub = new events_1.default();
+        _GasFeePoller_gasFeeFlows.set(this, void 0);
+        _GasFeePoller_getChainIds.set(this, void 0);
+        _GasFeePoller_getEthQuery.set(this, void 0);
+        _GasFeePoller_getGasFeeControllerEstimates.set(this, void 0);
+        _GasFeePoller_getTransactions.set(this, void 0);
+        _GasFeePoller_timeout.set(this, void 0);
+        _GasFeePoller_running.set(this, false);
+        __classPrivateFieldSet(this, _GasFeePoller_gasFeeFlows, gasFeeFlows, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getChainIds, getChainIds, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getTransactions, getTransactions, "f");
+        onStateChange(() => {
+            const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+            if (unapprovedTransactions.length) {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_stop).call(this);
+            }
+        });
+    }
+}
+exports.GasFeePoller = GasFeePoller;
+_GasFeePoller_gasFeeFlows = new WeakMap(), _GasFeePoller_getChainIds = new WeakMap(), _GasFeePoller_getEthQuery = new WeakMap(), _GasFeePoller_getGasFeeControllerEstimates = new WeakMap(), _GasFeePoller_getTransactions = new WeakMap(), _GasFeePoller_timeout = new WeakMap(), _GasFeePoller_running = new WeakMap(), _GasFeePoller_instances = new WeakSet(), _GasFeePoller_start = function _GasFeePoller_start() {
+    if (__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    // Intentionally not awaiting since this starts the timeout chain.
+    // eslint-disable-next-line @typescript-eslint/no-floating-promises
+    __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this);
+    __classPrivateFieldSet(this, _GasFeePoller_running, true, "f");
+    log('Started polling');
+}, _GasFeePoller_stop = function _GasFeePoller_stop() {
+    if (!__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    clearTimeout(__classPrivateFieldGet(this, _GasFeePoller_timeout, "f"));
+    __classPrivateFieldSet(this, _GasFeePoller_timeout, undefined, "f");
+    __classPrivateFieldSet(this, _GasFeePoller_running, false, "f");
+    log('Stopped polling');
+}, _GasFeePoller_onTimeout = function _GasFeePoller_onTimeout() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateUnapprovedTransactions).call(this);
+        // eslint-disable-next-line @typescript-eslint/no-misused-promises
+        __classPrivateFieldSet(this, _GasFeePoller_timeout, setTimeout(() => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this), INTERVAL_MILLISECONDS), "f");
+    });
+}, _GasFeePoller_updateUnapprovedTransactions = function _GasFeePoller_updateUnapprovedTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+        log('Found unapproved transactions', {
+            count: unapprovedTransactions.length,
+        });
+        const ethQuery = __classPrivateFieldGet(this, _GasFeePoller_getEthQuery, "f").call(this);
+        yield Promise.all(unapprovedTransactions.map((tx) => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateTransactionSuggestedFees).call(this, tx, ethQuery)));
+    });
+}, _GasFeePoller_updateTransactionSuggestedFees = function _GasFeePoller_updateTransactionSuggestedFees(transactionMeta, ethQuery) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(transactionMeta, __classPrivateFieldGet(this, _GasFeePoller_gasFeeFlows, "f"));
+        if (!gasFeeFlow) {
+            log('Skipping update as no gas fee flow found', transactionMeta.id);
+            return;
+        }
+        log('Found gas fee flow', gasFeeFlow.constructor.name, transactionMeta.id);
+        const request = {
+            ethQuery,
+            getGasFeeControllerEstimates: __classPrivateFieldGet(this, _GasFeePoller_getGasFeeControllerEstimates, "f"),
+            transactionMeta,
+        };
+        try {
+            const response = yield gasFeeFlow.getGasFees(request);
+            transactionMeta.gasFeeEstimates = response.estimates;
+        }
+        catch (error) {
+            log('Failed to get suggested gas fees', transactionMeta.id, error);
+            return;
+        }
+        this.hub.emit('transaction-updated', transactionMeta, 'GasFeePoller - Suggested gas fees updated');
+        log('Updated suggested gas fees', {
+            gasFeeEstimates: transactionMeta.gasFeeEstimates,
+            transaction: transactionMeta.id,
+        });
+    });
+}, _GasFeePoller_getUnapprovedTransactions = function _GasFeePoller_getUnapprovedTransactions() {
+    const chainIds = __classPrivateFieldGet(this, _GasFeePoller_getChainIds, "f").call(this);
+    return __classPrivateFieldGet(this, _GasFeePoller_getTransactions, "f").call(this).filter((tx) => chainIds.includes(tx.chainId) &&
+        tx.status === types_1.TransactionStatus.unapproved);
+};
+//# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 365c05b9c144b70bd2d52b568fb377e32d427c36..6d820055872191629c360a580b36e02b4c788533 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -3,4 +3,5 @@ export type { EtherscanTransactionMeta } from './utils/etherscan';
 export { isEIP1559Transaction } from './utils/utils';
 export * from './types';
 export { determineTransactionType } from './utils/transaction-type';
+export { mergeGasFeeControllerAndTransactionGasFeeEstimates } from './utils/gas-flow';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index ab09b74aed5d901cb106652da553935a35ac1b47..c4cfa43d5b94d05913a8dfe597427d1b3d734858 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -14,11 +14,13 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
+exports.mergeGasFeeControllerAndTransactionGasFeeEstimates = exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils/utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
 __exportStar(require("./types"), exports);
 var transaction_type_1 = require("./utils/transaction-type");
 Object.defineProperty(exports, "determineTransactionType", { enumerable: true, get: function () { return transaction_type_1.determineTransactionType; } });
+var gas_flow_1 = require("./utils/gas-flow");
+Object.defineProperty(exports, "mergeGasFeeControllerAndTransactionGasFeeEstimates", { enumerable: true, get: function () { return gas_flow_1.mergeGasFeeControllerAndTransactionGasFeeEstimates; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types.d.ts b/dist/types.d.ts
index d80d057d48112d9047fc6fe419c132c44a53c509..4480aa9e1ab31f87f37a9b5e2b850a1075dd4e6d 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -1,4 +1,6 @@
 import type { AccessList } from '@ethereumjs/tx';
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
 import type { Hex } from '@metamask/utils';
 import type { Operation } from 'fast-json-patch';
 export declare type Events = {
@@ -285,6 +287,8 @@ declare type TransactionMetaBase = {
      * The time the transaction was submitted to the network, in Unix epoch time (ms).
      */
     submittedTime?: number;
+    /** Alternate EIP-1559 gas fee estimates for multiple priority levels. */
+    gasFeeEstimates?: GasFeeEstimates;
     /**
      * The symbol of the token being swapped.
      */
@@ -799,5 +803,50 @@ export declare type SecurityAlertResponse = {
     result_type: string;
     providerRequestsCount?: Record<string, number>;
 };
+/** Gas fee estimates for a specific priority level. */
+export declare type GasFeeEstimatesLevel = {
+    /** Maximum amount to pay per gas. */
+    maxFeePerGas: Hex;
+    /** Maximum amount per gas to give to the validator as an incentive. */
+    maxPriorityFeePerGas: Hex;
+};
+/** Gas fee estimates for a transaction. */
+export declare type GasFeeEstimates = {
+    /** The gas fee estimate for a low priority transaction. */
+    low: GasFeeEstimatesLevel;
+    /** The gas fee estimate for a medium priority transaction. */
+    medium: GasFeeEstimatesLevel;
+    /** The gas fee estimate for a high priority transaction. */
+    high: GasFeeEstimatesLevel;
+};
+/** Request to a gas fee flow to obtain gas fee estimates. */
+export declare type GasFeeFlowRequest = {
+    /** An EthQuery instance to enable queries to the associated RPC provider. */
+    ethQuery: EthQuery;
+    /** Callback to get the GasFeeController estimates. */
+    getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+    /** The metadata of the transaction to obtain estimates for. */
+    transactionMeta: TransactionMeta;
+};
+/** Response from a gas fee flow containing gas fee estimates. */
+export declare type GasFeeFlowResponse = {
+    /** The gas fee estimates for the transaction. */
+    estimates: GasFeeEstimates;
+};
+/** A method of obtaining gas fee estimates for a specific transaction. */
+export declare type GasFeeFlow = {
+    /**
+     * Determine if the gas fee flow supports the specified transaction.
+     * @param transactionMeta - The transaction metadata.
+     * @returns Whether the gas fee flow supports the transaction.
+     */
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    /**
+     * Get gas fee estimates for a specific transaction.
+     * @param request - The gas fee flow request.
+     * @returns The gas fee flow response containing the gas fee estimates.
+     */
+    getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.d.ts b/dist/utils/gas-fees.d.ts
index 9ed9fddd65c4f6504aa018c793d6a4915873b4bc..ef16e4846f259fc7bf1de6d2bd08278be06e1156 100644
--- a/dist/utils/gas-fees.d.ts
+++ b/dist/utils/gas-fees.d.ts
@@ -1,31 +1,24 @@
 import type EthQuery from '@metamask/eth-query';
 import type { GasFeeState } from '@metamask/gas-fee-controller';
-import type { SavedGasFees, TransactionParams, TransactionMeta } from '../types';
+import type { SavedGasFees, TransactionParams, TransactionMeta, GasFeeFlow } from '../types';
 export declare type UpdateGasFeesRequest = {
     eip1559: boolean;
     ethQuery: EthQuery;
+    gasFeeFlows: GasFeeFlow[];
     getSavedGasFees: () => SavedGasFees | undefined;
     getGasFeeEstimates: () => Promise<GasFeeState>;
     txMeta: TransactionMeta;
 };
 export declare type GetGasFeeRequest = UpdateGasFeesRequest & {
-    savedGasFees?: SavedGasFees;
     initialParams: TransactionParams;
-    suggestedGasFees: Awaited<ReturnType<typeof getSuggestedGasFees>>;
+    savedGasFees?: SavedGasFees;
+    suggestedGasFees: SuggestedGasFees;
+};
+declare type SuggestedGasFees = {
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    gasPrice?: string;
 };
 export declare function updateGasFees(request: UpdateGasFeesRequest): Promise<void>;
-declare function getSuggestedGasFees(request: UpdateGasFeesRequest): Promise<{
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-    gasPrice?: undefined;
-} | {
-    maxFeePerGas: `0x${string}`;
-    maxPriorityFeePerGas: `0x${string}`;
-    gasPrice?: undefined;
-} | {
-    gasPrice: string | undefined;
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-}>;
 export {};
 //# sourceMappingURL=gas-fees.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index 823fa99ce6763695231177916fd41a20b1c31fdb..16296d2e012c33eb20cd5b172b5ac91bb246785e 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -12,11 +12,11 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.updateGasFees = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
-const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
 const utils_1 = require("@metamask/utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const logger_1 = require("../logger");
 const types_1 = require("../types");
+const gas_flow_1 = require("./gas-flow");
 const swaps_1 = require("./swaps");
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fees');
 function updateGasFees(request) {
@@ -27,8 +27,8 @@ function updateGasFees(request) {
         const savedGasFees = isSwap ? undefined : request.getSavedGasFees();
         const suggestedGasFees = yield getSuggestedGasFees(request);
         log('Suggested gas fees', suggestedGasFees);
-        const getGasFeeRequest = Object.assign(Object.assign({}, request), { savedGasFees,
-            initialParams,
+        const getGasFeeRequest = Object.assign(Object.assign({}, request), { initialParams,
+            savedGasFees,
             suggestedGasFees });
         txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
         txMeta.txParams.maxPriorityFeePerGas =
@@ -118,6 +118,10 @@ function getGasPrice(request) {
         log('Using gasPrice from request', initialParams.gasPrice);
         return initialParams.gasPrice;
     }
+    if (suggestedGasFees.maxFeePerGas) {
+        log('Using suggested maxFeePerGas', suggestedGasFees.maxFeePerGas);
+        return suggestedGasFees.maxFeePerGas;
+    }
     if (suggestedGasFees.gasPrice) {
         log('Using suggested gasPrice', suggestedGasFees.gasPrice);
         return suggestedGasFees.gasPrice;
@@ -163,38 +167,21 @@ function updateDefaultGasEstimates(txMeta) {
 }
 function getSuggestedGasFees(request) {
     return __awaiter(this, void 0, void 0, function* () {
-        const { eip1559, ethQuery, getGasFeeEstimates, txMeta } = request;
+        const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
         if ((!eip1559 && txMeta.txParams.gasPrice) ||
             (eip1559 &&
                 txMeta.txParams.maxFeePerGas &&
                 txMeta.txParams.maxPriorityFeePerGas)) {
             return {};
         }
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(txMeta, gasFeeFlows);
         try {
-            const { gasFeeEstimates, gasEstimateType } = yield getGasFeeEstimates();
-            if (eip1559 && gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
-                const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {}, } = gasFeeEstimates;
-                if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
-                    return {
-                        maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),
-                        maxPriorityFeePerGas: gweiDecimalToWeiHex(suggestedMaxPriorityFeePerGas),
-                    };
-                }
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
-                // The LEGACY type includes low, medium and high estimates of
-                // gas price values.
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.medium),
-                };
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
-                // The ETH_GASPRICE type just includes a single gas price property,
-                // which we can assume was retrieved from eth_gasPrice
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),
-                };
-            }
+            const response = yield gasFeeFlow.getGasFees({
+                ethQuery,
+                getGasFeeControllerEstimates: getGasFeeEstimates,
+                transactionMeta: txMeta,
+            });
+            return response.estimates.medium;
         }
         catch (error) {
             log('Failed to get suggested gas fees', error);
diff --git a/dist/utils/gas-flow.d.ts b/dist/utils/gas-flow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0327c3b0329dc48068074f609c51a22f51c50883
--- /dev/null
+++ b/dist/utils/gas-flow.d.ts
@@ -0,0 +1,19 @@
+import { type GasFeeState } from '@metamask/gas-fee-controller';
+import type { GasFeeEstimates as TransactionGasFeeEstimates, GasFeeFlow, TransactionMeta } from '../types';
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+export declare function getGasFeeFlow(transactionMeta: TransactionMeta, gasFeeFlows: GasFeeFlow[]): GasFeeFlow | undefined;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param gasFeeControllerEstimateType - The gas fee estimate type from the gas fee controller.
+ * @param gasFeeControllerEstimates - The gas fee estimates from the GasFeeController.
+ * @param transactionGasFeeEstimates - The gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+export declare function mergeGasFeeControllerAndTransactionGasFeeEstimates(gasFeeControllerEstimateType: GasFeeState['gasEstimateType'], gasFeeControllerEstimates: GasFeeState['gasFeeEstimates'], transactionGasFeeEstimates: TransactionGasFeeEstimates): GasFeeState['gasFeeEstimates'];
+//# sourceMappingURL=gas-flow.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.js b/dist/utils/gas-flow.js
new file mode 100644
index 0000000000000000000000000000000000000000..a22f3b76647186ac1f96448ba6a18033ee82c521
--- /dev/null
+++ b/dist/utils/gas-flow.js
@@ -0,0 +1,56 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.mergeGasFeeControllerAndTransactionGasFeeEstimates = exports.getGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+    return gasFeeFlows.find((gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta));
+}
+exports.getGasFeeFlow = getGasFeeFlow;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param gasFeeControllerEstimateType - The gas fee estimate type from the gas fee controller.
+ * @param gasFeeControllerEstimates - The gas fee estimates from the GasFeeController.
+ * @param transactionGasFeeEstimates - The gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+function mergeGasFeeControllerAndTransactionGasFeeEstimates(gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates) {
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        const gasFeeControllerFeeMarketEstimates = gasFeeControllerEstimates;
+        return Object.assign(Object.assign({}, gasFeeControllerFeeMarketEstimates), { low: mergeFeeMarketEstimate(gasFeeControllerFeeMarketEstimates.low, transactionGasFeeEstimates.low), medium: mergeFeeMarketEstimate(gasFeeControllerFeeMarketEstimates.medium, transactionGasFeeEstimates.medium), high: mergeFeeMarketEstimate(gasFeeControllerFeeMarketEstimates.high, transactionGasFeeEstimates.high) });
+    }
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+        return {
+            low: getLegacyEstimate(transactionGasFeeEstimates.low),
+            medium: getLegacyEstimate(transactionGasFeeEstimates.medium),
+            high: getLegacyEstimate(transactionGasFeeEstimates.high),
+        };
+    }
+    return gasFeeControllerEstimates;
+}
+exports.mergeGasFeeControllerAndTransactionGasFeeEstimates = mergeGasFeeControllerAndTransactionGasFeeEstimates;
+/**
+ * Merge a specific priority level of EIP-1559 gas fee estimates.
+ * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The merged gas fee estimate.
+ */
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+    return Object.assign(Object.assign({}, gasFeeControllerEstimate), { suggestedMaxFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas), suggestedMaxPriorityFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxPriorityFeePerGas) });
+}
+/**
+ * Generate a specific priority level for a legacy gas fee estimate.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The legacy gas fee estimate.
+ */
+function getLegacyEstimate(transactionGasFeeEstimate) {
+    return (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas);
+}
+//# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
