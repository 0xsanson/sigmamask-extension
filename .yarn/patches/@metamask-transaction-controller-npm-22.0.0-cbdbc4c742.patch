diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 731d0f5a9b077f7969c728bd30ce08e70052322c..f967d914bd19905b3f5ef3fa944305ffa3a591be 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -36,6 +36,7 @@ const gas_1 = require("./utils/gas");
 const gas_fees_1 = require("./utils/gas-fees");
 const history_1 = require("./utils/history");
 const nonce_1 = require("./utils/nonce");
+const simulation_1 = require("./utils/simulation");
 const swaps_1 = require("./utils/swaps");
 const transaction_type_1 = require("./utils/transaction-type");
 const utils_1 = require("./utils/utils");
@@ -292,6 +293,14 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 type: transactionType,
             };
             yield this.updateGasProperties(transactionMeta);
+            transactionMeta.simulationData = yield (0, simulation_1.getSimulationData)({
+                chainId,
+                from: txParams.from,
+                to: txParams.to,
+                value: txParams.value,
+                data: txParams.data,
+            });
+            (0, logger_1.projectLogger)('Retrieved simulation data', transactionMeta.simulationData);
             // Checks if a transaction already exists with a given actionId
             if (!existingTransactionMeta) {
                 // Set security provider response
diff --git a/dist/types.d.ts b/dist/types.d.ts
index d80d057d48112d9047fc6fe419c132c44a53c509..063d3b865c34125f5afd1a18ad3c33e00efbb63c 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -270,6 +270,7 @@ declare type TransactionMetaBase = {
      * This is purely attached to state logs for troubleshooting and support.
      */
     sendFlowHistory?: SendFlowHistoryEntry[];
+    simulationData?: SimulationData;
     /**
      * If the gas estimation fails, an object containing error and block information.
      */
@@ -799,5 +800,26 @@ export declare type SecurityAlertResponse = {
     result_type: string;
     providerRequestsCount?: Record<string, number>;
 };
+export declare type SimulationBalanceChange = {
+    previousBalance: Hex;
+    newBalance: Hex;
+    difference: Hex;
+    isDecrease: boolean;
+};
+export declare enum SimulationTokenStandard {
+    erc20 = "erc20",
+    erc721 = "erc721",
+    erc1155 = "erc1155"
+}
+export declare type SimulationToken = {
+    address: Hex;
+    standard: SimulationTokenStandard;
+    id?: Hex;
+};
+export declare type SimulationTokenBalanceChange = SimulationToken & SimulationBalanceChange;
+export declare type SimulationData = {
+    nativeBalanceChange?: SimulationBalanceChange;
+    tokenBalanceChanges: SimulationTokenBalanceChange[];
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/types.js b/dist/types.js
index 639f911e10b4c9092ad7a77f5dcba2c3a0c2f783..f825f2ea0b0a650dbf36617fc654bfe2aacc001a 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.SimulationTokenStandard = exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
  * in the wallet. Some of these correspond with the state of the transaction on the network, but
@@ -161,4 +161,10 @@ var UserFeeLevel;
     UserFeeLevel["DAPP_SUGGESTED"] = "dappSuggested";
     UserFeeLevel["MEDIUM"] = "medium";
 })(UserFeeLevel = exports.UserFeeLevel || (exports.UserFeeLevel = {}));
+var SimulationTokenStandard;
+(function (SimulationTokenStandard) {
+    SimulationTokenStandard["erc20"] = "erc20";
+    SimulationTokenStandard["erc721"] = "erc721";
+    SimulationTokenStandard["erc1155"] = "erc1155";
+})(SimulationTokenStandard = exports.SimulationTokenStandard || (exports.SimulationTokenStandard = {}));
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.d.ts b/dist/utils/simulation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6c6299770b9feebe3be7aedf1f36459f4dce11fb
--- /dev/null
+++ b/dist/utils/simulation.d.ts
@@ -0,0 +1,11 @@
+import { type Hex } from '@metamask/utils';
+import type { SimulationData } from '../types';
+export declare type GetSimulationDataRequest = {
+    chainId: Hex;
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+export declare function getSimulationData(request: GetSimulationDataRequest): Promise<SimulationData | undefined>;
+//# sourceMappingURL=simulation.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
new file mode 100644
index 0000000000000000000000000000000000000000..9f24e33bf55823232f01c3009d3961c42da0c95c
--- /dev/null
+++ b/dist/utils/simulation.js
@@ -0,0 +1,220 @@
+"use strict";
+/* eslint-disable @typescript-eslint/no-explicit-any */
+/* eslint-disable jsdoc/require-jsdoc */
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getSimulationData = void 0;
+const abi_1 = require("@ethersproject/abi");
+const providers_1 = require("@ethersproject/providers");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation');
+const RPC_METHOD = 'infura_simulateTransactions';
+const URLS_BY_CHAIN_ID = {
+    '0x1': 'https://tx-sentinel-ethereum-mainnet.api.cx.metamask.io/',
+    '0x5': 'https://tx-sentinel-ethereum-goerli.api.cx.metamask.io/',
+};
+function getSimulationData(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, from, to, value, data } = request;
+        log('Getting simulation data', request);
+        try {
+            const response = yield simulateTransactions(chainId, {
+                transactions: [{ from, to, value, data }],
+                withCallTrace: true,
+                withLogs: true,
+            });
+            log('Simulation response', response);
+            const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+            const events = getEvents(response);
+            log('Parsed events', events);
+            const tokenBalanceChanges = yield getTokenBalanceChanges(request, events);
+            return {
+                nativeBalanceChange,
+                tokenBalanceChanges,
+            };
+        }
+        catch (error) {
+            log('Failed to get simulation data', error, request);
+            return undefined;
+        }
+    });
+}
+exports.getSimulationData = getSimulationData;
+function getNativeBalanceChange(userAddress, response) {
+    var _a;
+    const { stateDiff } = (_a = response.transactions[0]) !== null && _a !== void 0 ? _a : { pre: {}, post: {} };
+    const previousBalance = stateDiff.pre[userAddress].balance;
+    const newBalance = stateDiff.post[userAddress].balance;
+    if (!previousBalance || !newBalance) {
+        return undefined;
+    }
+    const differenceBN = (0, controller_utils_1.hexToBN)(newBalance).sub((0, controller_utils_1.hexToBN)(previousBalance));
+    const isDecrease = differenceBN.isNeg();
+    const difference = (0, controller_utils_1.toHex)(differenceBN.abs());
+    return {
+        previousBalance,
+        newBalance,
+        difference,
+        isDecrease,
+    };
+}
+function getEvents(response) {
+    var _a;
+    const logs = getLogs((_a = response.transactions[0]) === null || _a === void 0 ? void 0 : _a.callTrace);
+    log('Extracted logs', logs);
+    const erc20Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+    const erc721Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC721);
+    const erc1155Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC1155);
+    return logs
+        .map((currentLog) => {
+        var _a;
+        const event = parseLog(currentLog, erc20Interface, erc721Interface, erc1155Interface);
+        if (!event) {
+            log('Failed to parse log', currentLog);
+            return undefined;
+        }
+        const inputs = (_a = event.abi.find((e) => e.name === event.name)) === null || _a === void 0 ? void 0 : _a.inputs;
+        if (!inputs) {
+            log('Failed to find inputs for event', event);
+            return undefined;
+        }
+        const args = event.args.reduce((argsResult, arg, index) => (Object.assign(Object.assign({}, argsResult), { [inputs[index].name.replace('_', '')]: (arg.toHexString
+                ? arg.toHexString()
+                : arg).toLowerCase() })), {});
+        return {
+            contractAddress: currentLog.address,
+            tokenStandard: event.standard,
+            name: event.name,
+            data: args,
+            abi: event.abi,
+        };
+    })
+        .filter((e) => e !== undefined);
+}
+function getTokenBalanceChanges(request, events) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const balanceTransactionsByToken = getBalanceTransactions(request, events);
+        const balanceTransactions = [...balanceTransactionsByToken.values()];
+        log('Generated balance transactions', balanceTransactions);
+        if (!balanceTransactions.length) {
+            return [];
+        }
+        const response = yield simulateTransactions(request.chainId, {
+            transactions: [...balanceTransactions, request, ...balanceTransactions],
+        });
+        log('Balance simulation response', response);
+        return [...balanceTransactionsByToken.keys()].map((token, index) => {
+            var _a, _b;
+            const previousBalance = (_a = response.transactions[index]) === null || _a === void 0 ? void 0 : _a.return;
+            const newBalance = (_b = response.transactions[index + balanceTransactions.length + 1]) === null || _b === void 0 ? void 0 : _b.return;
+            const differenceBN = (0, controller_utils_1.hexToBN)(newBalance).sub((0, controller_utils_1.hexToBN)(previousBalance));
+            const difference = (0, controller_utils_1.toHex)(differenceBN);
+            const isDecrease = differenceBN.isNeg();
+            return Object.assign(Object.assign({}, token), { previousBalance,
+                newBalance,
+                difference,
+                isDecrease });
+        });
+    });
+}
+function getBalanceTransactions(request, events) {
+    return events.reduce((result, event) => {
+        if (!['Transfer', 'TransferSingle', 'TransferBatch'].includes(event.name) ||
+            ![event.data.from, event.data.to].includes(request.from)) {
+            log('Ignoring event', event);
+            return result;
+        }
+        let tokenIds = [undefined];
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc721) {
+            tokenIds = [event.data.tokenId];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferSingle') {
+            tokenIds = [event.data.id];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferBatch') {
+            tokenIds = event.data.ids;
+        }
+        log('Extracted token ids', tokenIds);
+        for (const tokenId of tokenIds) {
+            const simulationToken = {
+                address: event.contractAddress,
+                standard: event.tokenStandard,
+                id: tokenId,
+            };
+            const parameters = [request.from];
+            if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155) {
+                parameters.push(tokenId);
+            }
+            result.set(simulationToken, {
+                from: request.from,
+                to: event.contractAddress,
+                data: new abi_1.Interface(event.abi).encodeFunctionData('balanceOf', parameters),
+            });
+        }
+        return result;
+    }, new Map());
+}
+function parseLog(eventLog, erc20, erc721, erc1155) {
+    const abisByStandard = [
+        {
+            abi: metamask_eth_abis_1.abiERC20,
+            contractInterface: erc20,
+            standard: types_1.SimulationTokenStandard.erc20,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC721,
+            contractInterface: erc721,
+            standard: types_1.SimulationTokenStandard.erc721,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC1155,
+            contractInterface: erc1155,
+            standard: types_1.SimulationTokenStandard.erc1155,
+        },
+    ];
+    for (const { abi, contractInterface, standard } of abisByStandard) {
+        try {
+            return Object.assign(Object.assign({}, contractInterface.parseLog(eventLog)), { abi,
+                standard });
+        }
+        catch (e) {
+            // Intentionally empty
+        }
+    }
+    return undefined;
+}
+function getLogs(call) {
+    var _a, _b;
+    const logs = (_a = call.logs) !== null && _a !== void 0 ? _a : [];
+    const nestedCalls = (_b = call.calls) !== null && _b !== void 0 ? _b : [];
+    return [
+        ...logs,
+        ...nestedCalls.map((nestedCall) => getLogs(nestedCall)).flat(),
+    ];
+}
+function simulateTransactions(chainId, request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const url = URLS_BY_CHAIN_ID[chainId];
+        if (!url) {
+            throw new Error(`Chain does not support simulations: ${chainId}`);
+        }
+        const jsonRpc = new providers_1.JsonRpcProvider(url);
+        const response = yield jsonRpc.send(RPC_METHOD, [request]);
+        return response;
+    });
+}
+//# sourceMappingURL=simulation.js.map
\ No newline at end of file
