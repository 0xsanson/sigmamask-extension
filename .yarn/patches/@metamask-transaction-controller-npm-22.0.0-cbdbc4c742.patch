diff --git a/dist/TransactionController.d.ts b/dist/TransactionController.d.ts
index 8a2025ef1e2b230d81bb28cac227f7bbb9db2c90..24ee94eead19450109b26f11dd6e8c76a0fecfc3 100644
--- a/dist/TransactionController.d.ts
+++ b/dist/TransactionController.d.ts
@@ -5,15 +5,18 @@ import type { AddApprovalRequest } from '@metamask/approval-controller';
 import type { BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
 import { BaseControllerV1 } from '@metamask/base-controller';
 import type { GasFeeState } from '@metamask/gas-fee-controller';
-import type { BlockTracker, NetworkState, Provider } from '@metamask/network-controller';
+import type { BlockTracker, NetworkClientId, NetworkController, NetworkControllerStateChangeEvent, NetworkState, Provider, NetworkControllerFindNetworkClientIdByChainIdAction, NetworkControllerGetNetworkClientByIdAction } from '@metamask/network-controller';
 import type { Hex } from '@metamask/utils';
 import { EventEmitter } from 'events';
 import type { NonceLock, Transaction as NonceTrackerTransaction } from 'nonce-tracker';
+import type { IncomingTransactionOptions } from './helpers/IncomingTransactionHelper';
 import type { Events, SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse } from './types';
 import { TransactionType, TransactionStatus } from './types';
 export declare const HARDFORK = Hardfork.London;
 /**
- * @type Result
+ * Object with new transaction's meta and a promise resolving to the
+ * transaction hash if successful.
+ *
  * @property result - Promise resolving to a new transaction hash
  * @property transactionMeta - Meta information about this new transaction
  */
@@ -29,9 +32,8 @@ export interface FeeMarketEIP1559Values {
     maxPriorityFeePerGas: string;
 }
 /**
- * @type TransactionConfig
- *
  * Transaction controller configuration
+ *
  * @property provider - Provider used to create a new underlying EthQuery instance
  * @property sign - Method used to sign transactions
  */
@@ -40,9 +42,8 @@ export interface TransactionConfig extends BaseConfig {
     txHistoryLimit: number;
 }
 /**
- * @type MethodData
- *
  * Method data registry object
+ *
  * @property registryMethod - Registry method raw string
  * @property parsedRegistryMethod - Registry method object, containing name and method arguments
  */
@@ -51,9 +52,8 @@ export interface MethodData {
     parsedRegistryMethod: Record<string, unknown>;
 }
 /**
- * @type TransactionState
- *
  * Transaction controller state
+ *
  * @property transactions - A list of TransactionMeta objects
  * @property methodData - Object containing all known method data information
  */
@@ -74,6 +74,79 @@ export declare const CANCEL_RATE = 1.1;
  * Multiplier used to determine a transaction's increased gas fee during speed up
  */
 export declare const SPEED_UP_RATE = 1.1;
+/**
+ * Configuration options for the PendingTransactionTracker
+ *
+ * @property isResubmitEnabled - Whether transaction publishing is automatically retried.
+ */
+export declare type PendingTransactionOptions = {
+    isResubmitEnabled?: boolean;
+};
+/**
+ * TransactionController constructor options.
+ *
+ * @property blockTracker - The block tracker used to poll for new blocks data.
+ * @property disableHistory - Whether to disable storing history in transaction metadata.
+ * @property disableSendFlowHistory - Explicitly disable transaction metadata history.
+ * @property disableSwaps - Whether to disable additional processing on swaps transactions.
+ * @property isMultichainEnabled - Enable multichain support.
+ * @property getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
+ * @property getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
+ * @property getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+ * @property getGasFeeEstimates - Callback to retrieve gas fee estimates.
+ * @property getNetworkClientRegistry - Gets the network client registry.
+ * @property getNetworkState - Gets the state of the network controller.
+ * @property getPermittedAccounts - Get accounts that a given origin has permissions for.
+ * @property getSavedGasFees - Gets the saved gas fee config.
+ * @property getSelectedAddress - Gets the address of the currently selected account.
+ * @property incomingTransactions - Configuration options for incoming transaction support.
+ * @property isSimulationEnabled - Whether new transactions will be automatically simulated.
+ * @property messenger - The controller messenger.
+ * @property onNetworkStateChange - Allows subscribing to network controller state changes.
+ * @property pendingTransactions - Configuration options for pending transaction support.
+ * @property provider - The provider used to create the underlying EthQuery instance.
+ * @property securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
+ * @property hooks - The controller hooks.
+ * @property hooks.afterSign - Additional logic to execute after signing a transaction. Return false to not change the status to signed.
+ * @property hooks.beforeApproveOnInit - Additional logic to execute before starting an approval flow for a transaction during initialization. Return false to skip the transaction.
+ * @property hooks.beforeCheckPendingTransaction - Additional logic to execute before checking pending transactions. Return false to prevent the broadcast of the transaction.
+ * @property hooks.beforePublish - Additional logic to execute before publishing a transaction. Return false to prevent the broadcast of the transaction.
+ * @property hooks.getAdditionalSignArguments - Returns additional arguments required to sign a transaction.
+ * @property hooks.publish - Alternate logic to publish a transaction.
+ */
+export declare type TransactionControllerOptions = {
+    blockTracker: BlockTracker;
+    disableHistory: boolean;
+    disableSendFlowHistory: boolean;
+    disableSwaps: boolean;
+    getCurrentAccountEIP1559Compatibility?: () => Promise<boolean>;
+    getCurrentNetworkEIP1559Compatibility: () => Promise<boolean>;
+    getExternalPendingTransactions?: (address: string, chainId?: string) => NonceTrackerTransaction[];
+    getGasFeeEstimates?: () => Promise<GasFeeState>;
+    getNetworkState: () => NetworkState;
+    getPermittedAccounts: (origin?: string) => Promise<string[]>;
+    getSavedGasFees?: (chainId: Hex) => SavedGasFees | undefined;
+    getSelectedAddress: () => string;
+    incomingTransactions?: IncomingTransactionOptions;
+    isSimulationEnabled?: () => boolean;
+    messenger: TransactionControllerMessenger;
+    onNetworkStateChange: (listener: (state: NetworkState) => void) => void;
+    pendingTransactions?: PendingTransactionOptions;
+    provider: Provider;
+    securityProviderRequest?: SecurityProviderRequest;
+    getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];
+    isMultichainEnabled: boolean;
+    hooks: {
+        afterSign?: (transactionMeta: TransactionMeta, signedTx: TypedTransaction) => boolean;
+        beforeApproveOnInit?: (transactionMeta: TransactionMeta) => boolean;
+        beforeCheckPendingTransaction?: (transactionMeta: TransactionMeta) => boolean;
+        beforePublish?: (transactionMeta: TransactionMeta) => boolean;
+        getAdditionalSignArguments?: (transactionMeta: TransactionMeta) => (TransactionMeta | undefined)[];
+        publish?: (transactionMeta: TransactionMeta) => Promise<{
+            transactionHash: string;
+        }>;
+    };
+};
 /**
  * The name of the {@link TransactionController}.
  */
@@ -81,11 +154,12 @@ declare const controllerName = "TransactionController";
 /**
  * The external actions available to the {@link TransactionController}.
  */
-declare type AllowedActions = AddApprovalRequest;
+declare type AllowedActions = AddApprovalRequest | NetworkControllerFindNetworkClientIdByChainIdAction | NetworkControllerGetNetworkClientByIdAction;
+declare type AllowedEvents = NetworkControllerStateChangeEvent;
 /**
  * The messenger of the {@link TransactionController}.
  */
-export declare type TransactionControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, never, AllowedActions['type'], never>;
+export declare type TransactionControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
 export interface TransactionControllerEventEmitter extends EventEmitter {
     on<T extends keyof Events>(eventName: T, listener: (...args: Events[T]) => void): this;
     emit<T extends keyof Events>(eventName: T, ...args: Events[T]): boolean;
@@ -94,15 +168,15 @@ export interface TransactionControllerEventEmitter extends EventEmitter {
  * Controller responsible for submitting and managing transactions.
  */
 export declare class TransactionController extends BaseControllerV1<TransactionConfig, TransactionState> {
-    private readonly ethQuery;
+    #private;
     private readonly isHistoryDisabled;
     private readonly isSwapsDisabled;
     private readonly isSendFlowHistoryDisabled;
     private readonly inProcessOfSigning;
     private readonly nonceTracker;
     private readonly registry;
-    private readonly provider;
     private readonly mutex;
+    private readonly gasFeeFlows;
     private readonly getSavedGasFees;
     private readonly getNetworkState;
     private readonly getCurrentAccountEIP1559Compatibility;
@@ -116,6 +190,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly securityProviderRequest?;
     private readonly pendingTransactionTracker;
     private readonly signAbortCallbacks;
+    private readonly isSimulationEnabled;
     private readonly afterSign;
     private readonly beforeApproveOnInit;
     private readonly beforeCheckPendingTransaction;
@@ -136,80 +211,11 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * Method used to sign transactions
      */
     sign?: (transaction: TypedTransaction, from: string, transactionMeta?: TransactionMeta) => Promise<TypedTransaction>;
+    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions, isSimulationEnabled, messenger, onNetworkStateChange, pendingTransactions, provider, securityProviderRequest, getNetworkClientRegistry, isMultichainEnabled, hooks, }: TransactionControllerOptions, config?: Partial<TransactionConfig>, state?: Partial<TransactionState>);
     /**
-     * Creates a TransactionController instance.
-     *
-     * @param options - The controller options.
-     * @param options.blockTracker - The block tracker used to poll for new blocks data.
-     * @param options.disableHistory - Whether to disable storing history in transaction metadata.
-     * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.
-     * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.
-     * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
-     * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
-     * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
-     * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
-     * @param options.getNetworkState - Gets the state of the network controller.
-     * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.
-     * @param options.getSavedGasFees - Gets the saved gas fee config.
-     * @param options.getSelectedAddress - Gets the address of the currently selected account.
-     * @param options.incomingTransactions - Configuration options for incoming transaction support.
-     * @param options.incomingTransactions.includeTokenTransfers - Whether or not to include ERC20 token transfers.
-     * @param options.incomingTransactions.isEnabled - Whether or not incoming transaction retrieval is enabled.
-     * @param options.incomingTransactions.queryEntireHistory - Whether to initially query the entire transaction history or only recent blocks.
-     * @param options.incomingTransactions.updateTransactions - Whether to update local transactions using remote transaction data.
-     * @param options.messenger - The controller messenger.
-     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
-     * @param options.pendingTransactions - Configuration options for pending transaction support.
-     * @param options.pendingTransactions.isResubmitEnabled - Whether transaction publishing is automatically retried.
-     * @param options.provider - The provider used to create the underlying EthQuery instance.
-     * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
-     * @param options.hooks - The controller hooks.
-     * @param options.hooks.afterSign - Additional logic to execute after signing a transaction. Return false to not change the status to signed.
-     * @param options.hooks.beforeApproveOnInit - Additional logic to execute before starting an approval flow for a transaction during initialization. Return false to skip the transaction.
-     * @param options.hooks.beforeCheckPendingTransaction - Additional logic to execute before checking pending transactions. Return false to prevent the broadcast of the transaction.
-     * @param options.hooks.beforePublish - Additional logic to execute before publishing a transaction. Return false to prevent the broadcast of the transaction.
-     * @param options.hooks.getAdditionalSignArguments - Returns additional arguments required to sign a transaction.
-     * @param options.hooks.publish - Alternate logic to publish a transaction.
-     * @param config - Initial options used to configure this controller.
-     * @param state - Initial state to set on this controller.
-     */
-    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions, messenger, onNetworkStateChange, pendingTransactions, provider, securityProviderRequest, hooks, }: {
-        blockTracker: BlockTracker;
-        disableHistory: boolean;
-        disableSendFlowHistory: boolean;
-        disableSwaps: boolean;
-        getCurrentAccountEIP1559Compatibility?: () => Promise<boolean>;
-        getCurrentNetworkEIP1559Compatibility: () => Promise<boolean>;
-        getExternalPendingTransactions?: (address: string) => NonceTrackerTransaction[];
-        getGasFeeEstimates?: () => Promise<GasFeeState>;
-        getNetworkState: () => NetworkState;
-        getPermittedAccounts: (origin?: string) => Promise<string[]>;
-        getSavedGasFees?: (chainId: Hex) => SavedGasFees | undefined;
-        getSelectedAddress: () => string;
-        incomingTransactions?: {
-            includeTokenTransfers?: boolean;
-            isEnabled?: () => boolean;
-            queryEntireHistory?: boolean;
-            updateTransactions?: boolean;
-        };
-        messenger: TransactionControllerMessenger;
-        onNetworkStateChange: (listener: (state: NetworkState) => void) => void;
-        pendingTransactions?: {
-            isResubmitEnabled?: boolean;
-        };
-        provider: Provider;
-        securityProviderRequest?: SecurityProviderRequest;
-        hooks: {
-            afterSign?: (transactionMeta: TransactionMeta, signedTx: TypedTransaction) => boolean;
-            beforeApproveOnInit?: (transactionMeta: TransactionMeta) => boolean;
-            beforeCheckPendingTransaction?: (transactionMeta: TransactionMeta) => boolean;
-            beforePublish?: (transactionMeta: TransactionMeta) => boolean;
-            getAdditionalSignArguments?: (transactionMeta: TransactionMeta) => (TransactionMeta | undefined)[];
-            publish?: (transactionMeta: TransactionMeta) => Promise<{
-                transactionHash: string;
-            }>;
-        };
-    }, config?: Partial<TransactionConfig>, state?: Partial<TransactionState>);
+     * Stops polling and removes listeners to prepare the controller for garbage collection.
+     */
+    destroy(): void;
     /**
      * Handle new method data request.
      *
@@ -235,9 +241,10 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * @param opts.swaps - Options for swaps transactions.
      * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.
      * @param opts.swaps.meta - Metadata for swap transaction.
+     * @param opts.networkClientId - The id of the network client for this transaction.
      * @returns Object containing a promise resolving to the transaction hash if approved.
      */
-    addTransaction(txParams: TransactionParams, { actionId, deviceConfirmedOn, method, origin, requireApproval, securityAlertResponse, sendFlowHistory, swaps, type, }?: {
+    addTransaction(txParams: TransactionParams, { actionId, deviceConfirmedOn, method, origin, requireApproval, securityAlertResponse, sendFlowHistory, swaps, type, networkClientId, }?: {
         actionId?: string;
         deviceConfirmedOn?: WalletDevice;
         method?: string;
@@ -250,10 +257,12 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
             meta?: Partial<TransactionMeta>;
         };
         type?: TransactionType;
+        networkClientId?: NetworkClientId;
     }): Promise<Result>;
-    startIncomingTransactionPolling(): void;
-    stopIncomingTransactionPolling(): void;
-    updateIncomingTransactions(): Promise<void>;
+    startIncomingTransactionPolling(networkClientIds?: NetworkClientId[]): void;
+    stopIncomingTransactionPolling(networkClientIds?: NetworkClientId[]): void;
+    stopAllIncomingTransactionPolling(): void;
+    updateIncomingTransactions(networkClientIds?: NetworkClientId[]): Promise<void>;
     /**
      * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
      * and emitting a `<tx.id>:finished` hub event.
@@ -285,9 +294,10 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * Estimates required gas for a given transaction.
      *
      * @param transaction - The transaction to estimate gas for.
+     * @param networkClientId - The network client id to use for the estimate.
      * @returns The gas and gas price.
      */
-    estimateGas(transaction: TransactionParams): Promise<{
+    estimateGas(transaction: TransactionParams, networkClientId?: NetworkClientId): Promise<{
         gas: string;
         simulationFails: {
             reason: any;
@@ -303,9 +313,10 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      *
      * @param transaction - The transaction params to estimate gas for.
      * @param multiplier - The multiplier to use for the gas buffer.
+     * @param networkClientId - The network client id to use for the estimate.
      */
-    estimateGasBuffered(transaction: TransactionParams, multiplier: number): Promise<{
-        gas: string;
+    estimateGasBuffered(transaction: TransactionParams, multiplier: number, networkClientId?: NetworkClientId): Promise<{
+        gas: `0x${string}`;
         simulationFails: {
             reason: any;
             errorKey: any;
@@ -338,8 +349,6 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * wiped on current network.
      */
     wipeTransactions(ignoreNetwork?: boolean, address?: string): void;
-    startIncomingTransactionProcessing(): void;
-    stopIncomingTransactionProcessing(): void;
     /**
      * Adds external provided transaction to state as confirmed transaction.
      *
@@ -403,14 +412,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
         maxFeePerGas?: string;
         maxPriorityFeePerGas?: string;
     }): TransactionMeta;
-    /**
-     * Gets the next nonce according to the nonce-tracker.
-     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
-     *
-     * @param address - The hex string address for the transaction.
-     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
-     */
-    getNonceLock(address: string): Promise<NonceLock>;
+    getNonceLock(address: string, networkClientId?: NetworkClientId): Promise<NonceLock>;
     /**
      * Updates the editable parameters of a transaction.
      *
@@ -440,7 +442,9 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * @param opts.hasNonce - Whether the transactions already have a nonce.
      * @returns The raw transactions.
      */
-    approveTransactionsWithSameNonce(listOfTxParams?: TransactionParams[], { hasNonce }?: {
+    approveTransactionsWithSameNonce(listOfTxParams?: (TransactionParams & {
+        chainId: Hex;
+    })[], { hasNonce }?: {
         hasNonce?: boolean;
     }): Promise<string | string[]>;
     /**
@@ -490,10 +494,9 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     abortTransactionSigning(transactionId: string): void;
     private addMetadata;
     private updateGasProperties;
-    private getCurrentChainTransactionsByStatus;
     private onBootCleanup;
     /**
-     * Force to submit approved transactions on current chain.
+     * Force submit approved transactions for all chains.
      */
     private submitApprovedTransactions;
     private processApproval;
@@ -557,6 +560,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
      * transaction type to use.
      *
+     * @param chainId - The chainId to use for the configuration.
      * @returns common configuration object
      */
     private getCommonConfiguration;
@@ -599,10 +603,8 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      */
     private updateTransactionMetaRSV;
     private getEIP1559Compatibility;
-    private addPendingTransactionTrackerListeners;
     private signTransaction;
     private onTransactionStatusChange;
-    private getNonceTrackerPendingTransactions;
     private getNonceTrackerTransactions;
     private onConfirmedTransaction;
     private updatePostBalance;
diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 731d0f5a9b077f7969c728bd30ce08e70052322c..01220b2e3c95adcf650ea3e8b6afbaaa19d008be 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -8,26 +8,44 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
+var _TransactionController_instances, _TransactionController_incomingTransactionOptions, _TransactionController_pendingTransactionOptions, _TransactionController_multichainTrackingHelper, _TransactionController_createNonceTracker, _TransactionController_createIncomingTransactionHelper, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_removeIncomingTransactionHelperListeners, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_getGasFeeFlows, _TransactionController_updateTransactionInternal, _TransactionController_simulateTransaction;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.HARDFORK = void 0;
 const common_1 = require("@ethereumjs/common");
 const tx_1 = require("@ethereumjs/tx");
+const util_1 = require("@ethereumjs/util");
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const eth_query_1 = __importDefault(require("@metamask/eth-query"));
+const network_controller_1 = require("@metamask/network-controller");
 const rpc_errors_1 = require("@metamask/rpc-errors");
+const utils_1 = require("@metamask/utils");
 const async_mutex_1 = require("async-mutex");
 const eth_method_registry_1 = require("eth-method-registry");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const events_1 = require("events");
 const lodash_1 = require("lodash");
 const nonce_tracker_1 = require("nonce-tracker");
 const uuid_1 = require("uuid");
+const DefaultGasFeeFlow_1 = require("./gas-flows/DefaultGasFeeFlow");
+const LineaGasFeeFlow_1 = require("./gas-flows/LineaGasFeeFlow");
 const EtherscanRemoteTransactionSource_1 = require("./helpers/EtherscanRemoteTransactionSource");
+const GasFeePoller_1 = require("./helpers/GasFeePoller");
 const IncomingTransactionHelper_1 = require("./helpers/IncomingTransactionHelper");
+const MultichainTrackingHelper_1 = require("./helpers/MultichainTrackingHelper");
 const PendingTransactionTracker_1 = require("./helpers/PendingTransactionTracker");
 const logger_1 = require("./logger");
 const types_1 = require("./types");
@@ -36,9 +54,10 @@ const gas_1 = require("./utils/gas");
 const gas_fees_1 = require("./utils/gas-fees");
 const history_1 = require("./utils/history");
 const nonce_1 = require("./utils/nonce");
+const simulation_1 = require("./utils/simulation");
 const swaps_1 = require("./utils/swaps");
 const transaction_type_1 = require("./utils/transaction-type");
-const utils_1 = require("./utils/utils");
+const utils_2 = require("./utils/utils");
 const validation_1 = require("./utils/validation");
 exports.HARDFORK = common_1.Hardfork.London;
 /**
@@ -57,49 +76,16 @@ const controllerName = 'TransactionController';
  * Controller responsible for submitting and managing transactions.
  */
 class TransactionController extends base_controller_1.BaseControllerV1 {
-    /**
-     * Creates a TransactionController instance.
-     *
-     * @param options - The controller options.
-     * @param options.blockTracker - The block tracker used to poll for new blocks data.
-     * @param options.disableHistory - Whether to disable storing history in transaction metadata.
-     * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.
-     * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.
-     * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
-     * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
-     * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
-     * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
-     * @param options.getNetworkState - Gets the state of the network controller.
-     * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.
-     * @param options.getSavedGasFees - Gets the saved gas fee config.
-     * @param options.getSelectedAddress - Gets the address of the currently selected account.
-     * @param options.incomingTransactions - Configuration options for incoming transaction support.
-     * @param options.incomingTransactions.includeTokenTransfers - Whether or not to include ERC20 token transfers.
-     * @param options.incomingTransactions.isEnabled - Whether or not incoming transaction retrieval is enabled.
-     * @param options.incomingTransactions.queryEntireHistory - Whether to initially query the entire transaction history or only recent blocks.
-     * @param options.incomingTransactions.updateTransactions - Whether to update local transactions using remote transaction data.
-     * @param options.messenger - The controller messenger.
-     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
-     * @param options.pendingTransactions - Configuration options for pending transaction support.
-     * @param options.pendingTransactions.isResubmitEnabled - Whether transaction publishing is automatically retried.
-     * @param options.provider - The provider used to create the underlying EthQuery instance.
-     * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
-     * @param options.hooks - The controller hooks.
-     * @param options.hooks.afterSign - Additional logic to execute after signing a transaction. Return false to not change the status to signed.
-     * @param options.hooks.beforeApproveOnInit - Additional logic to execute before starting an approval flow for a transaction during initialization. Return false to skip the transaction.
-     * @param options.hooks.beforeCheckPendingTransaction - Additional logic to execute before checking pending transactions. Return false to prevent the broadcast of the transaction.
-     * @param options.hooks.beforePublish - Additional logic to execute before publishing a transaction. Return false to prevent the broadcast of the transaction.
-     * @param options.hooks.getAdditionalSignArguments - Returns additional arguments required to sign a transaction.
-     * @param options.hooks.publish - Alternate logic to publish a transaction.
-     * @param config - Initial options used to configure this controller.
-     * @param state - Initial state to set on this controller.
-     */
-    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions = {}, messenger, onNetworkStateChange, pendingTransactions = {}, provider, securityProviderRequest, hooks = {}, }, config, state) {
+    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions = {}, isSimulationEnabled, messenger, onNetworkStateChange, pendingTransactions = {}, provider, securityProviderRequest, getNetworkClientRegistry, isMultichainEnabled = false, hooks, }, config, state) {
         var _a, _b, _c, _d, _e, _f;
         super(config, state);
+        _TransactionController_instances.add(this);
         this.inProcessOfSigning = new Set();
         this.mutex = new async_mutex_1.Mutex();
+        _TransactionController_incomingTransactionOptions.set(this, void 0);
+        _TransactionController_pendingTransactionOptions.set(this, void 0);
         this.signAbortCallbacks = new Map();
+        _TransactionController_multichainTrackingHelper.set(this, void 0);
         /**
          * EventEmitter instance used to listen to specific transactional events
          */
@@ -108,6 +94,11 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
          * Name of this controller used during composition
          */
         this.name = 'TransactionController';
+        _TransactionController_checkForPendingTransactionAndStartPolling.set(this, () => {
+            // PendingTransactionTracker reads state through its getTransactions hook
+            this.pendingTransactionTracker.startIfPendingTransactions();
+            __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").checkForPendingTransactionAndStartPolling();
+        });
         this.defaultConfig = {
             txHistoryLimit: 40,
         };
@@ -117,13 +108,12 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             lastFetchedBlockNumbers: {},
         };
         this.initialize();
-        this.provider = provider;
         this.messagingSystem = messenger;
         this.getNetworkState = getNetworkState;
-        this.ethQuery = new eth_query_1.default(provider);
         this.isSendFlowHistoryDisabled = disableSendFlowHistory !== null && disableSendFlowHistory !== void 0 ? disableSendFlowHistory : false;
         this.isHistoryDisabled = disableHistory !== null && disableHistory !== void 0 ? disableHistory : false;
         this.isSwapsDisabled = disableSwaps !== null && disableSwaps !== void 0 ? disableSwaps : false;
+        this.isSimulationEnabled = isSimulationEnabled !== null && isSimulationEnabled !== void 0 ? isSimulationEnabled : (() => true);
         // @ts-expect-error the type in eth-method-registry is inappropriate and should be changed
         this.registry = new eth_method_registry_1.MethodRegistry({ provider });
         this.getSavedGasFees = getSavedGasFees !== null && getSavedGasFees !== void 0 ? getSavedGasFees : ((_chainId) => undefined);
@@ -138,6 +128,8 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         this.getExternalPendingTransactions =
             getExternalPendingTransactions !== null && getExternalPendingTransactions !== void 0 ? getExternalPendingTransactions : (() => []);
         this.securityProviderRequest = securityProviderRequest;
+        __classPrivateFieldSet(this, _TransactionController_incomingTransactionOptions, incomingTransactions, "f");
+        __classPrivateFieldSet(this, _TransactionController_pendingTransactionOptions, pendingTransactions, "f");
         this.afterSign = (_a = hooks === null || hooks === void 0 ? void 0 : hooks.afterSign) !== null && _a !== void 0 ? _a : (() => true);
         this.beforeApproveOnInit = (_b = hooks === null || hooks === void 0 ? void 0 : hooks.beforeApproveOnInit) !== null && _b !== void 0 ? _b : (() => true);
         this.beforeCheckPendingTransaction =
@@ -149,56 +141,72 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             (_e = hooks === null || hooks === void 0 ? void 0 : hooks.getAdditionalSignArguments) !== null && _e !== void 0 ? _e : (() => []);
         this.publish =
             (_f = hooks === null || hooks === void 0 ? void 0 : hooks.publish) !== null && _f !== void 0 ? _f : (() => Promise.resolve({ transactionHash: undefined }));
-        this.nonceTracker = new nonce_tracker_1.NonceTracker({
-            // @ts-expect-error provider types misaligned: SafeEventEmitterProvider vs Record<string,string>
+        this.nonceTracker = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_createNonceTracker).call(this, {
             provider,
             blockTracker,
-            getPendingTransactions: this.getNonceTrackerPendingTransactions.bind(this),
-            getConfirmedTransactions: this.getNonceTrackerTransactions.bind(this, types_1.TransactionStatus.confirmed),
         });
-        this.incomingTransactionHelper = new IncomingTransactionHelper_1.IncomingTransactionHelper({
-            blockTracker,
-            getCurrentAccount: getSelectedAddress,
-            getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
-            getNetworkState,
-            isEnabled: incomingTransactions.isEnabled,
-            queryEntireHistory: incomingTransactions.queryEntireHistory,
-            remoteTransactionSource: new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource({
-                includeTokenTransfers: incomingTransactions.includeTokenTransfers,
+        __classPrivateFieldSet(this, _TransactionController_multichainTrackingHelper, new MultichainTrackingHelper_1.MultichainTrackingHelper({
+            isMultichainEnabled,
+            provider,
+            nonceTracker: this.nonceTracker,
+            incomingTransactionOptions: incomingTransactions,
+            findNetworkClientIdByChainId: (chainId) => {
+                return this.messagingSystem.call(`NetworkController:findNetworkClientIdByChainId`, chainId);
+            },
+            getNetworkClientById: ((networkClientId) => {
+                return this.messagingSystem.call(`NetworkController:getNetworkClientById`, networkClientId);
             }),
-            transactionLimit: this.config.txHistoryLimit,
-            updateTransactions: incomingTransactions.updateTransactions,
+            getNetworkClientRegistry,
+            removeIncomingTransactionHelperListeners: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_removeIncomingTransactionHelperListeners).bind(this),
+            removePendingTransactionTrackerListeners: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_removePendingTransactionTrackerListeners).bind(this),
+            createNonceTracker: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_createNonceTracker).bind(this),
+            createIncomingTransactionHelper: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_createIncomingTransactionHelper).bind(this),
+            createPendingTransactionTracker: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_createPendingTransactionTracker).bind(this),
+            onNetworkStateChange: (listener) => {
+                this.messagingSystem.subscribe('NetworkController:stateChange', listener);
+            },
+        }), "f");
+        __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").initialize();
+        const etherscanRemoteTransactionSource = new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource({
+            includeTokenTransfers: incomingTransactions.includeTokenTransfers,
         });
-        this.incomingTransactionHelper.hub.on('transactions', this.onIncomingTransactions.bind(this));
-        this.incomingTransactionHelper.hub.on('updatedLastFetchedBlockNumbers', this.onUpdatedLastFetchedBlockNumbers.bind(this));
-        this.pendingTransactionTracker = new PendingTransactionTracker_1.PendingTransactionTracker({
-            approveTransaction: this.approveTransaction.bind(this),
+        this.incomingTransactionHelper = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_createIncomingTransactionHelper).call(this, {
             blockTracker,
-            getChainId: this.getChainId.bind(this),
-            getEthQuery: () => this.ethQuery,
+            etherscanRemoteTransactionSource,
+        });
+        this.pendingTransactionTracker = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_createPendingTransactionTracker).call(this, {
+            provider,
+            blockTracker,
+        });
+        this.gasFeeFlows = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getGasFeeFlows).call(this);
+        const gasFeePoller = new GasFeePoller_1.GasFeePoller({
+            // Default gas fee polling is not yet supported by the clients
+            gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+            getEthQuery: (chainId, networkClientId) => __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId,
+                chainId,
+            }),
+            getGasFeeControllerEstimates: this.getGasFeeEstimates,
             getTransactions: () => this.state.transactions,
-            isResubmitEnabled: pendingTransactions.isResubmitEnabled,
-            nonceTracker: this.nonceTracker,
             onStateChange: (listener) => {
                 this.subscribe(listener);
-                onNetworkStateChange(listener);
-                listener();
-            },
-            publishTransaction: this.publishTransaction.bind(this),
-            hooks: {
-                beforeCheckPendingTransaction: this.beforeCheckPendingTransaction.bind(this),
-                beforePublish: this.beforePublish.bind(this),
             },
         });
-        this.addPendingTransactionTrackerListeners();
+        gasFeePoller.hub.on('transaction-updated', (transactionMeta) => __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_updateTransactionInternal).call(this, transactionMeta, { skipHistory: true }));
+        // when transactionsController state changes
+        // check for pending transactions and start polling if there are any
+        this.subscribe(__classPrivateFieldGet(this, _TransactionController_checkForPendingTransactionAndStartPolling, "f"));
+        // TODO once v2 is merged make sure this only runs when
+        // selectedNetworkClientId changes
         onNetworkStateChange(() => {
             (0, logger_1.projectLogger)('Detected network change', this.getChainId());
+            this.pendingTransactionTracker.startIfPendingTransactions();
             this.onBootCleanup();
         });
         this.onBootCleanup();
     }
     failTransaction(transactionMeta, error, actionId) {
-        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error: (0, utils_1.normalizeTxError)(error), status: types_1.TransactionStatus.failed });
+        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error: (0, utils_2.normalizeTxError)(error), status: types_1.TransactionStatus.failed });
         this.hub.emit('transaction-failed', {
             actionId,
             error: error.message,
@@ -215,6 +223,12 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             return { registryMethod, parsedRegistryMethod };
         });
     }
+    /**
+     * Stops polling and removes listeners to prepare the controller for garbage collection.
+     */
+    destroy() {
+        __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_stopAllTracking).call(this);
+    }
     /**
      * Handle new method data request.
      *
@@ -259,21 +273,30 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      * @param opts.swaps - Options for swaps transactions.
      * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.
      * @param opts.swaps.meta - Metadata for swap transaction.
+     * @param opts.networkClientId - The id of the network client for this transaction.
      * @returns Object containing a promise resolving to the transaction hash if approved.
      */
-    addTransaction(txParams, { actionId, deviceConfirmedOn, method, origin, requireApproval, securityAlertResponse, sendFlowHistory, swaps = {}, type, } = {}) {
+    addTransaction(txParams, { actionId, deviceConfirmedOn, method, origin, requireApproval, securityAlertResponse, sendFlowHistory, swaps = {}, type, networkClientId, } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             (0, logger_1.projectLogger)('Adding transaction', txParams);
-            txParams = (0, utils_1.normalizeTxParams)(txParams);
-            const isEIP1559Compatible = yield this.getEIP1559Compatibility();
+            txParams = (0, utils_2.normalizeTransactionParams)(txParams);
+            if (networkClientId &&
+                !__classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").has(networkClientId)) {
+                throw new Error('The networkClientId for this transaction could not be found');
+            }
+            const isEIP1559Compatible = yield this.getEIP1559Compatibility(networkClientId);
             (0, validation_1.validateTxParams)(txParams, isEIP1559Compatible);
             if (origin) {
                 yield (0, validation_1.validateTransactionOrigin)(yield this.getPermittedAccounts(origin), this.getSelectedAddress(), txParams.from, origin);
             }
             const dappSuggestedGasFees = this.generateDappSuggestedGasFees(txParams, origin);
-            const transactionType = type !== null && type !== void 0 ? type : (yield (0, transaction_type_1.determineTransactionType)(txParams, this.ethQuery)).type;
+            const chainId = this.getChainId(networkClientId);
+            const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId,
+                chainId,
+            });
+            const transactionType = type !== null && type !== void 0 ? type : (yield (0, transaction_type_1.determineTransactionType)(txParams, ethQuery)).type;
             const existingTransactionMeta = this.getTransactionWithActionId(actionId);
-            const chainId = this.getChainId();
             // If a request to add a transaction with the same actionId is submitted again, a new transaction will not be created for it.
             const transactionMeta = existingTransactionMeta || {
                 // Add actionId to txMeta to check if same actionId is seen again
@@ -290,8 +313,12 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 userEditedGasLimit: false,
                 verifiedOnBlockchain: false,
                 type: transactionType,
+                networkClientId,
             };
-            yield this.updateGasProperties(transactionMeta);
+            yield Promise.all([
+                this.updateGasProperties(transactionMeta),
+                __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_simulateTransaction).call(this, transactionMeta),
+            ]);
             // Checks if a transaction already exists with a given actionId
             if (!existingTransactionMeta) {
                 // Set security provider response
@@ -326,15 +353,31 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             };
         });
     }
-    startIncomingTransactionPolling() {
-        this.incomingTransactionHelper.start();
+    startIncomingTransactionPolling(networkClientIds = []) {
+        if (networkClientIds.length === 0) {
+            this.incomingTransactionHelper.start();
+            return;
+        }
+        __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").startIncomingTransactionPolling(networkClientIds);
+    }
+    stopIncomingTransactionPolling(networkClientIds = []) {
+        if (networkClientIds.length === 0) {
+            this.incomingTransactionHelper.stop();
+            return;
+        }
+        __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").stopIncomingTransactionPolling(networkClientIds);
     }
-    stopIncomingTransactionPolling() {
+    stopAllIncomingTransactionPolling() {
         this.incomingTransactionHelper.stop();
+        __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").stopAllIncomingTransactionPolling();
     }
-    updateIncomingTransactions() {
+    updateIncomingTransactions(networkClientIds = []) {
         return __awaiter(this, void 0, void 0, function* () {
-            yield this.incomingTransactionHelper.update();
+            if (networkClientIds.length === 0) {
+                yield this.incomingTransactionHelper.update();
+                return;
+            }
+            yield __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").updateIncomingTransactions(networkClientIds);
         });
     }
     /**
@@ -356,8 +399,8 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             }
             if (gasValues) {
                 // Not good practice to reassign a parameter but temporarily avoiding a larger refactor.
-                gasValues = (0, utils_1.normalizeGasFeeValues)(gasValues);
-                (0, utils_1.validateGasValues)(gasValues);
+                gasValues = (0, utils_2.normalizeGasFeeValues)(gasValues);
+                (0, utils_2.validateGasValues)(gasValues);
             }
             (0, logger_1.projectLogger)('Creating cancel transaction', transactionId, gasValues);
             const transactionMeta = this.getTransaction(transactionId);
@@ -368,24 +411,24 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 throw new Error('No sign method defined.');
             }
             // gasPrice (legacy non EIP1559)
-            const minGasPrice = (0, utils_1.getIncreasedPriceFromExisting)(transactionMeta.txParams.gasPrice, exports.CANCEL_RATE);
-            const gasPriceFromValues = (0, utils_1.isGasPriceValue)(gasValues) && gasValues.gasPrice;
+            const minGasPrice = (0, utils_2.getIncreasedPriceFromExisting)(transactionMeta.txParams.gasPrice, exports.CANCEL_RATE);
+            const gasPriceFromValues = (0, utils_2.isGasPriceValue)(gasValues) && gasValues.gasPrice;
             const newGasPrice = (gasPriceFromValues &&
-                (0, utils_1.validateMinimumIncrease)(gasPriceFromValues, minGasPrice)) ||
+                (0, utils_2.validateMinimumIncrease)(gasPriceFromValues, minGasPrice)) ||
                 minGasPrice;
             // maxFeePerGas (EIP1559)
             const existingMaxFeePerGas = (_a = transactionMeta.txParams) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
-            const minMaxFeePerGas = (0, utils_1.getIncreasedPriceFromExisting)(existingMaxFeePerGas, exports.CANCEL_RATE);
-            const maxFeePerGasValues = (0, utils_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxFeePerGas;
+            const minMaxFeePerGas = (0, utils_2.getIncreasedPriceFromExisting)(existingMaxFeePerGas, exports.CANCEL_RATE);
+            const maxFeePerGasValues = (0, utils_2.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxFeePerGas;
             const newMaxFeePerGas = (maxFeePerGasValues &&
-                (0, utils_1.validateMinimumIncrease)(maxFeePerGasValues, minMaxFeePerGas)) ||
+                (0, utils_2.validateMinimumIncrease)(maxFeePerGasValues, minMaxFeePerGas)) ||
                 (existingMaxFeePerGas && minMaxFeePerGas);
             // maxPriorityFeePerGas (EIP1559)
             const existingMaxPriorityFeePerGas = (_b = transactionMeta.txParams) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
-            const minMaxPriorityFeePerGas = (0, utils_1.getIncreasedPriceFromExisting)(existingMaxPriorityFeePerGas, exports.CANCEL_RATE);
-            const maxPriorityFeePerGasValues = (0, utils_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxPriorityFeePerGas;
+            const minMaxPriorityFeePerGas = (0, utils_2.getIncreasedPriceFromExisting)(existingMaxPriorityFeePerGas, exports.CANCEL_RATE);
+            const maxPriorityFeePerGasValues = (0, utils_2.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxPriorityFeePerGas;
             const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
-                (0, utils_1.validateMinimumIncrease)(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
+                (0, utils_2.validateMinimumIncrease)(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                 (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
             const newTxParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                 ? {
@@ -406,9 +449,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                     to: transactionMeta.txParams.from,
                     value: '0x0',
                 };
-            const unsignedEthTx = this.prepareUnsignedEthTx(newTxParams);
+            const unsignedEthTx = this.prepareUnsignedEthTx(transactionMeta.chainId, newTxParams);
             const signedTx = yield this.sign(unsignedEthTx, transactionMeta.txParams.from);
-            const rawTx = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
+            const rawTx = (0, util_1.bufferToHex)(signedTx.serialize());
             const newFee = (_c = newTxParams.maxFeePerGas) !== null && _c !== void 0 ? _c : newTxParams.gasPrice;
             const oldFee = newTxParams.maxFeePerGas
                 ? transactionMeta.txParams.maxFeePerGas
@@ -418,10 +461,15 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 newFee,
                 txParams: newTxParams,
             });
-            const hash = yield this.publishTransactionForRetry(rawTx, transactionMeta);
+            const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId: transactionMeta.networkClientId,
+                chainId: transactionMeta.chainId,
+            });
+            const hash = yield this.publishTransactionForRetry(ethQuery, rawTx, transactionMeta);
             const cancelTransactionMeta = {
                 actionId,
                 chainId: transactionMeta.chainId,
+                networkClientId: transactionMeta.networkClientId,
                 estimatedBaseFee,
                 hash,
                 id: (0, uuid_1.v1)(),
@@ -462,8 +510,8 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             }
             if (gasValues) {
                 // Not good practice to reassign a parameter but temporarily avoiding a larger refactor.
-                gasValues = (0, utils_1.normalizeGasFeeValues)(gasValues);
-                (0, utils_1.validateGasValues)(gasValues);
+                gasValues = (0, utils_2.normalizeGasFeeValues)(gasValues);
+                (0, utils_2.validateGasValues)(gasValues);
             }
             (0, logger_1.projectLogger)('Creating speed up transaction', transactionId, gasValues);
             const transactionMeta = this.state.transactions.find(({ id }) => id === transactionId);
@@ -476,37 +524,41 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 throw new Error('No sign method defined.');
             }
             // gasPrice (legacy non EIP1559)
-            const minGasPrice = (0, utils_1.getIncreasedPriceFromExisting)(transactionMeta.txParams.gasPrice, exports.SPEED_UP_RATE);
-            const gasPriceFromValues = (0, utils_1.isGasPriceValue)(gasValues) && gasValues.gasPrice;
+            const minGasPrice = (0, utils_2.getIncreasedPriceFromExisting)(transactionMeta.txParams.gasPrice, exports.SPEED_UP_RATE);
+            const gasPriceFromValues = (0, utils_2.isGasPriceValue)(gasValues) && gasValues.gasPrice;
             const newGasPrice = (gasPriceFromValues &&
-                (0, utils_1.validateMinimumIncrease)(gasPriceFromValues, minGasPrice)) ||
+                (0, utils_2.validateMinimumIncrease)(gasPriceFromValues, minGasPrice)) ||
                 minGasPrice;
             // maxFeePerGas (EIP1559)
             const existingMaxFeePerGas = (_a = transactionMeta.txParams) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
-            const minMaxFeePerGas = (0, utils_1.getIncreasedPriceFromExisting)(existingMaxFeePerGas, exports.SPEED_UP_RATE);
-            const maxFeePerGasValues = (0, utils_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxFeePerGas;
+            const minMaxFeePerGas = (0, utils_2.getIncreasedPriceFromExisting)(existingMaxFeePerGas, exports.SPEED_UP_RATE);
+            const maxFeePerGasValues = (0, utils_2.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxFeePerGas;
             const newMaxFeePerGas = (maxFeePerGasValues &&
-                (0, utils_1.validateMinimumIncrease)(maxFeePerGasValues, minMaxFeePerGas)) ||
+                (0, utils_2.validateMinimumIncrease)(maxFeePerGasValues, minMaxFeePerGas)) ||
                 (existingMaxFeePerGas && minMaxFeePerGas);
             // maxPriorityFeePerGas (EIP1559)
             const existingMaxPriorityFeePerGas = (_b = transactionMeta.txParams) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
-            const minMaxPriorityFeePerGas = (0, utils_1.getIncreasedPriceFromExisting)(existingMaxPriorityFeePerGas, exports.SPEED_UP_RATE);
-            const maxPriorityFeePerGasValues = (0, utils_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxPriorityFeePerGas;
+            const minMaxPriorityFeePerGas = (0, utils_2.getIncreasedPriceFromExisting)(existingMaxPriorityFeePerGas, exports.SPEED_UP_RATE);
+            const maxPriorityFeePerGasValues = (0, utils_2.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxPriorityFeePerGas;
             const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
-                (0, utils_1.validateMinimumIncrease)(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
+                (0, utils_2.validateMinimumIncrease)(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                 (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
             const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                 ? Object.assign(Object.assign({}, transactionMeta.txParams), { gasLimit: transactionMeta.txParams.gas, maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas, type: types_1.TransactionEnvelopeType.feeMarket }) : Object.assign(Object.assign({}, transactionMeta.txParams), { gasLimit: transactionMeta.txParams.gas, gasPrice: newGasPrice });
-            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
+            const unsignedEthTx = this.prepareUnsignedEthTx(transactionMeta.chainId, txParams);
             const signedTx = yield this.sign(unsignedEthTx, transactionMeta.txParams.from);
             yield this.updateTransactionMetaRSV(transactionMeta, signedTx);
-            const rawTx = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
+            const rawTx = (0, util_1.bufferToHex)(signedTx.serialize());
             const newFee = (_c = txParams.maxFeePerGas) !== null && _c !== void 0 ? _c : txParams.gasPrice;
             const oldFee = txParams.maxFeePerGas
                 ? transactionMeta.txParams.maxFeePerGas
                 : transactionMeta.txParams.gasPrice;
             (0, logger_1.projectLogger)('Submitting speed up transaction', { oldFee, newFee, txParams });
-            const hash = yield this.publishTransactionForRetry(rawTx, transactionMeta);
+            const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId: transactionMeta.networkClientId,
+                chainId: transactionMeta.chainId,
+            });
+            const hash = yield this.publishTransactionForRetry(ethQuery, rawTx, transactionMeta);
             const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { estimatedBaseFee, id: (0, uuid_1.v1)(), time: Date.now(), hash,
                 actionId, originalGasEstimate: transactionMeta.txParams.gas, type: types_1.TransactionType.retry, originalType: transactionMeta.type });
             const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
@@ -528,11 +580,15 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      * Estimates required gas for a given transaction.
      *
      * @param transaction - The transaction to estimate gas for.
+     * @param networkClientId - The network client id to use for the estimate.
      * @returns The gas and gas price.
      */
-    estimateGas(transaction) {
+    estimateGas(transaction, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { estimatedGas, simulationFails } = yield (0, gas_1.estimateGas)(transaction, this.ethQuery);
+            const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId,
+            });
+            const { estimatedGas, simulationFails } = yield (0, gas_1.estimateGas)(transaction, ethQuery);
             return { gas: estimatedGas, simulationFails };
         });
     }
@@ -541,10 +597,14 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      *
      * @param transaction - The transaction params to estimate gas for.
      * @param multiplier - The multiplier to use for the gas buffer.
+     * @param networkClientId - The network client id to use for the estimate.
      */
-    estimateGasBuffered(transaction, multiplier) {
+    estimateGasBuffered(transaction, multiplier, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const { blockGasLimit, estimatedGas, simulationFails } = yield (0, gas_1.estimateGas)(transaction, this.ethQuery);
+            const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId,
+            });
+            const { blockGasLimit, estimatedGas, simulationFails } = yield (0, gas_1.estimateGas)(transaction, ethQuery);
             const gas = (0, gas_1.addGasBuffer)(estimatedGas, blockGasLimit, multiplier);
             return {
                 gas,
@@ -559,15 +619,10 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      * @param note - A note or update reason to include in the transaction history.
      */
     updateTransaction(transactionMeta, note) {
-        const { transactions } = this.state;
-        transactionMeta.txParams = (0, utils_1.normalizeTxParams)(transactionMeta.txParams);
-        (0, validation_1.validateTxParams)(transactionMeta.txParams);
-        if (!this.isHistoryDisabled) {
-            (0, history_1.updateTransactionHistory)(transactionMeta, note);
-        }
-        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
-        transactions[index] = transactionMeta;
-        this.update({ transactions: this.trimTransactionsForState(transactions) });
+        __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_updateTransactionInternal).call(this, transactionMeta, {
+            note,
+            skipHistory: this.isHistoryDisabled,
+        });
     }
     /**
      * Update the security alert response for a transaction.
@@ -614,12 +669,6 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             transactions: this.trimTransactionsForState(newTransactions),
         });
     }
-    startIncomingTransactionProcessing() {
-        this.incomingTransactionHelper.start();
-    }
-    stopIncomingTransactionProcessing() {
-        this.incomingTransactionHelper.stop();
-    }
     /**
      * Adds external provided transaction to state as confirmed transaction.
      *
@@ -673,7 +722,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         if (!transactionMeta) {
             throw new Error(`Cannot update send flow history as no transaction metadata found`);
         }
-        (0, utils_1.validateIfTransactionUnapproved)(transactionMeta, 'updateTransactionSendFlowHistory');
+        (0, utils_2.validateIfTransactionUnapproved)(transactionMeta, 'updateTransactionSendFlowHistory');
         if (currentSendFlowHistoryLength ===
             (((_a = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.sendFlowHistory) === null || _a === void 0 ? void 0 : _a.length) || 0)) {
             transactionMeta.sendFlowHistory = [
@@ -707,7 +756,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         if (!transactionMeta) {
             throw new Error(`Cannot update transaction as no transaction metadata found`);
         }
-        (0, utils_1.validateIfTransactionUnapproved)(transactionMeta, 'updateTransactionGasFees');
+        (0, utils_2.validateIfTransactionUnapproved)(transactionMeta, 'updateTransactionGasFees');
         let transactionGasFees = {
             txParams: {
                 gas,
@@ -748,7 +797,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         if (!transactionMeta) {
             throw new Error(`Cannot update transaction as no transaction metadata found`);
         }
-        (0, utils_1.validateIfTransactionUnapproved)(transactionMeta, 'updatePreviousGasParams');
+        (0, utils_2.validateIfTransactionUnapproved)(transactionMeta, 'updatePreviousGasParams');
         const transactionPreviousGas = {
             previousGas: {
                 gasLimit,
@@ -765,16 +814,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         this.updateTransaction(updatedMeta, 'TransactionController:updatePreviousGasParams - Previous gas values updated');
         return this.getTransaction(transactionId);
     }
-    /**
-     * Gets the next nonce according to the nonce-tracker.
-     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
-     *
-     * @param address - The hex string address for the transaction.
-     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
-     */
-    getNonceLock(address) {
+    getNonceLock(address, networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            return this.nonceTracker.getNonceLock(address);
+            return __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getNonceLock(address, networkClientId);
         });
     }
     /**
@@ -796,7 +838,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             if (!transactionMeta) {
                 throw new Error(`Cannot update editable params as no transaction metadata found`);
             }
-            (0, utils_1.validateIfTransactionUnapproved)(transactionMeta, 'updateEditableParams');
+            (0, utils_2.validateIfTransactionUnapproved)(transactionMeta, 'updateEditableParams');
             const editableParams = {
                 txParams: {
                     data,
@@ -809,7 +851,10 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             };
             editableParams.txParams = (0, lodash_1.pickBy)(editableParams.txParams);
             const updatedTransaction = (0, lodash_1.merge)(transactionMeta, editableParams);
-            const { type } = yield (0, transaction_type_1.determineTransactionType)(updatedTransaction.txParams, this.ethQuery);
+            const { type } = yield (0, transaction_type_1.determineTransactionType)(updatedTransaction.txParams, __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId: transactionMeta.networkClientId,
+                chainId: transactionMeta.chainId,
+            }));
             updatedTransaction.type = type;
             this.updateTransaction(updatedTransaction, `Update Editable Params for ${txId}`);
             return this.getTransaction(txId);
@@ -832,11 +877,23 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 return '';
             }
             const initialTx = listOfTxParams[0];
-            const common = this.getCommonConfiguration();
+            const common = this.getCommonConfiguration(initialTx.chainId);
+            // We need to ensure we get the nonce using the the NonceTracker on the chain matching
+            // the txParams. In this context we only have chainId available to us, but the
+            // NonceTrackers are keyed by networkClientId. To workaround this, we attempt to find
+            // a networkClientId that matches the chainId. As a fallback, the globally selected
+            // network's NonceTracker will be used instead.
+            let networkClientId;
+            try {
+                networkClientId = this.messagingSystem.call(`NetworkController:findNetworkClientIdByChainId`, initialTx.chainId);
+            }
+            catch (err) {
+                (0, logger_1.projectLogger)('failed to find networkClientId from chainId', err);
+            }
             const initialTxAsEthTx = tx_1.TransactionFactory.fromTxData(initialTx, {
                 common,
             });
-            const initialTxAsSerializedHex = (0, ethereumjs_util_1.bufferToHex)(initialTxAsEthTx.serialize());
+            const initialTxAsSerializedHex = (0, util_1.bufferToHex)(initialTxAsEthTx.serialize());
             if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
                 return '';
             }
@@ -847,17 +904,17 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 const fromAddress = initialTx.from;
                 const requiresNonce = hasNonce !== true;
                 nonceLock = requiresNonce
-                    ? yield this.nonceTracker.getNonceLock(fromAddress)
+                    ? yield this.getNonceLock(fromAddress, networkClientId)
                     : undefined;
                 const nonce = nonceLock
-                    ? (0, ethereumjs_util_1.addHexPrefix)(nonceLock.nextNonce.toString(16))
+                    ? (0, utils_1.add0x)(nonceLock.nextNonce.toString(16))
                     : initialTx.nonce;
                 if (nonceLock) {
                     (0, logger_1.projectLogger)('Using nonce from nonce tracker', nonce, nonceLock.nonceDetails);
                 }
                 rawTransactions = yield Promise.all(listOfTxParams.map((txParams) => {
                     txParams.nonce = nonce;
-                    return this.signExternalTransaction(txParams);
+                    return this.signExternalTransaction(txParams.chainId, txParams);
                 }));
             }
             catch (err) {
@@ -903,7 +960,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             updatedTransactionMeta.submittedTime = new Date().getTime();
         }
         if (status === types_1.TransactionStatus.failed) {
-            updatedTransactionMeta.error = (0, utils_1.normalizeTxError)(new Error(errorMessage));
+            updatedTransactionMeta.error = (0, utils_2.normalizeTxError)(new Error(errorMessage));
         }
         this.updateTransaction(updatedTransactionMeta, `TransactionController:updateCustodialTransaction - Custodial transaction updated`);
         if ([types_1.TransactionStatus.submitted, types_1.TransactionStatus.failed].includes(status)) {
@@ -1015,22 +1072,21 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         }
         return filteredTransactions;
     }
-    signExternalTransaction(transactionParams) {
+    signExternalTransaction(chainId, transactionParams) {
         return __awaiter(this, void 0, void 0, function* () {
             if (!this.sign) {
                 throw new Error('No sign method defined.');
             }
-            const normalizedTransactionParams = (0, utils_1.normalizeTxParams)(transactionParams);
-            const chainId = this.getChainId();
-            const type = (0, utils_1.isEIP1559Transaction)(normalizedTransactionParams)
+            const normalizedTransactionParams = (0, utils_2.normalizeTransactionParams)(transactionParams);
+            const type = (0, utils_2.isEIP1559Transaction)(normalizedTransactionParams)
                 ? types_1.TransactionEnvelopeType.feeMarket
                 : types_1.TransactionEnvelopeType.legacy;
             const updatedTransactionParams = Object.assign(Object.assign({}, normalizedTransactionParams), { type, gasLimit: normalizedTransactionParams.gas, chainId });
             const { from } = updatedTransactionParams;
-            const common = this.getCommonConfiguration();
+            const common = this.getCommonConfiguration(chainId);
             const unsignedTransaction = tx_1.TransactionFactory.fromTxData(updatedTransactionParams, { common });
             const signedTransaction = yield this.sign(unsignedTransaction, from);
-            const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTransaction.serialize());
+            const rawTransaction = (0, util_1.bufferToHex)(signedTransaction.serialize());
             return rawTransaction;
         });
     }
@@ -1065,35 +1121,42 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
     }
     updateGasProperties(transactionMeta) {
         return __awaiter(this, void 0, void 0, function* () {
-            const isEIP1559Compatible = (yield this.getEIP1559Compatibility()) &&
+            const isEIP1559Compatible = (yield this.getEIP1559Compatibility(transactionMeta.networkClientId)) &&
                 transactionMeta.txParams.type !== types_1.TransactionEnvelopeType.legacy;
-            const chainId = this.getChainId();
+            const { networkClientId, chainId } = transactionMeta;
+            const isCustomNetwork = networkClientId
+                ? this.messagingSystem.call(`NetworkController:getNetworkClientById`, networkClientId).configuration.type === network_controller_1.NetworkClientType.Custom
+                : this.getNetworkState().providerConfig.type === controller_utils_1.NetworkType.rpc;
             yield (0, gas_1.updateGas)({
-                ethQuery: this.ethQuery,
-                providerConfig: this.getNetworkState().providerConfig,
+                ethQuery: __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                    networkClientId,
+                    chainId,
+                }),
+                chainId,
+                isCustomNetwork,
                 txMeta: transactionMeta,
             });
             yield (0, gas_fees_1.updateGasFees)({
                 eip1559: isEIP1559Compatible,
-                ethQuery: this.ethQuery,
-                getSavedGasFees: this.getSavedGasFees.bind(this, chainId),
-                getGasFeeEstimates: this.getGasFeeEstimates.bind(this),
+                ethQuery: __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                    networkClientId,
+                    chainId,
+                }),
+                gasFeeFlows: this.gasFeeFlows,
+                getGasFeeEstimates: this.getGasFeeEstimates,
+                getSavedGasFees: this.getSavedGasFees.bind(this),
                 txMeta: transactionMeta,
             });
         });
     }
-    getCurrentChainTransactionsByStatus(status) {
-        const chainId = this.getChainId();
-        return this.state.transactions.filter((transaction) => transaction.status === status && transaction.chainId === chainId);
-    }
     onBootCleanup() {
         this.submitApprovedTransactions();
     }
     /**
-     * Force to submit approved transactions on current chain.
+     * Force submit approved transactions for all chains.
      */
     submitApprovedTransactions() {
-        const approvedTransactions = this.getCurrentChainTransactionsByStatus(types_1.TransactionStatus.approved);
+        const approvedTransactions = this.state.transactions.filter((transaction) => transaction.status === types_1.TransactionStatus.approved);
         for (const transactionMeta of approvedTransactions) {
             if (this.beforeApproveOnInit(transactionMeta)) {
                 this.approveTransaction(transactionMeta.id).catch((error) => {
@@ -1187,10 +1250,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         return __awaiter(this, void 0, void 0, function* () {
             const { transactions } = this.state;
             const releaseLock = yield this.mutex.acquire();
-            const chainId = this.getChainId();
             const index = transactions.findIndex(({ id }) => transactionId === id);
             const transactionMeta = transactions[index];
-            const { txParams: { from }, } = transactionMeta;
+            const { txParams: { from }, networkClientId, } = transactionMeta;
             let releaseNonceLock;
             try {
                 if (!this.sign) {
@@ -1198,7 +1260,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                     this.failTransaction(transactionMeta, new Error('No sign method defined.'));
                     return;
                 }
-                else if (!chainId) {
+                else if (!transactionMeta.chainId) {
                     releaseLock();
                     this.failTransaction(transactionMeta, new Error('No chainId defined.'));
                     return;
@@ -1207,15 +1269,15 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                     (0, logger_1.projectLogger)('Skipping approval as signing in progress', transactionId);
                     return;
                 }
-                const [nonce, releaseNonce] = yield (0, nonce_1.getNextNonce)(transactionMeta, this.nonceTracker);
+                const [nonce, releaseNonce] = yield (0, nonce_1.getNextNonce)(transactionMeta, (address) => __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getNonceLock(address, networkClientId));
                 releaseNonceLock = releaseNonce;
                 transactionMeta.status = types_1.TransactionStatus.approved;
                 transactionMeta.txParams.nonce = nonce;
-                transactionMeta.txParams.chainId = chainId;
+                transactionMeta.txParams.chainId = transactionMeta.chainId;
                 const baseTxParams = Object.assign(Object.assign({}, transactionMeta.txParams), { gasLimit: transactionMeta.txParams.gas });
                 this.updateTransaction(transactionMeta, 'TransactionController#approveTransaction - Transaction approved');
                 this.onTransactionStatusChange(transactionMeta);
-                const isEIP1559 = (0, utils_1.isEIP1559Transaction)(transactionMeta.txParams);
+                const isEIP1559 = (0, utils_2.isEIP1559Transaction)(transactionMeta.txParams);
                 const txParams = isEIP1559
                     ? Object.assign(Object.assign({}, baseTxParams), { estimatedBaseFee: transactionMeta.txParams.estimatedBaseFee, type: types_1.TransactionEnvelopeType.feeMarket }) : baseTxParams;
                 const rawTx = yield this.signTransaction(transactionMeta, txParams);
@@ -1227,16 +1289,20 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 if (!rawTx) {
                     return;
                 }
+                const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                    networkClientId: transactionMeta.networkClientId,
+                    chainId: transactionMeta.chainId,
+                });
                 if (transactionMeta.type === types_1.TransactionType.swap) {
                     (0, logger_1.projectLogger)('Determining pre-transaction balance');
-                    const preTxBalance = yield (0, controller_utils_1.query)(this.ethQuery, 'getBalance', [from]);
+                    const preTxBalance = yield (0, controller_utils_1.query)(ethQuery, 'getBalance', [from]);
                     transactionMeta.preTxBalance = preTxBalance;
                     (0, logger_1.projectLogger)('Updated pre-transaction balance', transactionMeta.preTxBalance);
                 }
                 (0, logger_1.projectLogger)('Publishing transaction', txParams);
                 let { transactionHash: hash } = yield this.publish(transactionMeta, rawTx);
                 if (hash === undefined) {
-                    hash = yield this.publishTransaction(rawTx);
+                    hash = yield this.publishTransaction(ethQuery, rawTx);
                 }
                 (0, logger_1.projectLogger)('Publish successful', hash);
                 transactionMeta.hash = hash;
@@ -1262,9 +1328,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             }
         });
     }
-    publishTransaction(rawTransaction) {
+    publishTransaction(ethQuery, rawTransaction) {
         return __awaiter(this, void 0, void 0, function* () {
-            return yield (0, controller_utils_1.query)(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
+            return yield (0, controller_utils_1.query)(ethQuery, 'sendRawTransaction', [rawTransaction]);
         });
     }
     /**
@@ -1380,14 +1446,17 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         const isCompleted = this.isLocalFinalState(transaction.status);
         return { meta: transaction, isCompleted };
     }
-    getChainId() {
+    getChainId(networkClientId) {
+        if (networkClientId) {
+            return this.messagingSystem.call(`NetworkController:getNetworkClientById`, networkClientId).configuration.chainId;
+        }
         const { providerConfig } = this.getNetworkState();
         return providerConfig.chainId;
     }
-    prepareUnsignedEthTx(txParams) {
+    prepareUnsignedEthTx(chainId, txParams) {
         return tx_1.TransactionFactory.fromTxData(txParams, {
-            common: this.getCommonConfiguration(),
             freeze: false,
+            common: this.getCommonConfiguration(chainId),
         });
     }
     /**
@@ -1397,17 +1466,11 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
      * transaction type to use.
      *
+     * @param chainId - The chainId to use for the configuration.
      * @returns common configuration object
      */
-    getCommonConfiguration() {
-        const { providerConfig: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
-        if (chain !== controller_utils_1.RPC &&
-            chain !== controller_utils_1.NetworkType['linea-goerli'] &&
-            chain !== controller_utils_1.NetworkType['linea-mainnet']) {
-            return new common_1.Common({ chain, hardfork: exports.HARDFORK });
-        }
+    getCommonConfiguration(chainId) {
         const customChainParams = {
-            name,
             chainId: parseInt(chainId, 16),
             defaultHardfork: exports.HARDFORK,
         };
@@ -1462,7 +1525,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      */
     addExternalTransaction(transactionMeta) {
         var _a, _b;
-        const chainId = this.getChainId();
+        const { chainId } = transactionMeta;
         const { transactions } = this.state;
         const fromAddress = (_a = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.txParams) === null || _a === void 0 ? void 0 : _a.from;
         const sameFromAndNetworkTransactions = transactions.filter((transaction) => transaction.txParams.from === fromAddress &&
@@ -1489,10 +1552,13 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      */
     markNonceDuplicatesDropped(transactionId) {
         var _a, _b;
-        const chainId = this.getChainId();
         const transactionMeta = this.getTransaction(transactionId);
-        const nonce = (_a = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.txParams) === null || _a === void 0 ? void 0 : _a.nonce;
-        const from = (_b = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.txParams) === null || _b === void 0 ? void 0 : _b.from;
+        if (!transactionMeta) {
+            return;
+        }
+        const nonce = (_a = transactionMeta.txParams) === null || _a === void 0 ? void 0 : _a.nonce;
+        const from = (_b = transactionMeta.txParams) === null || _b === void 0 ? void 0 : _b.from;
+        const { chainId } = transactionMeta;
         const sameNonceTxs = this.state.transactions.filter((transaction) => transaction.id !== transactionId &&
             transaction.txParams.from === from &&
             transaction.txParams.nonce === nonce &&
@@ -1503,8 +1569,8 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         }
         // Mark all same nonce transactions as dropped and give it a replacedBy hash
         for (const transaction of sameNonceTxs) {
-            transaction.replacedBy = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.hash;
-            transaction.replacedById = transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.id;
+            transaction.replacedBy = transactionMeta.hash;
+            transaction.replacedById = transactionMeta.id;
             // Drop any transaction that wasn't previously failed (off chain failure)
             if (transaction.status !== types_1.TransactionStatus.failed) {
                 this.setTransactionStatusDropped(transaction);
@@ -1556,27 +1622,21 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 if (value === undefined || value === null) {
                     continue;
                 }
-                transactionMeta[key] = (0, ethereumjs_util_1.addHexPrefix)(value.toString(16));
+                transactionMeta[key] = (0, utils_1.add0x)(value.toString(16));
             }
         });
     }
-    getEIP1559Compatibility() {
+    getEIP1559Compatibility(networkClientId) {
         return __awaiter(this, void 0, void 0, function* () {
-            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility();
+            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility(networkClientId);
             const currentAccountIsEIP1559Compatible = yield this.getCurrentAccountEIP1559Compatibility();
             return (currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible);
         });
     }
-    addPendingTransactionTrackerListeners() {
-        this.pendingTransactionTracker.hub.on('transaction-confirmed', this.onConfirmedTransaction.bind(this));
-        this.pendingTransactionTracker.hub.on('transaction-dropped', this.setTransactionStatusDropped.bind(this));
-        this.pendingTransactionTracker.hub.on('transaction-failed', this.failTransaction.bind(this));
-        this.pendingTransactionTracker.hub.on('transaction-updated', this.updateTransaction.bind(this));
-    }
     signTransaction(transactionMeta, txParams) {
         return __awaiter(this, void 0, void 0, function* () {
             (0, logger_1.projectLogger)('Signing transaction', txParams);
-            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
+            const unsignedEthTx = this.prepareUnsignedEthTx(transactionMeta.chainId, txParams);
             this.inProcessOfSigning.add(transactionMeta.id);
             const signedTx = yield new Promise((resolve, reject) => {
                 var _a;
@@ -1597,7 +1657,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             transactionMeta.status = types_1.TransactionStatus.signed;
             this.updateTransaction(transactionMeta, 'TransactionController#approveTransaction - Transaction signed');
             this.onTransactionStatusChange(transactionMeta);
-            const rawTx = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
+            const rawTx = (0, util_1.bufferToHex)(signedTx.serialize());
             transactionMeta.rawTx = rawTx;
             this.updateTransaction(transactionMeta, 'TransactionController#approveTransaction - RawTransaction added');
             return rawTx;
@@ -1606,14 +1666,8 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
     onTransactionStatusChange(transactionMeta) {
         this.hub.emit('transaction-status-update', { transactionMeta });
     }
-    getNonceTrackerPendingTransactions(address) {
-        const standardPendingTransactions = this.getNonceTrackerTransactions(types_1.TransactionStatus.submitted, address);
-        const externalPendingTransactions = this.getExternalPendingTransactions(address);
-        return [...standardPendingTransactions, ...externalPendingTransactions];
-    }
-    getNonceTrackerTransactions(status, address) {
-        const currentChainId = this.getChainId();
-        return (0, nonce_1.getAndFormatTransactionsForNonceTracker)(currentChainId, address, status, this.state.transactions);
+    getNonceTrackerTransactions(status, address, chainId = this.getChainId()) {
+        return (0, nonce_1.getAndFormatTransactionsForNonceTracker)(chainId, address, status, this.state.transactions);
     }
     onConfirmedTransaction(transactionMeta) {
         (0, logger_1.projectLogger)('Processing confirmed transaction', transactionMeta.id);
@@ -1631,8 +1685,12 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 if (transactionMeta.type !== types_1.TransactionType.swap) {
                     return;
                 }
+                const ethQuery = __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                    networkClientId: transactionMeta.networkClientId,
+                    chainId: transactionMeta.chainId,
+                });
                 const { updatedTransactionMeta, approvalTransactionMeta } = yield (0, swaps_1.updatePostTransactionBalance)(transactionMeta, {
-                    ethQuery: this.ethQuery,
+                    ethQuery,
                     getTransaction: this.getTransaction.bind(this),
                     updateTransaction: this.updateTransaction.bind(this),
                 });
@@ -1647,10 +1705,10 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             }
         });
     }
-    publishTransactionForRetry(rawTx, transactionMeta) {
+    publishTransactionForRetry(ethQuery, rawTx, transactionMeta) {
         return __awaiter(this, void 0, void 0, function* () {
             try {
-                const hash = yield this.publishTransaction(rawTx);
+                const hash = yield this.publishTransaction(ethQuery, rawTx);
                 return hash;
             }
             catch (error) {
@@ -1678,4 +1736,104 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
     }
 }
 exports.TransactionController = TransactionController;
+_TransactionController_incomingTransactionOptions = new WeakMap(), _TransactionController_pendingTransactionOptions = new WeakMap(), _TransactionController_multichainTrackingHelper = new WeakMap(), _TransactionController_checkForPendingTransactionAndStartPolling = new WeakMap(), _TransactionController_instances = new WeakSet(), _TransactionController_createNonceTracker = function _TransactionController_createNonceTracker({ provider, blockTracker, chainId, }) {
+    return new nonce_tracker_1.NonceTracker({
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        provider: provider,
+        blockTracker,
+        getPendingTransactions: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getNonceTrackerPendingTransactions).bind(this, chainId),
+        getConfirmedTransactions: this.getNonceTrackerTransactions.bind(this, types_1.TransactionStatus.confirmed),
+    });
+}, _TransactionController_createIncomingTransactionHelper = function _TransactionController_createIncomingTransactionHelper({ blockTracker, etherscanRemoteTransactionSource, chainId, }) {
+    const incomingTransactionHelper = new IncomingTransactionHelper_1.IncomingTransactionHelper({
+        blockTracker,
+        getCurrentAccount: this.getSelectedAddress,
+        getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+        getChainId: chainId ? () => chainId : this.getChainId.bind(this),
+        isEnabled: __classPrivateFieldGet(this, _TransactionController_incomingTransactionOptions, "f").isEnabled,
+        queryEntireHistory: __classPrivateFieldGet(this, _TransactionController_incomingTransactionOptions, "f").queryEntireHistory,
+        remoteTransactionSource: etherscanRemoteTransactionSource,
+        transactionLimit: this.config.txHistoryLimit,
+        updateTransactions: __classPrivateFieldGet(this, _TransactionController_incomingTransactionOptions, "f").updateTransactions,
+    });
+    __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_addIncomingTransactionHelperListeners).call(this, incomingTransactionHelper);
+    return incomingTransactionHelper;
+}, _TransactionController_createPendingTransactionTracker = function _TransactionController_createPendingTransactionTracker({ provider, blockTracker, chainId, }) {
+    const ethQuery = new eth_query_1.default(provider);
+    const getChainId = chainId ? () => chainId : this.getChainId.bind(this);
+    const pendingTransactionTracker = new PendingTransactionTracker_1.PendingTransactionTracker({
+        approveTransaction: this.approveTransaction.bind(this),
+        blockTracker,
+        getChainId,
+        getEthQuery: () => ethQuery,
+        getTransactions: () => this.state.transactions,
+        isResubmitEnabled: __classPrivateFieldGet(this, _TransactionController_pendingTransactionOptions, "f").isResubmitEnabled,
+        getGlobalLock: () => __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").acquireNonceLockForChainIdKey({
+            chainId: getChainId(),
+        }),
+        publishTransaction: this.publishTransaction.bind(this),
+        hooks: {
+            beforeCheckPendingTransaction: this.beforeCheckPendingTransaction.bind(this),
+            beforePublish: this.beforePublish.bind(this),
+        },
+    });
+    __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_addPendingTransactionTrackerListeners).call(this, pendingTransactionTracker);
+    return pendingTransactionTracker;
+}, _TransactionController_stopAllTracking = function _TransactionController_stopAllTracking() {
+    this.pendingTransactionTracker.stop();
+    __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_removePendingTransactionTrackerListeners).call(this, this.pendingTransactionTracker);
+    this.incomingTransactionHelper.stop();
+    __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_removeIncomingTransactionHelperListeners).call(this, this.incomingTransactionHelper);
+    __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").stopAllTracking();
+}, _TransactionController_removeIncomingTransactionHelperListeners = function _TransactionController_removeIncomingTransactionHelperListeners(incomingTransactionHelper) {
+    incomingTransactionHelper.hub.removeAllListeners('transactions');
+    incomingTransactionHelper.hub.removeAllListeners('updatedLastFetchedBlockNumbers');
+}, _TransactionController_addIncomingTransactionHelperListeners = function _TransactionController_addIncomingTransactionHelperListeners(incomingTransactionHelper) {
+    incomingTransactionHelper.hub.on('transactions', this.onIncomingTransactions.bind(this));
+    incomingTransactionHelper.hub.on('updatedLastFetchedBlockNumbers', this.onUpdatedLastFetchedBlockNumbers.bind(this));
+}, _TransactionController_removePendingTransactionTrackerListeners = function _TransactionController_removePendingTransactionTrackerListeners(pendingTransactionTracker) {
+    pendingTransactionTracker.hub.removeAllListeners('transaction-confirmed');
+    pendingTransactionTracker.hub.removeAllListeners('transaction-dropped');
+    pendingTransactionTracker.hub.removeAllListeners('transaction-failed');
+    pendingTransactionTracker.hub.removeAllListeners('transaction-updated');
+}, _TransactionController_addPendingTransactionTrackerListeners = function _TransactionController_addPendingTransactionTrackerListeners(pendingTransactionTracker) {
+    pendingTransactionTracker.hub.on('transaction-confirmed', this.onConfirmedTransaction.bind(this));
+    pendingTransactionTracker.hub.on('transaction-dropped', this.setTransactionStatusDropped.bind(this));
+    pendingTransactionTracker.hub.on('transaction-failed', this.failTransaction.bind(this));
+    pendingTransactionTracker.hub.on('transaction-updated', this.updateTransaction.bind(this));
+}, _TransactionController_getNonceTrackerPendingTransactions = function _TransactionController_getNonceTrackerPendingTransactions(chainId, address) {
+    const standardPendingTransactions = this.getNonceTrackerTransactions(types_1.TransactionStatus.submitted, address, chainId);
+    const externalPendingTransactions = this.getExternalPendingTransactions(address, chainId);
+    return [...standardPendingTransactions, ...externalPendingTransactions];
+}, _TransactionController_getGasFeeFlows = function _TransactionController_getGasFeeFlows() {
+    return [new LineaGasFeeFlow_1.LineaGasFeeFlow(), new DefaultGasFeeFlow_1.DefaultGasFeeFlow()];
+}, _TransactionController_updateTransactionInternal = function _TransactionController_updateTransactionInternal(transactionMeta, { note, skipHistory }) {
+    const { transactions } = this.state;
+    transactionMeta.txParams = (0, utils_2.normalizeTransactionParams)(transactionMeta.txParams);
+    (0, validation_1.validateTxParams)(transactionMeta.txParams);
+    if (skipHistory !== true) {
+        (0, history_1.updateTransactionHistory)(transactionMeta, note !== null && note !== void 0 ? note : 'Transaction updated');
+    }
+    const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
+    transactions[index] = transactionMeta;
+    this.update({ transactions: this.trimTransactionsForState(transactions) });
+}, _TransactionController_simulateTransaction = function _TransactionController_simulateTransaction(transactionMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!this.isSimulationEnabled()) {
+            (0, logger_1.projectLogger)('Skipping simulation as disabled');
+            return;
+        }
+        const { chainId, txParams } = transactionMeta;
+        const { from, to, value, data } = txParams;
+        transactionMeta.simulationData = yield (0, simulation_1.getSimulationData)({
+            chainId,
+            from: from,
+            to: to,
+            value: value,
+            data: data,
+        });
+        (0, logger_1.projectLogger)('Retrieved simulation data', transactionMeta.simulationData);
+    });
+};
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/constants.d.ts b/dist/constants.d.ts
index 06bf9f0e6dcea286fdee08087534884c7c07ec32..cb0ebaaa8e2b0d08c7d9c132c4e8d3598992e1fa 100644
--- a/dist/constants.d.ts
+++ b/dist/constants.d.ts
@@ -4,7 +4,7 @@ export declare const CHAIN_IDS: {
     readonly BSC: "0x38";
     readonly BSC_TESTNET: "0x61";
     readonly OPTIMISM: "0xa";
-    readonly OPTIMISM_TESTNET: "0x1a4";
+    readonly OPTIMISM_SEPOLIA: "0xaa37dc";
     readonly POLYGON: "0x89";
     readonly POLYGON_TESTNET: "0x13881";
     readonly AVALANCHE: "0xa86a";
@@ -56,7 +56,7 @@ export declare const ETHERSCAN_SUPPORTED_NETWORKS: {
         domain: string;
         subdomain: string;
     };
-    "0x1a4": {
+    "0xaa37dc": {
         domain: string;
         subdomain: string;
     };
@@ -103,6 +103,6 @@ export declare const ETHERSCAN_SUPPORTED_NETWORKS: {
 };
 export declare const GAS_BUFFER_CHAIN_OVERRIDES: {
     "0xa": number;
-    "0x1a4": number;
+    "0xaa37dc": number;
 };
 //# sourceMappingURL=constants.d.ts.map
\ No newline at end of file
diff --git a/dist/constants.js b/dist/constants.js
index 362a0f6fe00fa4c5982542bd21a2cd354cd17c7c..bf10f835916bc003aef38f0648b6a366f2a94bec 100644
--- a/dist/constants.js
+++ b/dist/constants.js
@@ -7,7 +7,7 @@ exports.CHAIN_IDS = {
     BSC: '0x38',
     BSC_TESTNET: '0x61',
     OPTIMISM: '0xa',
-    OPTIMISM_TESTNET: '0x1a4',
+    OPTIMISM_SEPOLIA: '0xaa37dc',
     POLYGON: '0x89',
     POLYGON_TESTNET: '0x13881',
     AVALANCHE: '0xa86a',
@@ -59,9 +59,9 @@ exports.ETHERSCAN_SUPPORTED_NETWORKS = {
         domain: exports.DEFAULT_ETHERSCAN_DOMAIN,
         subdomain: `${exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-optimistic`,
     },
-    [exports.CHAIN_IDS.OPTIMISM_TESTNET]: {
+    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: {
         domain: exports.DEFAULT_ETHERSCAN_DOMAIN,
-        subdomain: `${exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-goerli-optimistic`,
+        subdomain: `${exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia-optimistic`,
     },
     [exports.CHAIN_IDS.POLYGON]: {
         domain: 'polygonscan.com',
@@ -106,6 +106,6 @@ exports.ETHERSCAN_SUPPORTED_NETWORKS = {
 };
 exports.GAS_BUFFER_CHAIN_OVERRIDES = {
     [exports.CHAIN_IDS.OPTIMISM]: 1,
-    [exports.CHAIN_IDS.OPTIMISM_TESTNET]: 1,
+    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: 1,
 };
 //# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.d.ts b/dist/gas-flows/DefaultGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..325802b3bdecba22343ebacc0c07d0ea087bce52
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+export declare class DefaultGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..8e38b2711c6636e2776bd8ff4cd89a2468a45aa4
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -0,0 +1,78 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFeeFlow_instances, _DefaultGasFeeFlow_getEstimateLevel, _DefaultGasFeeFlow_getFeeMarketLevel, _DefaultGasFeeFlow_getLegacyLevel;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFeeFlow = void 0;
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_fees_1 = require("../utils/gas-fees");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'default-gas-fee-flow');
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+class DefaultGasFeeFlow {
+    constructor() {
+        _DefaultGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { getGasFeeControllerEstimates, transactionMeta } = request;
+            const { networkClientId } = transactionMeta;
+            const { gasEstimateType, gasFeeEstimates } = yield getGasFeeControllerEstimates({ networkClientId });
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                log('Using fee market estimates', gasFeeEstimates);
+            }
+            else if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                log('Using legacy estimates', gasFeeEstimates);
+            }
+            else {
+                throw new Error(`'No gas fee estimates available`);
+            }
+            const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getEstimateLevel).call(this, {
+                    gasEstimateType,
+                    gasFeeEstimates,
+                    level,
+                }) })), {});
+            return { estimates };
+        });
+    }
+}
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+_DefaultGasFeeFlow_instances = new WeakSet(), _DefaultGasFeeFlow_getEstimateLevel = function _DefaultGasFeeFlow_getEstimateLevel({ gasEstimateType, gasFeeEstimates, level, }) {
+    if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, level);
+    }
+    return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, level);
+}, _DefaultGasFeeFlow_getFeeMarketLevel = function _DefaultGasFeeFlow_getFeeMarketLevel(gasFeeEstimates, level) {
+    const maxFeePerGas = (0, gas_fees_1.gweiDecimalToWeiHex)(gasFeeEstimates[level].suggestedMaxFeePerGas);
+    const maxPriorityFeePerGas = (0, gas_fees_1.gweiDecimalToWeiHex)(gasFeeEstimates[level].suggestedMaxPriorityFeePerGas);
+    return {
+        maxFeePerGas,
+        maxPriorityFeePerGas,
+    };
+}, _DefaultGasFeeFlow_getLegacyLevel = function _DefaultGasFeeFlow_getLegacyLevel(gasFeeEstimates, level) {
+    const gasPrice = (0, gas_fees_1.gweiDecimalToWeiHex)(gasFeeEstimates[level]);
+    return {
+        maxFeePerGas: gasPrice,
+        maxPriorityFeePerGas: gasPrice,
+    };
+};
+//# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.d.ts b/dist/gas-flows/LineaGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ce728dbb8f4d72569d4fe703425350ed4d7683d4
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - Static multipliers to increase the base and priority fees.
+ */
+export declare class LineaGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=LineaGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..856d378efcf21f3cfc961f92f86a5111e85a1a7d
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -0,0 +1,111 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _LineaGasFeeFlow_instances, _LineaGasFeeFlow_getLineaGasFees, _LineaGasFeeFlow_getLineaResponse, _LineaGasFeeFlow_getValuesFromMultipliers, _LineaGasFeeFlow_getMaxFees, _LineaGasFeeFlow_feesToString;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.LineaGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const DefaultGasFeeFlow_1 = require("./DefaultGasFeeFlow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'linea-gas-fee-flow');
+const LINEA_CHAIN_IDS = [
+    controller_utils_1.ChainId['linea-mainnet'],
+    controller_utils_1.ChainId['linea-goerli'],
+];
+const BASE_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.35,
+    high: 1.7,
+};
+const PRIORITY_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.05,
+    high: 1.1,
+};
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - Static multipliers to increase the base and priority fees.
+ */
+class LineaGasFeeFlow {
+    constructor() {
+        _LineaGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(transactionMeta) {
+        return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                return yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaGasFees).call(this, request);
+            }
+            catch (error) {
+                log('Using default flow as fallback due to error', error);
+                return new DefaultGasFeeFlow_1.DefaultGasFeeFlow().getGasFees(request);
+            }
+        });
+    }
+}
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+_LineaGasFeeFlow_instances = new WeakSet(), _LineaGasFeeFlow_getLineaGasFees = function _LineaGasFeeFlow_getLineaGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { ethQuery, transactionMeta } = request;
+        const lineaResponse = yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaResponse).call(this, transactionMeta, ethQuery);
+        log('Received Linea response', lineaResponse);
+        const baseFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getValuesFromMultipliers).call(this, lineaResponse.baseFeePerGas, BASE_FEE_MULTIPLIERS);
+        log('Generated base fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, baseFees));
+        const priorityFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getValuesFromMultipliers).call(this, lineaResponse.priorityFeePerGas, PRIORITY_FEE_MULTIPLIERS);
+        log('Generated priority fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, priorityFees));
+        const maxFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getMaxFees).call(this, baseFees, priorityFees);
+        log('Generated max fees', __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_feesToString).call(this, maxFees));
+        const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: {
+                maxFeePerGas: (0, controller_utils_1.toHex)(maxFees[level]),
+                maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees[level]),
+            } })), {});
+        return { estimates };
+    });
+}, _LineaGasFeeFlow_getLineaResponse = function _LineaGasFeeFlow_getLineaResponse(transactionMeta, ethQuery) {
+    return (0, controller_utils_1.query)(ethQuery, 'linea_estimateGas', [
+        {
+            from: transactionMeta.txParams.from,
+            to: transactionMeta.txParams.to,
+            value: transactionMeta.txParams.value,
+            input: transactionMeta.txParams.data,
+            // Required in request but no impact on response.
+            gasPrice: '0x100000000',
+        },
+    ]);
+}, _LineaGasFeeFlow_getValuesFromMultipliers = function _LineaGasFeeFlow_getValuesFromMultipliers(value, multipliers) {
+    const base = (0, controller_utils_1.hexToBN)(value);
+    const low = base.muln(multipliers.low);
+    const medium = base.muln(multipliers.medium);
+    const high = base.muln(multipliers.high);
+    return {
+        low,
+        medium,
+        high,
+    };
+}, _LineaGasFeeFlow_getMaxFees = function _LineaGasFeeFlow_getMaxFees(baseFees, priorityFees) {
+    return {
+        low: baseFees.low.add(priorityFees.low),
+        medium: baseFees.medium.add(priorityFees.medium),
+        high: baseFees.high.add(priorityFees.high),
+    };
+}, _LineaGasFeeFlow_feesToString = function _LineaGasFeeFlow_feesToString(fees) {
+    return Object.values(types_1.GasFeeEstimateLevel).map((level) => fees[level].toString(10));
+};
+//# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/EtherscanRemoteTransactionSource.js b/dist/helpers/EtherscanRemoteTransactionSource.js
index 22a00a2d34123cf9e73c86ee28acc929a44a7bce..f40260e306dfc24f503081856035cbe05878700f 100644
--- a/dist/helpers/EtherscanRemoteTransactionSource.js
+++ b/dist/helpers/EtherscanRemoteTransactionSource.js
@@ -19,16 +19,21 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _EtherscanRemoteTransactionSource_instances, _EtherscanRemoteTransactionSource_includeTokenTransfers, _EtherscanRemoteTransactionSource_isTokenRequestPending, _EtherscanRemoteTransactionSource_fetchNormalTransactions, _EtherscanRemoteTransactionSource_fetchTokenTransactions, _EtherscanRemoteTransactionSource_getResponseTransactions, _EtherscanRemoteTransactionSource_normalizeTransaction, _EtherscanRemoteTransactionSource_normalizeTokenTransaction, _EtherscanRemoteTransactionSource_normalizeTransactionBase;
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _EtherscanRemoteTransactionSource_instances, _EtherscanRemoteTransactionSource_includeTokenTransfers, _EtherscanRemoteTransactionSource_isTokenRequestPending, _EtherscanRemoteTransactionSource_mutex, _EtherscanRemoteTransactionSource_releaseLockAfterInterval, _EtherscanRemoteTransactionSource_fetchNormalTransactions, _EtherscanRemoteTransactionSource_fetchTokenTransactions, _EtherscanRemoteTransactionSource_getResponseTransactions, _EtherscanRemoteTransactionSource_normalizeTransaction, _EtherscanRemoteTransactionSource_normalizeTokenTransaction, _EtherscanRemoteTransactionSource_normalizeTransactionBase;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.EtherscanRemoteTransactionSource = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
-const ethereumjs_util_1 = require("ethereumjs-util");
+const async_mutex_1 = require("async-mutex");
+const bn_js_1 = __importDefault(require("bn.js"));
 const uuid_1 = require("uuid");
 const constants_1 = require("../constants");
 const logger_1 = require("../logger");
 const types_1 = require("../types");
 const etherscan_1 = require("../utils/etherscan");
+const ETHERSCAN_RATE_LIMIT_INTERVAL = 5000;
 /**
  * A RemoteTransactionSource that fetches transaction data from Etherscan.
  */
@@ -37,6 +42,7 @@ class EtherscanRemoteTransactionSource {
         _EtherscanRemoteTransactionSource_instances.add(this);
         _EtherscanRemoteTransactionSource_includeTokenTransfers.set(this, void 0);
         _EtherscanRemoteTransactionSource_isTokenRequestPending.set(this, void 0);
+        _EtherscanRemoteTransactionSource_mutex.set(this, new async_mutex_1.Mutex());
         _EtherscanRemoteTransactionSource_fetchNormalTransactions.set(this, (request, etherscanRequest) => __awaiter(this, void 0, void 0, function* () {
             const { currentChainId } = request;
             const etherscanTransactions = yield (0, etherscan_1.fetchEtherscanTransactions)(etherscanRequest);
@@ -58,19 +64,36 @@ class EtherscanRemoteTransactionSource {
     }
     fetchTransactions(request) {
         return __awaiter(this, void 0, void 0, function* () {
+            const releaseLock = yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_mutex, "f").acquire();
+            const acquiredTime = Date.now();
             const etherscanRequest = Object.assign(Object.assign({}, request), { chainId: request.currentChainId });
-            const transactions = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f")
-                ? yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_fetchTokenTransactions, "f").call(this, request, etherscanRequest)
-                : yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_fetchNormalTransactions, "f").call(this, request, etherscanRequest);
-            if (__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, "f")) {
-                __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, !__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f"), "f");
+            try {
+                const transactions = __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f")
+                    ? yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_fetchTokenTransactions, "f").call(this, request, etherscanRequest)
+                    : yield __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_fetchNormalTransactions, "f").call(this, request, etherscanRequest);
+                if (__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_includeTokenTransfers, "f")) {
+                    __classPrivateFieldSet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, !__classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_isTokenRequestPending, "f"), "f");
+                }
+                return transactions;
+            }
+            finally {
+                __classPrivateFieldGet(this, _EtherscanRemoteTransactionSource_instances, "m", _EtherscanRemoteTransactionSource_releaseLockAfterInterval).call(this, acquiredTime, releaseLock);
             }
-            return transactions;
         });
     }
 }
 exports.EtherscanRemoteTransactionSource = EtherscanRemoteTransactionSource;
-_EtherscanRemoteTransactionSource_includeTokenTransfers = new WeakMap(), _EtherscanRemoteTransactionSource_isTokenRequestPending = new WeakMap(), _EtherscanRemoteTransactionSource_fetchNormalTransactions = new WeakMap(), _EtherscanRemoteTransactionSource_fetchTokenTransactions = new WeakMap(), _EtherscanRemoteTransactionSource_instances = new WeakSet(), _EtherscanRemoteTransactionSource_getResponseTransactions = function _EtherscanRemoteTransactionSource_getResponseTransactions(response) {
+_EtherscanRemoteTransactionSource_includeTokenTransfers = new WeakMap(), _EtherscanRemoteTransactionSource_isTokenRequestPending = new WeakMap(), _EtherscanRemoteTransactionSource_mutex = new WeakMap(), _EtherscanRemoteTransactionSource_fetchNormalTransactions = new WeakMap(), _EtherscanRemoteTransactionSource_fetchTokenTransactions = new WeakMap(), _EtherscanRemoteTransactionSource_instances = new WeakSet(), _EtherscanRemoteTransactionSource_releaseLockAfterInterval = function _EtherscanRemoteTransactionSource_releaseLockAfterInterval(acquireTime, releaseLock) {
+    const elapsedTime = Date.now() - acquireTime;
+    const remainingTime = Math.max(0, ETHERSCAN_RATE_LIMIT_INTERVAL - elapsedTime);
+    // Wait for the remaining time if it hasn't been 5 seconds yet
+    if (remainingTime > 0) {
+        setTimeout(releaseLock, remainingTime);
+    }
+    else {
+        releaseLock();
+    }
+}, _EtherscanRemoteTransactionSource_getResponseTransactions = function _EtherscanRemoteTransactionSource_getResponseTransactions(response) {
     let result = response.result;
     if (response.status === '0') {
         result = [];
@@ -109,12 +132,12 @@ _EtherscanRemoteTransactionSource_includeTokenTransfers = new WeakMap(), _Ethers
         txParams: {
             chainId: currentChainId,
             from: txMeta.from,
-            gas: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gas)),
-            gasPrice: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasPrice)),
-            gasUsed: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasUsed)),
-            nonce: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.nonce)),
+            gas: (0, controller_utils_1.BNToHex)(new bn_js_1.default(txMeta.gas)),
+            gasPrice: (0, controller_utils_1.BNToHex)(new bn_js_1.default(txMeta.gasPrice)),
+            gasUsed: (0, controller_utils_1.BNToHex)(new bn_js_1.default(txMeta.gasUsed)),
+            nonce: (0, controller_utils_1.BNToHex)(new bn_js_1.default(txMeta.nonce)),
             to: txMeta.to,
-            value: (0, controller_utils_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.value)),
+            value: (0, controller_utils_1.BNToHex)(new bn_js_1.default(txMeta.value)),
         },
         type: types_1.TransactionType.incoming,
         verifiedOnBlockchain: false,
diff --git a/dist/helpers/GasFeePoller.d.ts b/dist/helpers/GasFeePoller.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..95bb979bdfd5109e604d409e0708659deaf85840
--- /dev/null
+++ b/dist/helpers/GasFeePoller.d.ts
@@ -0,0 +1,32 @@
+/// <reference types="node" />
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import type { Hex } from '@metamask/utils';
+import EventEmitter from 'events';
+import type { NetworkClientId } from '../../../network-controller/src';
+import type { GasFeeFlow } from '../types';
+import { type TransactionMeta } from '../types';
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+export declare class GasFeePoller {
+    #private;
+    hub: EventEmitter;
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }: {
+        gasFeeFlows: GasFeeFlow[];
+        getEthQuery: (chainId: Hex, networkClientId?: NetworkClientId) => EthQuery;
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+        getTransactions: () => TransactionMeta[];
+        onStateChange: (listener: () => void) => void;
+    });
+}
+//# sourceMappingURL=GasFeePoller.d.ts.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.js b/dist/helpers/GasFeePoller.js
new file mode 100644
index 0000000000000000000000000000000000000000..c0ac2e7003664533eb2a4af143fa8eca656b2ee4
--- /dev/null
+++ b/dist/helpers/GasFeePoller.js
@@ -0,0 +1,144 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _GasFeePoller_instances, _GasFeePoller_gasFeeFlows, _GasFeePoller_getEthQuery, _GasFeePoller_getGasFeeControllerEstimates, _GasFeePoller_getTransactions, _GasFeePoller_timeout, _GasFeePoller_running, _GasFeePoller_start, _GasFeePoller_stop, _GasFeePoller_onTimeout, _GasFeePoller_updateUnapprovedTransactions, _GasFeePoller_updateTransactionSuggestedFees, _GasFeePoller_getUnapprovedTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeePoller = void 0;
+const utils_1 = require("@metamask/utils");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_flow_1 = require("../utils/gas-flow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-poller');
+const INTERVAL_MILLISECONDS = 10000;
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+class GasFeePoller {
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }) {
+        _GasFeePoller_instances.add(this);
+        this.hub = new events_1.default();
+        _GasFeePoller_gasFeeFlows.set(this, void 0);
+        _GasFeePoller_getEthQuery.set(this, void 0);
+        _GasFeePoller_getGasFeeControllerEstimates.set(this, void 0);
+        _GasFeePoller_getTransactions.set(this, void 0);
+        _GasFeePoller_timeout.set(this, void 0);
+        _GasFeePoller_running.set(this, false);
+        __classPrivateFieldSet(this, _GasFeePoller_gasFeeFlows, gasFeeFlows, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getTransactions, getTransactions, "f");
+        onStateChange(() => {
+            const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+            if (unapprovedTransactions.length) {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_stop).call(this);
+            }
+        });
+    }
+}
+exports.GasFeePoller = GasFeePoller;
+_GasFeePoller_gasFeeFlows = new WeakMap(), _GasFeePoller_getEthQuery = new WeakMap(), _GasFeePoller_getGasFeeControllerEstimates = new WeakMap(), _GasFeePoller_getTransactions = new WeakMap(), _GasFeePoller_timeout = new WeakMap(), _GasFeePoller_running = new WeakMap(), _GasFeePoller_instances = new WeakSet(), _GasFeePoller_start = function _GasFeePoller_start() {
+    if (__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    // Intentionally not awaiting since this starts the timeout chain.
+    // eslint-disable-next-line @typescript-eslint/no-floating-promises
+    __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this);
+    __classPrivateFieldSet(this, _GasFeePoller_running, true, "f");
+    log('Started polling');
+}, _GasFeePoller_stop = function _GasFeePoller_stop() {
+    if (!__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    clearTimeout(__classPrivateFieldGet(this, _GasFeePoller_timeout, "f"));
+    __classPrivateFieldSet(this, _GasFeePoller_timeout, undefined, "f");
+    __classPrivateFieldSet(this, _GasFeePoller_running, false, "f");
+    log('Stopped polling');
+}, _GasFeePoller_onTimeout = function _GasFeePoller_onTimeout() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateUnapprovedTransactions).call(this);
+        // eslint-disable-next-line @typescript-eslint/no-misused-promises
+        __classPrivateFieldSet(this, _GasFeePoller_timeout, setTimeout(() => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this), INTERVAL_MILLISECONDS), "f");
+    });
+}, _GasFeePoller_updateUnapprovedTransactions = function _GasFeePoller_updateUnapprovedTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+        log('Found unapproved transactions', {
+            count: unapprovedTransactions.length,
+        });
+        yield Promise.all(unapprovedTransactions.map((tx) => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateTransactionSuggestedFees).call(this, tx)));
+    });
+}, _GasFeePoller_updateTransactionSuggestedFees = function _GasFeePoller_updateTransactionSuggestedFees(transactionMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, networkClientId } = transactionMeta;
+        const ethQuery = __classPrivateFieldGet(this, _GasFeePoller_getEthQuery, "f").call(this, chainId, networkClientId);
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(transactionMeta, __classPrivateFieldGet(this, _GasFeePoller_gasFeeFlows, "f"));
+        if (!gasFeeFlow) {
+            log('No gas fee flow found', transactionMeta.id);
+        }
+        else {
+            log('Found gas fee flow', gasFeeFlow.constructor.name, transactionMeta.id);
+        }
+        const request = {
+            ethQuery,
+            getGasFeeControllerEstimates: __classPrivateFieldGet(this, _GasFeePoller_getGasFeeControllerEstimates, "f"),
+            transactionMeta,
+        };
+        let gasFeeEstimates;
+        if (gasFeeFlow) {
+            try {
+                const response = yield gasFeeFlow.getGasFees(request);
+                gasFeeEstimates = response.estimates;
+            }
+            catch (error) {
+                log('Failed to get suggested gas fees', transactionMeta.id, error);
+            }
+        }
+        if (!gasFeeEstimates && transactionMeta.gasFeeEstimatesLoaded) {
+            return;
+        }
+        transactionMeta.gasFeeEstimates = gasFeeEstimates;
+        transactionMeta.gasFeeEstimatesLoaded = true;
+        this.hub.emit('transaction-updated', transactionMeta);
+        log('Updated suggested gas fees', {
+            gasFeeEstimates: transactionMeta.gasFeeEstimates,
+            transaction: transactionMeta.id,
+        });
+    });
+}, _GasFeePoller_getUnapprovedTransactions = function _GasFeePoller_getUnapprovedTransactions() {
+    return __classPrivateFieldGet(this, _GasFeePoller_getTransactions, "f").call(this).filter((tx) => tx.status === types_1.TransactionStatus.unapproved);
+};
+//# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/dist/helpers/IncomingTransactionHelper.d.ts b/dist/helpers/IncomingTransactionHelper.d.ts
index 3716ebff171b4396260b35693419e9f3a9da08bc..8c91971d214bd9a0bdb09cd3b807ffbbc4d78d35 100644
--- a/dist/helpers/IncomingTransactionHelper.d.ts
+++ b/dist/helpers/IncomingTransactionHelper.d.ts
@@ -1,17 +1,31 @@
 /// <reference types="node" />
-import type { BlockTracker, NetworkState } from '@metamask/network-controller';
+import type { BlockTracker } from '@metamask/network-controller';
 import type { Hex } from '@metamask/utils';
 import EventEmitter from 'events';
 import type { RemoteTransactionSource, TransactionMeta } from '../types';
+/**
+ * Configuration options for the IncomingTransactionHelper
+ *
+ * @property includeTokenTransfers - Whether or not to include ERC20 token transfers.
+ * @property isEnabled - Whether or not incoming transaction retrieval is enabled.
+ * @property queryEntireHistory - Whether to initially query the entire transaction history or only recent blocks.
+ * @property updateTransactions - Whether to update local transactions using remote transaction data.
+ */
+export declare type IncomingTransactionOptions = {
+    includeTokenTransfers?: boolean;
+    isEnabled?: () => boolean;
+    queryEntireHistory?: boolean;
+    updateTransactions?: boolean;
+};
 export declare class IncomingTransactionHelper {
     #private;
     hub: EventEmitter;
-    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, queryEntireHistory, remoteTransactionSource, transactionLimit, updateTransactions, }: {
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getChainId, isEnabled, queryEntireHistory, remoteTransactionSource, transactionLimit, updateTransactions, }: {
         blockTracker: BlockTracker;
         getCurrentAccount: () => string;
         getLastFetchedBlockNumbers: () => Record<string, number>;
         getLocalTransactions?: () => TransactionMeta[];
-        getNetworkState: () => NetworkState;
+        getChainId: () => Hex;
         isEnabled?: () => boolean;
         queryEntireHistory?: boolean;
         remoteTransactionSource: RemoteTransactionSource;
diff --git a/dist/helpers/IncomingTransactionHelper.js b/dist/helpers/IncomingTransactionHelper.js
index 3c93cb1671d4dd46c414566b823e7649f97b95c4..8eb7d6e41423f7ba5e378dd385a92cae17d3d42b 100644
--- a/dist/helpers/IncomingTransactionHelper.js
+++ b/dist/helpers/IncomingTransactionHelper.js
@@ -22,7 +22,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _IncomingTransactionHelper_instances, _IncomingTransactionHelper_blockTracker, _IncomingTransactionHelper_getCurrentAccount, _IncomingTransactionHelper_getLastFetchedBlockNumbers, _IncomingTransactionHelper_getLocalTransactions, _IncomingTransactionHelper_getNetworkState, _IncomingTransactionHelper_isEnabled, _IncomingTransactionHelper_isRunning, _IncomingTransactionHelper_mutex, _IncomingTransactionHelper_onLatestBlock, _IncomingTransactionHelper_queryEntireHistory, _IncomingTransactionHelper_remoteTransactionSource, _IncomingTransactionHelper_transactionLimit, _IncomingTransactionHelper_updateTransactions, _IncomingTransactionHelper_sortTransactionsByTime, _IncomingTransactionHelper_getNewTransactions, _IncomingTransactionHelper_getUpdatedTransactions, _IncomingTransactionHelper_isTransactionOutdated, _IncomingTransactionHelper_getFromBlock, _IncomingTransactionHelper_updateLastFetchedBlockNumber, _IncomingTransactionHelper_getBlockNumberKey, _IncomingTransactionHelper_canStart, _IncomingTransactionHelper_getCurrentChainId;
+var _IncomingTransactionHelper_instances, _IncomingTransactionHelper_blockTracker, _IncomingTransactionHelper_getCurrentAccount, _IncomingTransactionHelper_getLastFetchedBlockNumbers, _IncomingTransactionHelper_getLocalTransactions, _IncomingTransactionHelper_getChainId, _IncomingTransactionHelper_isEnabled, _IncomingTransactionHelper_isRunning, _IncomingTransactionHelper_mutex, _IncomingTransactionHelper_onLatestBlock, _IncomingTransactionHelper_queryEntireHistory, _IncomingTransactionHelper_remoteTransactionSource, _IncomingTransactionHelper_transactionLimit, _IncomingTransactionHelper_updateTransactions, _IncomingTransactionHelper_sortTransactionsByTime, _IncomingTransactionHelper_getNewTransactions, _IncomingTransactionHelper_getUpdatedTransactions, _IncomingTransactionHelper_isTransactionOutdated, _IncomingTransactionHelper_getLastFetchedBlockNumberDec, _IncomingTransactionHelper_getFromBlock, _IncomingTransactionHelper_updateLastFetchedBlockNumber, _IncomingTransactionHelper_getBlockNumberKey, _IncomingTransactionHelper_canStart;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.IncomingTransactionHelper = void 0;
 const async_mutex_1 = require("async-mutex");
@@ -36,13 +36,13 @@ const UPDATE_CHECKS = [
     (txMeta) => txMeta.txParams.gasUsed,
 ];
 class IncomingTransactionHelper {
-    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getNetworkState, isEnabled, queryEntireHistory, remoteTransactionSource, transactionLimit, updateTransactions, }) {
+    constructor({ blockTracker, getCurrentAccount, getLastFetchedBlockNumbers, getLocalTransactions, getChainId, isEnabled, queryEntireHistory, remoteTransactionSource, transactionLimit, updateTransactions, }) {
         _IncomingTransactionHelper_instances.add(this);
         _IncomingTransactionHelper_blockTracker.set(this, void 0);
         _IncomingTransactionHelper_getCurrentAccount.set(this, void 0);
         _IncomingTransactionHelper_getLastFetchedBlockNumbers.set(this, void 0);
         _IncomingTransactionHelper_getLocalTransactions.set(this, void 0);
-        _IncomingTransactionHelper_getNetworkState.set(this, void 0);
+        _IncomingTransactionHelper_getChainId.set(this, void 0);
         _IncomingTransactionHelper_isEnabled.set(this, void 0);
         _IncomingTransactionHelper_isRunning.set(this, void 0);
         _IncomingTransactionHelper_mutex.set(this, new async_mutex_1.Mutex());
@@ -56,7 +56,7 @@ class IncomingTransactionHelper {
         __classPrivateFieldSet(this, _IncomingTransactionHelper_getCurrentAccount, getCurrentAccount, "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, getLastFetchedBlockNumbers, "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_getLocalTransactions, getLocalTransactions || (() => []), "f");
-        __classPrivateFieldSet(this, _IncomingTransactionHelper_getNetworkState, getNetworkState, "f");
+        __classPrivateFieldSet(this, _IncomingTransactionHelper_getChainId, getChainId, "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_isEnabled, isEnabled !== null && isEnabled !== void 0 ? isEnabled : (() => true), "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_isRunning, false, "f");
         __classPrivateFieldSet(this, _IncomingTransactionHelper_queryEntireHistory, queryEntireHistory !== null && queryEntireHistory !== void 0 ? queryEntireHistory : true, "f");
@@ -99,9 +99,9 @@ class IncomingTransactionHelper {
                 }
                 const latestBlockNumber = parseInt(latestBlockNumberHex || (yield __classPrivateFieldGet(this, _IncomingTransactionHelper_blockTracker, "f").getLatestBlock()), 16);
                 const additionalLastFetchedKeys = (_c = (_b = (_a = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f")).getLastBlockVariations) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];
-                const fromBlock = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getFromBlock).call(this, latestBlockNumber, additionalLastFetchedKeys);
+                const fromBlock = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getFromBlock).call(this, latestBlockNumber);
                 const address = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this);
-                const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+                const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_getChainId, "f").call(this);
                 let remoteTransactions = [];
                 try {
                     remoteTransactions =
@@ -147,7 +147,7 @@ class IncomingTransactionHelper {
     }
 }
 exports.IncomingTransactionHelper = IncomingTransactionHelper;
-_IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHelper_getCurrentAccount = new WeakMap(), _IncomingTransactionHelper_getLastFetchedBlockNumbers = new WeakMap(), _IncomingTransactionHelper_getLocalTransactions = new WeakMap(), _IncomingTransactionHelper_getNetworkState = new WeakMap(), _IncomingTransactionHelper_isEnabled = new WeakMap(), _IncomingTransactionHelper_isRunning = new WeakMap(), _IncomingTransactionHelper_mutex = new WeakMap(), _IncomingTransactionHelper_onLatestBlock = new WeakMap(), _IncomingTransactionHelper_queryEntireHistory = new WeakMap(), _IncomingTransactionHelper_remoteTransactionSource = new WeakMap(), _IncomingTransactionHelper_transactionLimit = new WeakMap(), _IncomingTransactionHelper_updateTransactions = new WeakMap(), _IncomingTransactionHelper_instances = new WeakSet(), _IncomingTransactionHelper_sortTransactionsByTime = function _IncomingTransactionHelper_sortTransactionsByTime(transactions) {
+_IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHelper_getCurrentAccount = new WeakMap(), _IncomingTransactionHelper_getLastFetchedBlockNumbers = new WeakMap(), _IncomingTransactionHelper_getLocalTransactions = new WeakMap(), _IncomingTransactionHelper_getChainId = new WeakMap(), _IncomingTransactionHelper_isEnabled = new WeakMap(), _IncomingTransactionHelper_isRunning = new WeakMap(), _IncomingTransactionHelper_mutex = new WeakMap(), _IncomingTransactionHelper_onLatestBlock = new WeakMap(), _IncomingTransactionHelper_queryEntireHistory = new WeakMap(), _IncomingTransactionHelper_remoteTransactionSource = new WeakMap(), _IncomingTransactionHelper_transactionLimit = new WeakMap(), _IncomingTransactionHelper_updateTransactions = new WeakMap(), _IncomingTransactionHelper_instances = new WeakSet(), _IncomingTransactionHelper_sortTransactionsByTime = function _IncomingTransactionHelper_sortTransactionsByTime(transactions) {
     transactions.sort((a, b) => (a.time < b.time ? -1 : 1));
 }, _IncomingTransactionHelper_getNewTransactions = function _IncomingTransactionHelper_getNewTransactions(remoteTxs, localTxs) {
     return remoteTxs.filter((tx) => !localTxs.some(({ hash }) => hash === tx.hash));
@@ -156,9 +156,14 @@ _IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHel
         __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_isTransactionOutdated).call(this, remoteTx, localTx)));
 }, _IncomingTransactionHelper_isTransactionOutdated = function _IncomingTransactionHelper_isTransactionOutdated(remoteTx, localTx) {
     return UPDATE_CHECKS.some((getValue) => getValue(remoteTx) !== getValue(localTx));
-}, _IncomingTransactionHelper_getFromBlock = function _IncomingTransactionHelper_getFromBlock(latestBlockNumber, additionalKeys) {
-    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this, additionalKeys);
-    const lastFetchedBlockNumber = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this)[lastFetchedKey];
+}, _IncomingTransactionHelper_getLastFetchedBlockNumberDec = function _IncomingTransactionHelper_getLastFetchedBlockNumberDec() {
+    var _a, _b, _c;
+    const additionalLastFetchedKeys = (_c = (_b = (_a = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f")).getLastBlockVariations) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];
+    const lastFetchedKey = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getBlockNumberKey).call(this, additionalLastFetchedKeys);
+    const lastFetchedBlockNumbers = __classPrivateFieldGet(this, _IncomingTransactionHelper_getLastFetchedBlockNumbers, "f").call(this);
+    return lastFetchedBlockNumbers[lastFetchedKey];
+}, _IncomingTransactionHelper_getFromBlock = function _IncomingTransactionHelper_getFromBlock(latestBlockNumber) {
+    const lastFetchedBlockNumber = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getLastFetchedBlockNumberDec).call(this);
     if (lastFetchedBlockNumber) {
         return lastFetchedBlockNumber + 1;
     }
@@ -189,15 +194,13 @@ _IncomingTransactionHelper_blockTracker = new WeakMap(), _IncomingTransactionHel
     });
 }, _IncomingTransactionHelper_getBlockNumberKey = function _IncomingTransactionHelper_getBlockNumberKey(additionalKeys) {
     var _a;
-    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_getChainId, "f").call(this);
     const currentAccount = (_a = __classPrivateFieldGet(this, _IncomingTransactionHelper_getCurrentAccount, "f").call(this)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
     return [currentChainId, currentAccount, ...additionalKeys].join('#');
 }, _IncomingTransactionHelper_canStart = function _IncomingTransactionHelper_canStart() {
     const isEnabled = __classPrivateFieldGet(this, _IncomingTransactionHelper_isEnabled, "f").call(this);
-    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_instances, "m", _IncomingTransactionHelper_getCurrentChainId).call(this);
+    const currentChainId = __classPrivateFieldGet(this, _IncomingTransactionHelper_getChainId, "f").call(this);
     const isSupportedNetwork = __classPrivateFieldGet(this, _IncomingTransactionHelper_remoteTransactionSource, "f").isSupportedNetwork(currentChainId);
     return isEnabled && isSupportedNetwork;
-}, _IncomingTransactionHelper_getCurrentChainId = function _IncomingTransactionHelper_getCurrentChainId() {
-    return __classPrivateFieldGet(this, _IncomingTransactionHelper_getNetworkState, "f").call(this).providerConfig.chainId;
 };
 //# sourceMappingURL=IncomingTransactionHelper.js.map
\ No newline at end of file
diff --git a/dist/helpers/MultichainTrackingHelper.d.ts b/dist/helpers/MultichainTrackingHelper.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..054196422567b24a90998f67bd7f9d685ac6c344
--- /dev/null
+++ b/dist/helpers/MultichainTrackingHelper.d.ts
@@ -0,0 +1,72 @@
+import EthQuery from '@metamask/eth-query';
+import type { NetworkClientId, NetworkController, BlockTracker, Provider, NetworkControllerStateChangeEvent } from '@metamask/network-controller';
+import type { Hex } from '@metamask/utils';
+import type { NonceLock, NonceTracker } from 'nonce-tracker';
+import { EtherscanRemoteTransactionSource } from './EtherscanRemoteTransactionSource';
+import type { IncomingTransactionHelper, IncomingTransactionOptions } from './IncomingTransactionHelper';
+import type { PendingTransactionTracker } from './PendingTransactionTracker';
+export declare type MultichainTrackingHelperOptions = {
+    isMultichainEnabled: boolean;
+    provider: Provider;
+    nonceTracker: NonceTracker;
+    incomingTransactionOptions: IncomingTransactionOptions;
+    findNetworkClientIdByChainId: NetworkController['findNetworkClientIdByChainId'];
+    getNetworkClientById: NetworkController['getNetworkClientById'];
+    getNetworkClientRegistry: NetworkController['getNetworkClientRegistry'];
+    removeIncomingTransactionHelperListeners: (IncomingTransactionHelper: IncomingTransactionHelper) => void;
+    removePendingTransactionTrackerListeners: (pendingTransactionTracker: PendingTransactionTracker) => void;
+    createNonceTracker: (opts: {
+        provider: Provider;
+        blockTracker: BlockTracker;
+        chainId?: Hex;
+    }) => NonceTracker;
+    createIncomingTransactionHelper: (opts: {
+        blockTracker: BlockTracker;
+        etherscanRemoteTransactionSource: EtherscanRemoteTransactionSource;
+        chainId?: Hex;
+    }) => IncomingTransactionHelper;
+    createPendingTransactionTracker: (opts: {
+        provider: Provider;
+        blockTracker: BlockTracker;
+        chainId?: Hex;
+    }) => PendingTransactionTracker;
+    onNetworkStateChange: (listener: (...payload: NetworkControllerStateChangeEvent['payload']) => void) => void;
+};
+export declare class MultichainTrackingHelper {
+    #private;
+    constructor({ isMultichainEnabled, provider, nonceTracker, incomingTransactionOptions, findNetworkClientIdByChainId, getNetworkClientById, getNetworkClientRegistry, removeIncomingTransactionHelperListeners, removePendingTransactionTrackerListeners, createNonceTracker, createIncomingTransactionHelper, createPendingTransactionTracker, onNetworkStateChange, }: MultichainTrackingHelperOptions);
+    initialize(): void;
+    has(networkClientId: NetworkClientId): boolean;
+    getEthQuery({ networkClientId, chainId, }?: {
+        networkClientId?: NetworkClientId;
+        chainId?: Hex;
+    }): EthQuery;
+    /**
+     * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .
+     *
+     * @param opts - The options object.
+     * @param opts.chainId - The hex chainId.
+     * @param opts.key - The hex address (or constant) pertaining to the chainId
+     * @returns Mutex instance for the given chainId and key pair
+     */
+    acquireNonceLockForChainIdKey({ chainId, key, }: {
+        chainId: Hex;
+        key?: string;
+    }): Promise<() => void>;
+    /**
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
+     *
+     * @param address - The hex string address for the transaction.
+     * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
+     */
+    getNonceLock(address: string, networkClientId?: NetworkClientId): Promise<NonceLock>;
+    startIncomingTransactionPolling(networkClientIds?: NetworkClientId[]): void;
+    stopIncomingTransactionPolling(networkClientIds?: NetworkClientId[]): void;
+    stopAllIncomingTransactionPolling(): void;
+    updateIncomingTransactions(networkClientIds?: NetworkClientId[]): Promise<void>;
+    checkForPendingTransactionAndStartPolling: () => void;
+    stopAllTracking(): void;
+}
+//# sourceMappingURL=MultichainTrackingHelper.d.ts.map
\ No newline at end of file
diff --git a/dist/helpers/MultichainTrackingHelper.js b/dist/helpers/MultichainTrackingHelper.js
new file mode 100644
index 0000000000000000000000000000000000000000..237e8a0625b8cbaf855079b35425c8df415d8a55
--- /dev/null
+++ b/dist/helpers/MultichainTrackingHelper.js
@@ -0,0 +1,292 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _MultichainTrackingHelper_instances, _MultichainTrackingHelper_isMultichainEnabled, _MultichainTrackingHelper_provider, _MultichainTrackingHelper_nonceTracker, _MultichainTrackingHelper_incomingTransactionOptions, _MultichainTrackingHelper_findNetworkClientIdByChainId, _MultichainTrackingHelper_getNetworkClientById, _MultichainTrackingHelper_getNetworkClientRegistry, _MultichainTrackingHelper_removeIncomingTransactionHelperListeners, _MultichainTrackingHelper_removePendingTransactionTrackerListeners, _MultichainTrackingHelper_createNonceTracker, _MultichainTrackingHelper_createIncomingTransactionHelper, _MultichainTrackingHelper_createPendingTransactionTracker, _MultichainTrackingHelper_nonceMutexesByChainId, _MultichainTrackingHelper_trackingMap, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, _MultichainTrackingHelper_refreshTrackingMap, _MultichainTrackingHelper_stopTrackingByNetworkClientId, _MultichainTrackingHelper_startTrackingByNetworkClientId, _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MultichainTrackingHelper = void 0;
+const eth_query_1 = __importDefault(require("@metamask/eth-query"));
+const async_mutex_1 = require("async-mutex");
+const logger_1 = require("../logger");
+const EtherscanRemoteTransactionSource_1 = require("./EtherscanRemoteTransactionSource");
+class MultichainTrackingHelper {
+    constructor({ isMultichainEnabled, provider, nonceTracker, incomingTransactionOptions, findNetworkClientIdByChainId, getNetworkClientById, getNetworkClientRegistry, removeIncomingTransactionHelperListeners, removePendingTransactionTrackerListeners, createNonceTracker, createIncomingTransactionHelper, createPendingTransactionTracker, onNetworkStateChange, }) {
+        _MultichainTrackingHelper_instances.add(this);
+        _MultichainTrackingHelper_isMultichainEnabled.set(this, void 0);
+        _MultichainTrackingHelper_provider.set(this, void 0);
+        _MultichainTrackingHelper_nonceTracker.set(this, void 0);
+        _MultichainTrackingHelper_incomingTransactionOptions.set(this, void 0);
+        _MultichainTrackingHelper_findNetworkClientIdByChainId.set(this, void 0);
+        _MultichainTrackingHelper_getNetworkClientById.set(this, void 0);
+        _MultichainTrackingHelper_getNetworkClientRegistry.set(this, void 0);
+        _MultichainTrackingHelper_removeIncomingTransactionHelperListeners.set(this, void 0);
+        _MultichainTrackingHelper_removePendingTransactionTrackerListeners.set(this, void 0);
+        _MultichainTrackingHelper_createNonceTracker.set(this, void 0);
+        _MultichainTrackingHelper_createIncomingTransactionHelper.set(this, void 0);
+        _MultichainTrackingHelper_createPendingTransactionTracker.set(this, void 0);
+        _MultichainTrackingHelper_nonceMutexesByChainId.set(this, new Map());
+        _MultichainTrackingHelper_trackingMap.set(this, new Map());
+        _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap.set(this, new Map());
+        this.checkForPendingTransactionAndStartPolling = () => {
+            for (const [, trackers] of __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")) {
+                trackers.pendingTransactionTracker.startIfPendingTransactions();
+            }
+        };
+        _MultichainTrackingHelper_refreshTrackingMap.set(this, (networkClients) => {
+            __classPrivateFieldGet(this, _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources, "f").call(this, networkClients);
+            const networkClientIds = Object.keys(networkClients);
+            const existingNetworkClientIds = Array.from(__classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").keys());
+            // Remove tracking for NetworkClientIds that no longer exist
+            const networkClientIdsToRemove = existingNetworkClientIds.filter((id) => !networkClientIds.includes(id));
+            networkClientIdsToRemove.forEach((id) => {
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_instances, "m", _MultichainTrackingHelper_stopTrackingByNetworkClientId).call(this, id);
+            });
+            // Start tracking new NetworkClientIds from the registry
+            const networkClientIdsToAdd = networkClientIds.filter((id) => !existingNetworkClientIds.includes(id));
+            networkClientIdsToAdd.forEach((id) => {
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_instances, "m", _MultichainTrackingHelper_startTrackingByNetworkClientId).call(this, id);
+            });
+        });
+        _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources.set(this, (networkClients) => {
+            // this will be prettier when we have consolidated network clients with a single chainId:
+            // check if there are still other network clients using the same chainId
+            // if not remove the etherscanRemoteTransaction source from the map
+            const chainIdsInRegistry = new Set();
+            Object.values(networkClients).forEach((networkClient) => chainIdsInRegistry.add(networkClient.configuration.chainId));
+            const existingChainIds = Array.from(__classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").keys());
+            const chainIdsToRemove = existingChainIds.filter((chainId) => !chainIdsInRegistry.has(chainId));
+            chainIdsToRemove.forEach((chainId) => {
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").delete(chainId);
+            });
+        });
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_isMultichainEnabled, isMultichainEnabled, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_provider, provider, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_nonceTracker, nonceTracker, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_incomingTransactionOptions, incomingTransactionOptions, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_findNetworkClientIdByChainId, findNetworkClientIdByChainId, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_getNetworkClientById, getNetworkClientById, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_getNetworkClientRegistry, getNetworkClientRegistry, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_createNonceTracker, createNonceTracker, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_createIncomingTransactionHelper, createIncomingTransactionHelper, "f");
+        __classPrivateFieldSet(this, _MultichainTrackingHelper_createPendingTransactionTracker, createPendingTransactionTracker, "f");
+        onNetworkStateChange((_, patches) => {
+            if (__classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+                const networkClients = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientRegistry, "f").call(this);
+                patches.forEach(({ op, path }) => {
+                    if (op === 'remove' && path[0] === 'networkConfigurations') {
+                        const networkClientId = path[1];
+                        delete networkClients[networkClientId];
+                    }
+                });
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_refreshTrackingMap, "f").call(this, networkClients);
+            }
+        });
+    }
+    initialize() {
+        if (!__classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+            return;
+        }
+        const networkClients = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientRegistry, "f").call(this);
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_refreshTrackingMap, "f").call(this, networkClients);
+    }
+    has(networkClientId) {
+        return __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").has(networkClientId);
+    }
+    getEthQuery({ networkClientId, chainId, } = {}) {
+        if (!__classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+            return new eth_query_1.default(__classPrivateFieldGet(this, _MultichainTrackingHelper_provider, "f"));
+        }
+        let networkClient;
+        if (networkClientId) {
+            try {
+                networkClient = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+            }
+            catch (err) {
+                (0, logger_1.incomingTransactionsLogger)('failed to get network client by networkClientId');
+            }
+        }
+        if (!networkClient && chainId) {
+            try {
+                networkClientId = __classPrivateFieldGet(this, _MultichainTrackingHelper_findNetworkClientIdByChainId, "f").call(this, chainId);
+                networkClient = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+            }
+            catch (err) {
+                (0, logger_1.incomingTransactionsLogger)('failed to get network client by chainId');
+            }
+        }
+        if (networkClient) {
+            return new eth_query_1.default(networkClient.provider);
+        }
+        // NOTE(JL): we're not ready to drop globally selected ethQuery yet.
+        // Some calls to getEthQuery only have access to optional networkClientId
+        // throw new Error('failed to get eth query instance');
+        return new eth_query_1.default(__classPrivateFieldGet(this, _MultichainTrackingHelper_provider, "f"));
+    }
+    /**
+     * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .
+     *
+     * @param opts - The options object.
+     * @param opts.chainId - The hex chainId.
+     * @param opts.key - The hex address (or constant) pertaining to the chainId
+     * @returns Mutex instance for the given chainId and key pair
+     */
+    acquireNonceLockForChainIdKey({ chainId, key = 'global', }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let nonceMutexesForChainId = __classPrivateFieldGet(this, _MultichainTrackingHelper_nonceMutexesByChainId, "f").get(chainId);
+            if (!nonceMutexesForChainId) {
+                nonceMutexesForChainId = new Map();
+                __classPrivateFieldGet(this, _MultichainTrackingHelper_nonceMutexesByChainId, "f").set(chainId, nonceMutexesForChainId);
+            }
+            let nonceMutexForKey = nonceMutexesForChainId.get(key);
+            if (!nonceMutexForKey) {
+                nonceMutexForKey = new async_mutex_1.Mutex();
+                nonceMutexesForChainId.set(key, nonceMutexForKey);
+            }
+            return yield nonceMutexForKey.acquire();
+        });
+    }
+    /**
+     * Gets the next nonce according to the nonce-tracker.
+     * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
+     *
+     * @param address - The hex string address for the transaction.
+     * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.
+     * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
+     */
+    getNonceLock(address, networkClientId) {
+        return __awaiter(this, void 0, void 0, function* () {
+            let releaseLockForChainIdKey;
+            let nonceTracker = __classPrivateFieldGet(this, _MultichainTrackingHelper_nonceTracker, "f");
+            if (networkClientId && __classPrivateFieldGet(this, _MultichainTrackingHelper_isMultichainEnabled, "f")) {
+                const networkClient = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+                releaseLockForChainIdKey = yield this.acquireNonceLockForChainIdKey({
+                    chainId: networkClient.configuration.chainId,
+                    key: address,
+                });
+                const trackers = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId);
+                if (!trackers) {
+                    throw new Error('missing nonceTracker for networkClientId');
+                }
+                nonceTracker = trackers.nonceTracker;
+            }
+            // Acquires the lock for the chainId + address and the nonceLock from the nonceTracker, then
+            // couples them together by replacing the nonceLock's releaseLock method with
+            // an anonymous function that calls releases both the original nonceLock and the
+            // lock for the chainId.
+            try {
+                const nonceLock = yield nonceTracker.getNonceLock(address);
+                return Object.assign(Object.assign({}, nonceLock), { releaseLock: () => {
+                        nonceLock.releaseLock();
+                        releaseLockForChainIdKey === null || releaseLockForChainIdKey === void 0 ? void 0 : releaseLockForChainIdKey();
+                    } });
+            }
+            catch (err) {
+                releaseLockForChainIdKey === null || releaseLockForChainIdKey === void 0 ? void 0 : releaseLockForChainIdKey();
+                throw err;
+            }
+        });
+    }
+    startIncomingTransactionPolling(networkClientIds = []) {
+        networkClientIds.forEach((networkClientId) => {
+            var _a;
+            (_a = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId)) === null || _a === void 0 ? void 0 : _a.incomingTransactionHelper.start();
+        });
+    }
+    stopIncomingTransactionPolling(networkClientIds = []) {
+        networkClientIds.forEach((networkClientId) => {
+            var _a;
+            (_a = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId)) === null || _a === void 0 ? void 0 : _a.incomingTransactionHelper.stop();
+        });
+    }
+    stopAllIncomingTransactionPolling() {
+        for (const [, trackers] of __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")) {
+            trackers.incomingTransactionHelper.stop();
+        }
+    }
+    updateIncomingTransactions(networkClientIds = []) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const promises = yield Promise.allSettled(networkClientIds.map((networkClientId) => __awaiter(this, void 0, void 0, function* () {
+                var _a;
+                return yield ((_a = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")
+                    .get(networkClientId)) === null || _a === void 0 ? void 0 : _a.incomingTransactionHelper.update());
+            })));
+            promises
+                .filter((result) => result.status === 'rejected')
+                .forEach((result) => {
+                (0, logger_1.incomingTransactionsLogger)('failed to update incoming transactions', result.reason);
+            });
+        });
+    }
+    stopAllTracking() {
+        for (const [networkClientId] of __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f")) {
+            __classPrivateFieldGet(this, _MultichainTrackingHelper_instances, "m", _MultichainTrackingHelper_stopTrackingByNetworkClientId).call(this, networkClientId);
+        }
+    }
+}
+exports.MultichainTrackingHelper = MultichainTrackingHelper;
+_MultichainTrackingHelper_isMultichainEnabled = new WeakMap(), _MultichainTrackingHelper_provider = new WeakMap(), _MultichainTrackingHelper_nonceTracker = new WeakMap(), _MultichainTrackingHelper_incomingTransactionOptions = new WeakMap(), _MultichainTrackingHelper_findNetworkClientIdByChainId = new WeakMap(), _MultichainTrackingHelper_getNetworkClientById = new WeakMap(), _MultichainTrackingHelper_getNetworkClientRegistry = new WeakMap(), _MultichainTrackingHelper_removeIncomingTransactionHelperListeners = new WeakMap(), _MultichainTrackingHelper_removePendingTransactionTrackerListeners = new WeakMap(), _MultichainTrackingHelper_createNonceTracker = new WeakMap(), _MultichainTrackingHelper_createIncomingTransactionHelper = new WeakMap(), _MultichainTrackingHelper_createPendingTransactionTracker = new WeakMap(), _MultichainTrackingHelper_nonceMutexesByChainId = new WeakMap(), _MultichainTrackingHelper_trackingMap = new WeakMap(), _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap = new WeakMap(), _MultichainTrackingHelper_refreshTrackingMap = new WeakMap(), _MultichainTrackingHelper_refreshEtherscanRemoteTransactionSources = new WeakMap(), _MultichainTrackingHelper_instances = new WeakSet(), _MultichainTrackingHelper_stopTrackingByNetworkClientId = function _MultichainTrackingHelper_stopTrackingByNetworkClientId(networkClientId) {
+    const trackers = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId);
+    if (trackers) {
+        trackers.pendingTransactionTracker.stop();
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_removePendingTransactionTrackerListeners, "f").call(this, trackers.pendingTransactionTracker);
+        trackers.incomingTransactionHelper.stop();
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_removeIncomingTransactionHelperListeners, "f").call(this, trackers.incomingTransactionHelper);
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").delete(networkClientId);
+    }
+}, _MultichainTrackingHelper_startTrackingByNetworkClientId = function _MultichainTrackingHelper_startTrackingByNetworkClientId(networkClientId) {
+    const trackers = __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").get(networkClientId);
+    if (trackers) {
+        return;
+    }
+    const { provider, blockTracker, configuration: { chainId }, } = __classPrivateFieldGet(this, _MultichainTrackingHelper_getNetworkClientById, "f").call(this, networkClientId);
+    let etherscanRemoteTransactionSource = __classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").get(chainId);
+    if (!etherscanRemoteTransactionSource) {
+        etherscanRemoteTransactionSource = new EtherscanRemoteTransactionSource_1.EtherscanRemoteTransactionSource({
+            includeTokenTransfers: __classPrivateFieldGet(this, _MultichainTrackingHelper_incomingTransactionOptions, "f").includeTokenTransfers,
+        });
+        __classPrivateFieldGet(this, _MultichainTrackingHelper_etherscanRemoteTransactionSourcesMap, "f").set(chainId, etherscanRemoteTransactionSource);
+    }
+    const nonceTracker = __classPrivateFieldGet(this, _MultichainTrackingHelper_createNonceTracker, "f").call(this, {
+        provider,
+        blockTracker,
+        chainId,
+    });
+    const incomingTransactionHelper = __classPrivateFieldGet(this, _MultichainTrackingHelper_createIncomingTransactionHelper, "f").call(this, {
+        blockTracker,
+        etherscanRemoteTransactionSource,
+        chainId,
+    });
+    const pendingTransactionTracker = __classPrivateFieldGet(this, _MultichainTrackingHelper_createPendingTransactionTracker, "f").call(this, {
+        provider,
+        blockTracker,
+        chainId,
+    });
+    __classPrivateFieldGet(this, _MultichainTrackingHelper_trackingMap, "f").set(networkClientId, {
+        nonceTracker,
+        incomingTransactionHelper,
+        pendingTransactionTracker,
+    });
+};
+//# sourceMappingURL=MultichainTrackingHelper.js.map
\ No newline at end of file
diff --git a/dist/helpers/PendingTransactionTracker.d.ts b/dist/helpers/PendingTransactionTracker.d.ts
index ea04e2f7910f94eddb7fe0da2c9b3412f17afecd..3d05faf1d5004dc11fe3adb9a42ac1f186871f29 100644
--- a/dist/helpers/PendingTransactionTracker.d.ts
+++ b/dist/helpers/PendingTransactionTracker.d.ts
@@ -1,8 +1,7 @@
 /// <reference types="node" />
 import type EthQuery from '@metamask/eth-query';
-import type { BlockTracker } from '@metamask/network-controller';
+import type { BlockTracker, NetworkClientId } from '@metamask/network-controller';
 import EventEmitter from 'events';
-import type { NonceTracker } from 'nonce-tracker';
 import type { TransactionMeta } from '../types';
 declare type Events = {
     'transaction-confirmed': [txMeta: TransactionMeta];
@@ -17,27 +16,28 @@ export interface PendingTransactionTrackerEventEmitter extends EventEmitter {
 export declare class PendingTransactionTracker {
     #private;
     hub: PendingTransactionTrackerEventEmitter;
-    constructor({ approveTransaction, blockTracker, getChainId, getEthQuery, getTransactions, isResubmitEnabled, nonceTracker, onStateChange, publishTransaction, hooks, }: {
+    constructor({ approveTransaction, blockTracker, getChainId, getEthQuery, getTransactions, isResubmitEnabled, getGlobalLock, publishTransaction, hooks, }: {
         approveTransaction: (transactionId: string) => Promise<void>;
         blockTracker: BlockTracker;
         getChainId: () => string;
-        getEthQuery: () => EthQuery;
+        getEthQuery: (networkClientId?: NetworkClientId) => EthQuery;
         getTransactions: () => TransactionMeta[];
         isResubmitEnabled?: boolean;
-        nonceTracker: NonceTracker;
-        onStateChange: (listener: () => void) => void;
-        publishTransaction: (rawTx: string) => Promise<string>;
+        getGlobalLock: () => Promise<() => void>;
+        publishTransaction: (ethQuery: EthQuery, rawTx: string) => Promise<string>;
         hooks?: {
             beforeCheckPendingTransaction?: (transactionMeta: TransactionMeta) => boolean;
             beforePublish?: (transactionMeta: TransactionMeta) => boolean;
         };
     });
+    startIfPendingTransactions: () => void;
     /**
      * Force checks the network if the given transaction is confirmed and updates it's status.
      *
      * @param txMeta - The transaction to check
      */
     forceCheckTransaction(txMeta: TransactionMeta): Promise<void>;
+    stop(): void;
 }
 export {};
 //# sourceMappingURL=PendingTransactionTracker.d.ts.map
\ No newline at end of file
diff --git a/dist/helpers/PendingTransactionTracker.js b/dist/helpers/PendingTransactionTracker.js
index cb1a92ed6106ee15f8467d987c66f72e9cc48380..26bde1b6d85d5725895f8c1eaab468ccafc79370 100644
--- a/dist/helpers/PendingTransactionTracker.js
+++ b/dist/helpers/PendingTransactionTracker.js
@@ -22,7 +22,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _PendingTransactionTracker_instances, _PendingTransactionTracker_approveTransaction, _PendingTransactionTracker_blockTracker, _PendingTransactionTracker_droppedBlockCountByHash, _PendingTransactionTracker_getChainId, _PendingTransactionTracker_getEthQuery, _PendingTransactionTracker_getTransactions, _PendingTransactionTracker_isResubmitEnabled, _PendingTransactionTracker_listener, _PendingTransactionTracker_nonceTracker, _PendingTransactionTracker_onStateChange, _PendingTransactionTracker_publishTransaction, _PendingTransactionTracker_running, _PendingTransactionTracker_beforeCheckPendingTransaction, _PendingTransactionTracker_beforePublish, _PendingTransactionTracker_start, _PendingTransactionTracker_stop, _PendingTransactionTracker_onLatestBlock, _PendingTransactionTracker_checkTransactions, _PendingTransactionTracker_resubmitTransactions, _PendingTransactionTracker_isKnownTransactionError, _PendingTransactionTracker_resubmitTransaction, _PendingTransactionTracker_isResubmitDue, _PendingTransactionTracker_checkTransaction, _PendingTransactionTracker_onTransactionConfirmed, _PendingTransactionTracker_isTransactionDropped, _PendingTransactionTracker_isNonceTaken, _PendingTransactionTracker_getPendingTransactions, _PendingTransactionTracker_warnTransaction, _PendingTransactionTracker_failTransaction, _PendingTransactionTracker_dropTransaction, _PendingTransactionTracker_updateTransaction, _PendingTransactionTracker_getTransactionReceipt, _PendingTransactionTracker_getBlockByHash, _PendingTransactionTracker_getNetworkTransactionCount, _PendingTransactionTracker_getCurrentChainTransactions;
+var _PendingTransactionTracker_instances, _PendingTransactionTracker_approveTransaction, _PendingTransactionTracker_blockTracker, _PendingTransactionTracker_droppedBlockCountByHash, _PendingTransactionTracker_getChainId, _PendingTransactionTracker_getEthQuery, _PendingTransactionTracker_getTransactions, _PendingTransactionTracker_isResubmitEnabled, _PendingTransactionTracker_listener, _PendingTransactionTracker_getGlobalLock, _PendingTransactionTracker_publishTransaction, _PendingTransactionTracker_running, _PendingTransactionTracker_beforeCheckPendingTransaction, _PendingTransactionTracker_beforePublish, _PendingTransactionTracker_start, _PendingTransactionTracker_onLatestBlock, _PendingTransactionTracker_checkTransactions, _PendingTransactionTracker_resubmitTransactions, _PendingTransactionTracker_isKnownTransactionError, _PendingTransactionTracker_resubmitTransaction, _PendingTransactionTracker_isResubmitDue, _PendingTransactionTracker_checkTransaction, _PendingTransactionTracker_onTransactionConfirmed, _PendingTransactionTracker_isTransactionDropped, _PendingTransactionTracker_isNonceTaken, _PendingTransactionTracker_getPendingTransactions, _PendingTransactionTracker_warnTransaction, _PendingTransactionTracker_failTransaction, _PendingTransactionTracker_dropTransaction, _PendingTransactionTracker_updateTransaction, _PendingTransactionTracker_getTransactionReceipt, _PendingTransactionTracker_getBlockByHash, _PendingTransactionTracker_getNetworkTransactionCount, _PendingTransactionTracker_getCurrentChainTransactions;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.PendingTransactionTracker = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
@@ -48,7 +48,7 @@ const KNOWN_TRANSACTION_ERRORS = [
 ];
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'pending-transactions');
 class PendingTransactionTracker {
-    constructor({ approveTransaction, blockTracker, getChainId, getEthQuery, getTransactions, isResubmitEnabled, nonceTracker, onStateChange, publishTransaction, hooks, }) {
+    constructor({ approveTransaction, blockTracker, getChainId, getEthQuery, getTransactions, isResubmitEnabled, getGlobalLock, publishTransaction, hooks, }) {
         var _a, _b;
         _PendingTransactionTracker_instances.add(this);
         _PendingTransactionTracker_approveTransaction.set(this, void 0);
@@ -61,12 +61,20 @@ class PendingTransactionTracker {
         // TODO: Replace `any` with type
         // eslint-disable-next-line @typescript-eslint/no-explicit-any
         _PendingTransactionTracker_listener.set(this, void 0);
-        _PendingTransactionTracker_nonceTracker.set(this, void 0);
-        _PendingTransactionTracker_onStateChange.set(this, void 0);
+        _PendingTransactionTracker_getGlobalLock.set(this, void 0);
         _PendingTransactionTracker_publishTransaction.set(this, void 0);
         _PendingTransactionTracker_running.set(this, void 0);
         _PendingTransactionTracker_beforeCheckPendingTransaction.set(this, void 0);
         _PendingTransactionTracker_beforePublish.set(this, void 0);
+        this.startIfPendingTransactions = () => {
+            const pendingTransactions = __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getPendingTransactions).call(this);
+            if (pendingTransactions.length) {
+                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_start).call(this);
+            }
+            else {
+                this.stop();
+            }
+        };
         this.hub = new events_1.default();
         __classPrivateFieldSet(this, _PendingTransactionTracker_approveTransaction, approveTransaction, "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_blockTracker, blockTracker, "f");
@@ -76,21 +84,11 @@ class PendingTransactionTracker {
         __classPrivateFieldSet(this, _PendingTransactionTracker_getTransactions, getTransactions, "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_isResubmitEnabled, isResubmitEnabled !== null && isResubmitEnabled !== void 0 ? isResubmitEnabled : true, "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_listener, __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_onLatestBlock).bind(this), "f");
-        __classPrivateFieldSet(this, _PendingTransactionTracker_nonceTracker, nonceTracker, "f");
-        __classPrivateFieldSet(this, _PendingTransactionTracker_onStateChange, onStateChange, "f");
+        __classPrivateFieldSet(this, _PendingTransactionTracker_getGlobalLock, getGlobalLock, "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_publishTransaction, publishTransaction, "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_running, false, "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_beforePublish, (_a = hooks === null || hooks === void 0 ? void 0 : hooks.beforePublish) !== null && _a !== void 0 ? _a : (() => true), "f");
         __classPrivateFieldSet(this, _PendingTransactionTracker_beforeCheckPendingTransaction, (_b = hooks === null || hooks === void 0 ? void 0 : hooks.beforeCheckPendingTransaction) !== null && _b !== void 0 ? _b : (() => true), "f");
-        __classPrivateFieldGet(this, _PendingTransactionTracker_onStateChange, "f").call(this, () => {
-            const pendingTransactions = __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_getPendingTransactions).call(this);
-            if (pendingTransactions.length) {
-                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_start).call(this);
-            }
-            else {
-                __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_stop).call(this);
-            }
-        });
     }
     /**
      * Force checks the network if the given transaction is confirmed and updates it's status.
@@ -99,7 +97,7 @@ class PendingTransactionTracker {
      */
     forceCheckTransaction(txMeta) {
         return __awaiter(this, void 0, void 0, function* () {
-            const nonceGlobalLock = yield __classPrivateFieldGet(this, _PendingTransactionTracker_nonceTracker, "f").getGlobalLock();
+            const releaseLock = yield __classPrivateFieldGet(this, _PendingTransactionTracker_getGlobalLock, "f").call(this);
             try {
                 yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_checkTransaction).call(this, txMeta);
             }
@@ -108,29 +106,30 @@ class PendingTransactionTracker {
                 log('Failed to check transaction', error);
             }
             finally {
-                nonceGlobalLock.releaseLock();
+                releaseLock();
             }
         });
     }
+    stop() {
+        if (!__classPrivateFieldGet(this, _PendingTransactionTracker_running, "f")) {
+            return;
+        }
+        __classPrivateFieldGet(this, _PendingTransactionTracker_blockTracker, "f").removeListener('latest', __classPrivateFieldGet(this, _PendingTransactionTracker_listener, "f"));
+        __classPrivateFieldSet(this, _PendingTransactionTracker_running, false, "f");
+        log('Stopped polling');
+    }
 }
 exports.PendingTransactionTracker = PendingTransactionTracker;
-_PendingTransactionTracker_approveTransaction = new WeakMap(), _PendingTransactionTracker_blockTracker = new WeakMap(), _PendingTransactionTracker_droppedBlockCountByHash = new WeakMap(), _PendingTransactionTracker_getChainId = new WeakMap(), _PendingTransactionTracker_getEthQuery = new WeakMap(), _PendingTransactionTracker_getTransactions = new WeakMap(), _PendingTransactionTracker_isResubmitEnabled = new WeakMap(), _PendingTransactionTracker_listener = new WeakMap(), _PendingTransactionTracker_nonceTracker = new WeakMap(), _PendingTransactionTracker_onStateChange = new WeakMap(), _PendingTransactionTracker_publishTransaction = new WeakMap(), _PendingTransactionTracker_running = new WeakMap(), _PendingTransactionTracker_beforeCheckPendingTransaction = new WeakMap(), _PendingTransactionTracker_beforePublish = new WeakMap(), _PendingTransactionTracker_instances = new WeakSet(), _PendingTransactionTracker_start = function _PendingTransactionTracker_start() {
+_PendingTransactionTracker_approveTransaction = new WeakMap(), _PendingTransactionTracker_blockTracker = new WeakMap(), _PendingTransactionTracker_droppedBlockCountByHash = new WeakMap(), _PendingTransactionTracker_getChainId = new WeakMap(), _PendingTransactionTracker_getEthQuery = new WeakMap(), _PendingTransactionTracker_getTransactions = new WeakMap(), _PendingTransactionTracker_isResubmitEnabled = new WeakMap(), _PendingTransactionTracker_listener = new WeakMap(), _PendingTransactionTracker_getGlobalLock = new WeakMap(), _PendingTransactionTracker_publishTransaction = new WeakMap(), _PendingTransactionTracker_running = new WeakMap(), _PendingTransactionTracker_beforeCheckPendingTransaction = new WeakMap(), _PendingTransactionTracker_beforePublish = new WeakMap(), _PendingTransactionTracker_instances = new WeakSet(), _PendingTransactionTracker_start = function _PendingTransactionTracker_start() {
     if (__classPrivateFieldGet(this, _PendingTransactionTracker_running, "f")) {
         return;
     }
     __classPrivateFieldGet(this, _PendingTransactionTracker_blockTracker, "f").on('latest', __classPrivateFieldGet(this, _PendingTransactionTracker_listener, "f"));
     __classPrivateFieldSet(this, _PendingTransactionTracker_running, true, "f");
     log('Started polling');
-}, _PendingTransactionTracker_stop = function _PendingTransactionTracker_stop() {
-    if (!__classPrivateFieldGet(this, _PendingTransactionTracker_running, "f")) {
-        return;
-    }
-    __classPrivateFieldGet(this, _PendingTransactionTracker_blockTracker, "f").removeListener('latest', __classPrivateFieldGet(this, _PendingTransactionTracker_listener, "f"));
-    __classPrivateFieldSet(this, _PendingTransactionTracker_running, false, "f");
-    log('Stopped polling');
 }, _PendingTransactionTracker_onLatestBlock = function _PendingTransactionTracker_onLatestBlock(latestBlockNumber) {
     return __awaiter(this, void 0, void 0, function* () {
-        const nonceGlobalLock = yield __classPrivateFieldGet(this, _PendingTransactionTracker_nonceTracker, "f").getGlobalLock();
+        const releaseLock = yield __classPrivateFieldGet(this, _PendingTransactionTracker_getGlobalLock, "f").call(this);
         try {
             yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_checkTransactions).call(this);
         }
@@ -139,7 +138,7 @@ _PendingTransactionTracker_approveTransaction = new WeakMap(), _PendingTransacti
             log('Failed to check transactions', error);
         }
         finally {
-            nonceGlobalLock.releaseLock();
+            releaseLock();
         }
         try {
             yield __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_resubmitTransactions).call(this, latestBlockNumber);
@@ -214,7 +213,8 @@ _PendingTransactionTracker_approveTransaction = new WeakMap(), _PendingTransacti
             yield __classPrivateFieldGet(this, _PendingTransactionTracker_approveTransaction, "f").call(this, txMeta.id);
             return;
         }
-        yield __classPrivateFieldGet(this, _PendingTransactionTracker_publishTransaction, "f").call(this, rawTx);
+        const ethQuery = __classPrivateFieldGet(this, _PendingTransactionTracker_getEthQuery, "f").call(this, txMeta.networkClientId);
+        yield __classPrivateFieldGet(this, _PendingTransactionTracker_publishTransaction, "f").call(this, ethQuery, rawTx);
         txMeta.retryCount = ((_a = txMeta.retryCount) !== null && _a !== void 0 ? _a : 0) + 1;
         __classPrivateFieldGet(this, _PendingTransactionTracker_instances, "m", _PendingTransactionTracker_updateTransaction).call(this, txMeta, 'PendingTransactionTracker:transaction-retry - Retry count increased');
     });
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 365c05b9c144b70bd2d52b568fb377e32d427c36..f88cd0bbed5464d00acd0d56600ef6be089dd3de 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,6 +1,7 @@
 export * from './TransactionController';
 export type { EtherscanTransactionMeta } from './utils/etherscan';
-export { isEIP1559Transaction } from './utils/utils';
+export { isEIP1559Transaction, normalizeTransactionParams, } from './utils/utils';
 export * from './types';
 export { determineTransactionType } from './utils/transaction-type';
+export { mergeGasFeeEstimates } from './utils/gas-flow';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index ab09b74aed5d901cb106652da553935a35ac1b47..4923cf0171172b03b6c9cac7d9de00ce0e0c4b54 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -14,11 +14,14 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
+exports.mergeGasFeeEstimates = exports.determineTransactionType = exports.normalizeTransactionParams = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils/utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
+Object.defineProperty(exports, "normalizeTransactionParams", { enumerable: true, get: function () { return utils_1.normalizeTransactionParams; } });
 __exportStar(require("./types"), exports);
 var transaction_type_1 = require("./utils/transaction-type");
 Object.defineProperty(exports, "determineTransactionType", { enumerable: true, get: function () { return transaction_type_1.determineTransactionType; } });
+var gas_flow_1 = require("./utils/gas-flow");
+Object.defineProperty(exports, "mergeGasFeeEstimates", { enumerable: true, get: function () { return gas_flow_1.mergeGasFeeEstimates; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types.d.ts b/dist/types.d.ts
index d80d057d48112d9047fc6fe419c132c44a53c509..d0be9f03cb1bd4bfd4de8dfb9cdced305b850f98 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -1,4 +1,7 @@
 import type { AccessList } from '@ethereumjs/tx';
+import type EthQuery from '@metamask/eth-query';
+import type { FetchGasFeeEstimateOptions, GasFeeState } from '@metamask/gas-fee-controller';
+import type { NetworkClientId } from '@metamask/network-controller';
 import type { Hex } from '@metamask/utils';
 import type { Operation } from 'fast-json-patch';
 export declare type Events = {
@@ -164,6 +167,10 @@ declare type TransactionMetaBase = {
      * The number of the latest block when the transaction submit was first retried.
      */
     firstRetryBlockNumber?: string;
+    /** Alternate EIP-1559 gas fee estimates for multiple priority levels. */
+    gasFeeEstimates?: GasFeeEstimates;
+    /** Whether the gas fee estimates have been checked at least once. */
+    gasFeeEstimatesLoaded?: boolean;
     /**
      * A hex string of the transaction hash, used to identify the transaction on the network.
      */
@@ -184,6 +191,10 @@ declare type TransactionMetaBase = {
      * Whether the transaction entry is generated from a user operation.
      */
     isUserOperation?: boolean;
+    /**
+     * The ID of the network client used by the transaction.
+     */
+    networkClientId?: NetworkClientId;
     /**
      * Network code as per EIP-155 for this transaction
      *
@@ -270,6 +281,10 @@ declare type TransactionMetaBase = {
      * This is purely attached to state logs for troubleshooting and support.
      */
     sendFlowHistory?: SendFlowHistoryEntry[];
+    /**
+     * Simulation data for the transaction used to predict its outcome.
+     */
+    simulationData?: SimulationData;
     /**
      * If the gas estimation fails, an object containing error and block information.
      */
@@ -799,5 +814,91 @@ export declare type SecurityAlertResponse = {
     result_type: string;
     providerRequestsCount?: Record<string, number>;
 };
+/** Gas fee estimates for a specific priority level. */
+export declare type GasFeeEstimatesForLevel = {
+    /** Maximum amount to pay per gas. */
+    maxFeePerGas: Hex;
+    /** Maximum amount per gas to give to the validator as an incentive. */
+    maxPriorityFeePerGas: Hex;
+};
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+export declare enum GasFeeEstimateLevel {
+    low = "low",
+    medium = "medium",
+    high = "high"
+}
+/** Gas fee estimates for a transaction. */
+export declare type GasFeeEstimates = {
+    /** The gas fee estimate for a low priority transaction. */
+    [GasFeeEstimateLevel.low]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a medium priority transaction. */
+    [GasFeeEstimateLevel.medium]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a high priority transaction. */
+    [GasFeeEstimateLevel.high]: GasFeeEstimatesForLevel;
+};
+/** Request to a gas fee flow to obtain gas fee estimates. */
+export declare type GasFeeFlowRequest = {
+    /** An EthQuery instance to enable queries to the associated RPC provider. */
+    ethQuery: EthQuery;
+    /** Callback to get the GasFeeController estimates. */
+    getGasFeeControllerEstimates: (options: FetchGasFeeEstimateOptions) => Promise<GasFeeState>;
+    /** The metadata of the transaction to obtain estimates for. */
+    transactionMeta: TransactionMeta;
+};
+/** Response from a gas fee flow containing gas fee estimates. */
+export declare type GasFeeFlowResponse = {
+    /** The gas fee estimates for the transaction. */
+    estimates: GasFeeEstimates;
+};
+/** A method of obtaining gas fee estimates for a specific transaction. */
+export declare type GasFeeFlow = {
+    /**
+     * Determine if the gas fee flow supports the specified transaction.
+     * @param transactionMeta - The transaction metadata.
+     * @returns Whether the gas fee flow supports the transaction.
+     */
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    /**
+     * Get gas fee estimates for a specific transaction.
+     * @param request - The gas fee flow request.
+     * @returns The gas fee flow response containing the gas fee estimates.
+     */
+    getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
+};
+/** Simulation data concerning an update to a native or token balance. */
+export declare type SimulationBalanceChange = {
+    /** The balance before the transaction. */
+    previousBalance: Hex;
+    /** The balance after the transaction. */
+    newBalance: Hex;
+    /** The difference in balance. */
+    difference: Hex;
+    /** Whether the balance is increasing or decreasing. */
+    isDecrease: boolean;
+};
+/** Token standards supported by simulation. */
+export declare enum SimulationTokenStandard {
+    erc20 = "erc20",
+    erc721 = "erc721",
+    erc1155 = "erc1155"
+}
+/** Simulation data concerning an updated token. */
+export declare type SimulationToken = {
+    /** The token's contract address. */
+    address: Hex;
+    /** The standard of the token. */
+    standard: SimulationTokenStandard;
+    /** The ID of the token if supported by the standard. */
+    id?: Hex;
+};
+/** Simulation data concerning a change to the a token balance. */
+export declare type SimulationTokenBalanceChange = SimulationToken & SimulationBalanceChange;
+/** Simulation data for a transaction. */
+export declare type SimulationData = {
+    /** Data concerning a change to the user's native balance. */
+    nativeBalanceChange?: SimulationBalanceChange;
+    /** Data concerning a change to the user's token balances. */
+    tokenBalanceChanges: SimulationTokenBalanceChange[];
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/types.js b/dist/types.js
index 639f911e10b4c9092ad7a77f5dcba2c3a0c2f783..09fd44ed67a140b13829bfd0dac6d4d434071a68 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.SimulationTokenStandard = exports.GasFeeEstimateLevel = exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
  * in the wallet. Some of these correspond with the state of the transaction on the network, but
@@ -161,4 +161,18 @@ var UserFeeLevel;
     UserFeeLevel["DAPP_SUGGESTED"] = "dappSuggested";
     UserFeeLevel["MEDIUM"] = "medium";
 })(UserFeeLevel = exports.UserFeeLevel || (exports.UserFeeLevel = {}));
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+var GasFeeEstimateLevel;
+(function (GasFeeEstimateLevel) {
+    GasFeeEstimateLevel["low"] = "low";
+    GasFeeEstimateLevel["medium"] = "medium";
+    GasFeeEstimateLevel["high"] = "high";
+})(GasFeeEstimateLevel = exports.GasFeeEstimateLevel || (exports.GasFeeEstimateLevel = {}));
+/** Token standards supported by simulation. */
+var SimulationTokenStandard;
+(function (SimulationTokenStandard) {
+    SimulationTokenStandard["erc20"] = "erc20";
+    SimulationTokenStandard["erc721"] = "erc721";
+    SimulationTokenStandard["erc1155"] = "erc1155";
+})(SimulationTokenStandard = exports.SimulationTokenStandard || (exports.SimulationTokenStandard = {}));
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/etherscan.d.ts b/dist/utils/etherscan.d.ts
index 4a63542389a6c41ccef6af100710bee9cd347d4c..a3139d38694e10775e0d8fffd5e344edb3e13fbc 100644
--- a/dist/utils/etherscan.d.ts
+++ b/dist/utils/etherscan.d.ts
@@ -61,4 +61,11 @@ export declare function fetchEtherscanTransactions({ address, chainId, fromBlock
  * @returns An Etherscan response object containing the request status and an array of token transaction data.
  */
 export declare function fetchEtherscanTokenTransactions({ address, chainId, fromBlock, limit, }: EtherscanTransactionRequest): Promise<EtherscanTransactionResponse<EtherscanTokenTransactionMeta>>;
+/**
+ * Return the host url used to fetch data from Etherscan.
+ *
+ * @param chainId - Current chain ID used to determine subdomain and domain.
+ * @returns host URL to access Etherscan data.
+ */
+export declare function getEtherscanApiHost(chainId: Hex): string;
 //# sourceMappingURL=etherscan.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/etherscan.js b/dist/utils/etherscan.js
index 793254201f64cb538b813e9ed44db5802a50b5c1..99f21a3b19ecec599785094665ddd9d158d722af 100644
--- a/dist/utils/etherscan.js
+++ b/dist/utils/etherscan.js
@@ -9,7 +9,7 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.fetchEtherscanTokenTransactions = exports.fetchEtherscanTransactions = void 0;
+exports.getEtherscanApiHost = exports.fetchEtherscanTokenTransactions = exports.fetchEtherscanTransactions = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const constants_1 = require("../constants");
 const logger_1 = require("../logger");
@@ -89,11 +89,7 @@ function fetchTransactions(action, { address, chainId, fromBlock, limit, }) {
  * @returns URL to access Etherscan data.
  */
 function getEtherscanApiUrl(chainId, urlParams) {
-    const networkInfo = constants_1.ETHERSCAN_SUPPORTED_NETWORKS[chainId];
-    if (!networkInfo) {
-        throw new Error(`Etherscan does not support chain with ID: ${chainId}`);
-    }
-    const apiUrl = `https://${networkInfo.subdomain}.${networkInfo.domain}`;
+    const apiUrl = getEtherscanApiHost(chainId);
     let url = `${apiUrl}/api?`;
     for (const paramKey of Object.keys(urlParams)) {
         const value = urlParams[paramKey];
@@ -105,4 +101,19 @@ function getEtherscanApiUrl(chainId, urlParams) {
     url += 'tag=latest&page=1';
     return url;
 }
+/**
+ * Return the host url used to fetch data from Etherscan.
+ *
+ * @param chainId - Current chain ID used to determine subdomain and domain.
+ * @returns host URL to access Etherscan data.
+ */
+function getEtherscanApiHost(chainId) {
+    // @ts-expect-error We account for `chainId` not being a property below
+    const networkInfo = constants_1.ETHERSCAN_SUPPORTED_NETWORKS[chainId];
+    if (!networkInfo) {
+        throw new Error(`Etherscan does not support chain with ID: ${chainId}`);
+    }
+    return `https://${networkInfo.subdomain}.${networkInfo.domain}`;
+}
+exports.getEtherscanApiHost = getEtherscanApiHost;
 //# sourceMappingURL=etherscan.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.d.ts b/dist/utils/gas-fees.d.ts
index 9ed9fddd65c4f6504aa018c793d6a4915873b4bc..29031bd9e8ecc2659cca41f850f838cd072e74ea 100644
--- a/dist/utils/gas-fees.d.ts
+++ b/dist/utils/gas-fees.d.ts
@@ -1,31 +1,26 @@
 import type EthQuery from '@metamask/eth-query';
-import type { GasFeeState } from '@metamask/gas-fee-controller';
-import type { SavedGasFees, TransactionParams, TransactionMeta } from '../types';
+import type { FetchGasFeeEstimateOptions, GasFeeState } from '@metamask/gas-fee-controller';
+import type { Hex } from '@metamask/utils';
+import type { SavedGasFees, TransactionParams, TransactionMeta, GasFeeFlow } from '../types';
 export declare type UpdateGasFeesRequest = {
     eip1559: boolean;
     ethQuery: EthQuery;
-    getSavedGasFees: () => SavedGasFees | undefined;
-    getGasFeeEstimates: () => Promise<GasFeeState>;
+    gasFeeFlows: GasFeeFlow[];
+    getGasFeeEstimates: (options: FetchGasFeeEstimateOptions) => Promise<GasFeeState>;
+    getSavedGasFees: (chainId: Hex) => SavedGasFees | undefined;
     txMeta: TransactionMeta;
 };
 export declare type GetGasFeeRequest = UpdateGasFeesRequest & {
-    savedGasFees?: SavedGasFees;
     initialParams: TransactionParams;
-    suggestedGasFees: Awaited<ReturnType<typeof getSuggestedGasFees>>;
+    savedGasFees?: SavedGasFees;
+    suggestedGasFees: SuggestedGasFees;
+};
+declare type SuggestedGasFees = {
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    gasPrice?: string;
 };
 export declare function updateGasFees(request: UpdateGasFeesRequest): Promise<void>;
-declare function getSuggestedGasFees(request: UpdateGasFeesRequest): Promise<{
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-    gasPrice?: undefined;
-} | {
-    maxFeePerGas: `0x${string}`;
-    maxPriorityFeePerGas: `0x${string}`;
-    gasPrice?: undefined;
-} | {
-    gasPrice: string | undefined;
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-}>;
+export declare function gweiDecimalToWeiHex(value: string): `0x${string}`;
 export {};
 //# sourceMappingURL=gas-fees.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index 823fa99ce6763695231177916fd41a20b1c31fdb..965c8dd630289b2988617fbddd46124ceeeade0f 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -10,13 +10,12 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.updateGasFees = void 0;
+exports.gweiDecimalToWeiHex = exports.updateGasFees = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
-const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
 const utils_1 = require("@metamask/utils");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const logger_1 = require("../logger");
 const types_1 = require("../types");
+const gas_flow_1 = require("./gas-flow");
 const swaps_1 = require("./swaps");
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fees');
 function updateGasFees(request) {
@@ -24,11 +23,13 @@ function updateGasFees(request) {
         const { txMeta } = request;
         const initialParams = Object.assign({}, txMeta.txParams);
         const isSwap = swaps_1.SWAP_TRANSACTION_TYPES.includes(txMeta.type);
-        const savedGasFees = isSwap ? undefined : request.getSavedGasFees();
+        const savedGasFees = isSwap
+            ? undefined
+            : request.getSavedGasFees(txMeta.chainId);
         const suggestedGasFees = yield getSuggestedGasFees(request);
         log('Suggested gas fees', suggestedGasFees);
-        const getGasFeeRequest = Object.assign(Object.assign({}, request), { savedGasFees,
-            initialParams,
+        const getGasFeeRequest = Object.assign(Object.assign({}, request), { initialParams,
+            savedGasFees,
             suggestedGasFees });
         txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
         txMeta.txParams.maxPriorityFeePerGas =
@@ -51,6 +52,10 @@ function updateGasFees(request) {
     });
 }
 exports.updateGasFees = updateGasFees;
+function gweiDecimalToWeiHex(value) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(value));
+}
+exports.gweiDecimalToWeiHex = gweiDecimalToWeiHex;
 function getMaxFeePerGas(request) {
     const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;
     if (!eip1559) {
@@ -118,6 +123,10 @@ function getGasPrice(request) {
         log('Using gasPrice from request', initialParams.gasPrice);
         return initialParams.gasPrice;
     }
+    if (suggestedGasFees.maxFeePerGas) {
+        log('Using suggested maxFeePerGas', suggestedGasFees.maxFeePerGas);
+        return suggestedGasFees.maxFeePerGas;
+    }
     if (suggestedGasFees.gasPrice) {
         log('Using suggested gasPrice', suggestedGasFees.gasPrice);
         return suggestedGasFees.gasPrice;
@@ -163,50 +172,30 @@ function updateDefaultGasEstimates(txMeta) {
 }
 function getSuggestedGasFees(request) {
     return __awaiter(this, void 0, void 0, function* () {
-        const { eip1559, ethQuery, getGasFeeEstimates, txMeta } = request;
+        const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
         if ((!eip1559 && txMeta.txParams.gasPrice) ||
             (eip1559 &&
                 txMeta.txParams.maxFeePerGas &&
                 txMeta.txParams.maxPriorityFeePerGas)) {
             return {};
         }
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(txMeta, gasFeeFlows);
         try {
-            const { gasFeeEstimates, gasEstimateType } = yield getGasFeeEstimates();
-            if (eip1559 && gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
-                const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {}, } = gasFeeEstimates;
-                if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
-                    return {
-                        maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),
-                        maxPriorityFeePerGas: gweiDecimalToWeiHex(suggestedMaxPriorityFeePerGas),
-                    };
-                }
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
-                // The LEGACY type includes low, medium and high estimates of
-                // gas price values.
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.medium),
-                };
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
-                // The ETH_GASPRICE type just includes a single gas price property,
-                // which we can assume was retrieved from eth_gasPrice
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),
-                };
-            }
+            const response = yield gasFeeFlow.getGasFees({
+                ethQuery,
+                getGasFeeControllerEstimates: getGasFeeEstimates,
+                transactionMeta: txMeta,
+            });
+            return response.estimates.medium;
         }
         catch (error) {
             log('Failed to get suggested gas fees', error);
         }
         const gasPriceDecimal = (yield (0, controller_utils_1.query)(ethQuery, 'gasPrice'));
         const gasPrice = gasPriceDecimal
-            ? (0, ethereumjs_util_1.addHexPrefix)(gasPriceDecimal.toString(16))
+            ? (0, utils_1.add0x)(gasPriceDecimal.toString(16))
             : undefined;
         return { gasPrice };
     });
 }
-function gweiDecimalToWeiHex(value) {
-    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(value));
-}
 //# sourceMappingURL=gas-fees.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.d.ts b/dist/utils/gas-flow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..31b8760327437dde4b9d454ec9f88504dba456e0
--- /dev/null
+++ b/dist/utils/gas-flow.d.ts
@@ -0,0 +1,32 @@
+import type { GasFeeEstimates, LegacyGasPriceEstimate } from '@metamask/gas-fee-controller';
+import { type GasFeeState } from '@metamask/gas-fee-controller';
+import { type GasFeeEstimates as TransactionGasFeeEstimates, type GasFeeFlow, type TransactionMeta } from '../types';
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+export declare function getGasFeeFlow(transactionMeta: TransactionMeta, gasFeeFlows: GasFeeFlow[]): GasFeeFlow | undefined;
+declare type FeeMarketMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'fee-market';
+    gasFeeControllerEstimates: GasFeeEstimates;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+declare type LegacyMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'legacy';
+    gasFeeControllerEstimates: LegacyGasPriceEstimate;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+export declare function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }: FeeMarketMergeGasFeeEstimatesRequest | LegacyMergeGasFeeEstimatesRequest): GasFeeState['gasFeeEstimates'];
+export {};
+//# sourceMappingURL=gas-flow.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.js b/dist/utils/gas-flow.js
new file mode 100644
index 0000000000000000000000000000000000000000..1657d027cae24ef7d1b314a39c755d56fd86bc22
--- /dev/null
+++ b/dist/utils/gas-flow.js
@@ -0,0 +1,53 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.mergeGasFeeEstimates = exports.getGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const types_1 = require("../types");
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+    return gasFeeFlows.find((gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta));
+}
+exports.getGasFeeFlow = getGasFeeFlow;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }) {
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: mergeFeeMarketEstimate(gasFeeControllerEstimates[level], transactionGasFeeEstimates[level]) })), Object.assign({}, gasFeeControllerEstimates));
+    }
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: getLegacyEstimate(transactionGasFeeEstimates[level]) })), {});
+    }
+    return gasFeeControllerEstimates;
+}
+exports.mergeGasFeeEstimates = mergeGasFeeEstimates;
+/**
+ * Merge a specific priority level of EIP-1559 gas fee estimates.
+ * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The merged gas fee estimate.
+ */
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+    return Object.assign(Object.assign({}, gasFeeControllerEstimate), { suggestedMaxFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas), suggestedMaxPriorityFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxPriorityFeePerGas) });
+}
+/**
+ * Generate a specific priority level for a legacy gas fee estimate.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The legacy gas fee estimate.
+ */
+function getLegacyEstimate(transactionGasFeeEstimate) {
+    return (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas);
+}
+//# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
diff --git a/dist/utils/gas.d.ts b/dist/utils/gas.d.ts
index a3abd31506aaa9fee37de2eec7d913712ec920a1..012c64666e8ad39f56227f4173b73336efcec715 100644
--- a/dist/utils/gas.d.ts
+++ b/dist/utils/gas.d.ts
@@ -1,10 +1,11 @@
 /// <reference types="debug" />
 import type EthQuery from '@metamask/eth-query';
-import type { ProviderConfig } from '@metamask/network-controller';
+import type { Hex } from '@metamask/utils';
 import type { TransactionMeta, TransactionParams } from '../types';
 export declare type UpdateGasRequest = {
     ethQuery: EthQuery;
-    providerConfig: ProviderConfig;
+    isCustomNetwork: boolean;
+    chainId: Hex;
     txMeta: TransactionMeta;
 };
 export declare const log: import("debug").Debugger;
@@ -23,5 +24,5 @@ export declare function estimateGas(txParams: TransactionParams, ethQuery: EthQu
         };
     } | undefined;
 }>;
-export declare function addGasBuffer(estimatedGas: string, blockGasLimit: string, multiplier: number): string;
+export declare function addGasBuffer(estimatedGas: string, blockGasLimit: string, multiplier: number): `0x${string}`;
 //# sourceMappingURL=gas.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas.js b/dist/utils/gas.js
index 072b0e61717ffe01fba101c831594c02fb5b7005..c79a7e5260b1e0b1a7d023d3e9d6d2b58d6f8d1a 100644
--- a/dist/utils/gas.js
+++ b/dist/utils/gas.js
@@ -13,7 +13,6 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.addGasBuffer = exports.estimateGas = exports.updateGas = exports.DEFAULT_GAS_MULTIPLIER = exports.FIXED_GAS = exports.log = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const constants_1 = require("../constants");
 const logger_1 = require("../logger");
 exports.log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas');
@@ -42,7 +41,7 @@ function estimateGas(txParams, ethQuery) {
         const { data, value } = request;
         const { gasLimit: gasLimitHex, number: blockNumber } = yield getLatestBlock(ethQuery);
         const gasLimitBN = (0, controller_utils_1.hexToBN)(gasLimitHex);
-        request.data = data ? (0, ethereumjs_util_1.addHexPrefix)(data) : data;
+        request.data = data ? (0, utils_1.add0x)(data) : data;
         request.gas = (0, controller_utils_1.BNToHex)((0, controller_utils_1.fractionBN)(gasLimitBN, 19, 20));
         request.value = value || '0x0';
         let estimatedGas = request.gas;
@@ -76,16 +75,16 @@ function addGasBuffer(estimatedGas, blockGasLimit, multiplier) {
     const maxGasBN = (0, controller_utils_1.hexToBN)(blockGasLimit).muln(0.9);
     const paddedGasBN = estimatedGasBN.muln(multiplier);
     if (estimatedGasBN.gt(maxGasBN)) {
-        const estimatedGasHex = (0, ethereumjs_util_1.addHexPrefix)(estimatedGas);
+        const estimatedGasHex = (0, utils_1.add0x)(estimatedGas);
         (0, exports.log)('Using estimated value', estimatedGasHex);
         return estimatedGasHex;
     }
     if (paddedGasBN.lt(maxGasBN)) {
-        const paddedHex = (0, ethereumjs_util_1.addHexPrefix)((0, controller_utils_1.BNToHex)(paddedGasBN));
+        const paddedHex = (0, utils_1.add0x)((0, controller_utils_1.BNToHex)(paddedGasBN));
         (0, exports.log)('Using padded estimate', paddedHex, multiplier);
         return paddedHex;
     }
-    const maxHex = (0, ethereumjs_util_1.addHexPrefix)((0, controller_utils_1.BNToHex)(maxGasBN));
+    const maxHex = (0, utils_1.add0x)((0, controller_utils_1.BNToHex)(maxGasBN));
     (0, exports.log)('Using 90% of block gas limit', maxHex);
     return maxHex;
 }
@@ -93,7 +92,7 @@ exports.addGasBuffer = addGasBuffer;
 function getGas(request) {
     var _a;
     return __awaiter(this, void 0, void 0, function* () {
-        const { providerConfig, txMeta } = request;
+        const { isCustomNetwork, chainId, txMeta } = request;
         if (txMeta.txParams.gas) {
             (0, exports.log)('Using value from request', txMeta.txParams.gas);
             return [txMeta.txParams.gas];
@@ -103,18 +102,17 @@ function getGas(request) {
             return [exports.FIXED_GAS];
         }
         const { blockGasLimit, estimatedGas, simulationFails } = yield estimateGas(txMeta.txParams, request.ethQuery);
-        if (providerConfig.type === controller_utils_1.NetworkType.rpc) {
+        if (isCustomNetwork) {
             (0, exports.log)('Using original estimate as custom network');
             return [estimatedGas, simulationFails];
         }
-        const bufferMultiplier = (_a = constants_1.GAS_BUFFER_CHAIN_OVERRIDES[providerConfig.chainId]) !== null && _a !== void 0 ? _a : exports.DEFAULT_GAS_MULTIPLIER;
+        const bufferMultiplier = (_a = constants_1.GAS_BUFFER_CHAIN_OVERRIDES[chainId]) !== null && _a !== void 0 ? _a : exports.DEFAULT_GAS_MULTIPLIER;
         const bufferedGas = addGasBuffer(estimatedGas, blockGasLimit, bufferMultiplier);
         return [bufferedGas, simulationFails];
     });
 }
-function requiresFixedGas({ ethQuery, txMeta, providerConfig, }) {
+function requiresFixedGas({ ethQuery, txMeta, isCustomNetwork, }) {
     return __awaiter(this, void 0, void 0, function* () {
-        const isCustomNetwork = providerConfig.type === controller_utils_1.NetworkType.rpc;
         const { txParams: { to, data }, } = txMeta;
         if (isCustomNetwork || !to || data) {
             return false;
diff --git a/dist/utils/nonce.d.ts b/dist/utils/nonce.d.ts
index 04b9b52995529ebf068876fa54e16abf048d173a..0a5bf32ba41e11df6cfb0d21688fc27ecab1db47 100644
--- a/dist/utils/nonce.d.ts
+++ b/dist/utils/nonce.d.ts
@@ -1,13 +1,13 @@
-import type { NonceTracker, Transaction as NonceTrackerTransaction } from 'nonce-tracker';
+import type { NonceLock, Transaction as NonceTrackerTransaction } from 'nonce-tracker';
 import type { TransactionMeta, TransactionStatus } from '../types';
 /**
  * Determine the next nonce to be used for a transaction.
  *
  * @param txMeta - The transaction metadata.
- * @param nonceTracker - An instance of a nonce tracker.
+ * @param getNonceLock - An anonymous function that acquires the nonce lock for an address
  * @returns The next hexadecimal nonce to be used for the given transaction, and optionally a function to release the nonce lock.
  */
-export declare function getNextNonce(txMeta: TransactionMeta, nonceTracker: NonceTracker): Promise<[string, (() => void) | undefined]>;
+export declare function getNextNonce(txMeta: TransactionMeta, getNonceLock: (address: string) => Promise<NonceLock>): Promise<[string, (() => void) | undefined]>;
 /**
  * Filter and format transactions for the nonce tracker.
  *
diff --git a/dist/utils/nonce.js b/dist/utils/nonce.js
index 686d398d9d1b86a255edd8f7686569943117a4f4..f5f3ca7e06bd989da290e4d8db983ce41c4bcc04 100644
--- a/dist/utils/nonce.js
+++ b/dist/utils/nonce.js
@@ -17,10 +17,10 @@ const log = (0, logger_1.createModuleLogger)(logger_1.projectLogger, 'nonce');
  * Determine the next nonce to be used for a transaction.
  *
  * @param txMeta - The transaction metadata.
- * @param nonceTracker - An instance of a nonce tracker.
+ * @param getNonceLock - An anonymous function that acquires the nonce lock for an address
  * @returns The next hexadecimal nonce to be used for the given transaction, and optionally a function to release the nonce lock.
  */
-function getNextNonce(txMeta, nonceTracker) {
+function getNextNonce(txMeta, getNonceLock) {
     return __awaiter(this, void 0, void 0, function* () {
         const { customNonceValue, txParams: { from, nonce: existingNonce }, } = txMeta;
         const customNonce = customNonceValue ? (0, controller_utils_1.toHex)(customNonceValue) : undefined;
@@ -32,7 +32,7 @@ function getNextNonce(txMeta, nonceTracker) {
             log('Using existing nonce', existingNonce);
             return [existingNonce, undefined];
         }
-        const nonceLock = yield nonceTracker.getNonceLock(from);
+        const nonceLock = yield getNonceLock(from);
         const nonce = (0, controller_utils_1.toHex)(nonceLock.nextNonce);
         const releaseLock = nonceLock.releaseLock.bind(nonceLock);
         log('Using nonce from nonce tracker', nonce, nonceLock.nonceDetails);
diff --git a/dist/utils/simulation-api.d.ts b/dist/utils/simulation-api.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8389fcda31b6a36c7d04047f6ee197b45fde2f77
--- /dev/null
+++ b/dist/utils/simulation-api.d.ts
@@ -0,0 +1,66 @@
+import { type Hex } from '@metamask/utils';
+/** Single transaction to simulate in a simulation API request.  */
+export declare type SimulationRequestTransaction = {
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+/** Request to the simulation API to simulate transactions. */
+export declare type SimulationRequest = {
+    transactions: SimulationRequestTransaction[];
+    overrides?: {
+        [address: Hex]: {
+            stateDiff: {
+                [slot: Hex]: Hex;
+            };
+        };
+    };
+    withCallTrace?: boolean;
+    withLogs?: boolean;
+};
+/** Raw event log emitted by a simulated transaction. */
+export declare type SimulationLog = {
+    address: Hex;
+    data: Hex;
+    topics: Hex[];
+};
+/** Call trace of a single simulated transaction. */
+export declare type SimulationResponseCallTrace = {
+    calls: SimulationResponseCallTrace[];
+    logs: SimulationLog[];
+};
+/** Response from the simulation API. */
+export declare type SimulationResponse = {
+    transactions: {
+        return: Hex;
+        callTrace: SimulationResponseCallTrace;
+        stateDiff: {
+            pre: {
+                [address: Hex]: {
+                    balance?: Hex;
+                    nonce?: Hex;
+                    storage?: {
+                        [slot: Hex]: Hex;
+                    };
+                };
+            };
+            post: {
+                [address: Hex]: {
+                    balance?: Hex;
+                    nonce?: Hex;
+                    storage?: {
+                        [slot: Hex]: Hex;
+                    };
+                };
+            };
+        };
+    }[];
+};
+/**
+ * Simulate transactions using the transaction simulation API.
+ * @param chainId - The chain ID to simulate transactions on.
+ * @param request - The request to simulate transactions.
+ */
+export declare function simulateTransactions(chainId: Hex, request: SimulationRequest): Promise<SimulationResponse>;
+//# sourceMappingURL=simulation-api.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.js b/dist/utils/simulation-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..e6f0c1947c7d92a03db5a7acba89e79b4bf6059b
--- /dev/null
+++ b/dist/utils/simulation-api.js
@@ -0,0 +1,61 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.simulateTransactions = void 0;
+const providers_1 = require("@ethersproject/providers");
+const utils_1 = require("@metamask/utils");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation-api');
+const RPC_METHOD = 'infura_simulateTransactions';
+const BASE_URL = 'https://tx-sentinel-{0}.api.cx.metamask.io/';
+const SUBDOMAIN_BY_CHAIN_ID = {
+    [constants_1.CHAIN_IDS.MAINNET]: 'ethereum-mainnet',
+    [constants_1.CHAIN_IDS.GOERLI]: 'ethereum-goerli',
+    [constants_1.CHAIN_IDS.SEPOLIA]: 'ethereum-sepolia',
+    [constants_1.CHAIN_IDS.LINEA_MAINNET]: 'linea-mainnet',
+    [constants_1.CHAIN_IDS.LINEA_GOERLI]: 'linea-goerli',
+    [constants_1.CHAIN_IDS.ARBITRUM]: 'arbitrum-mainnet',
+    [constants_1.CHAIN_IDS.AVALANCHE]: 'avalanche-mainnet',
+    [constants_1.CHAIN_IDS.OPTIMISM]: 'optimism-mainnet',
+    [constants_1.CHAIN_IDS.POLYGON]: 'polygon-mainnet',
+    [constants_1.CHAIN_IDS.BSC]: 'bsc-mainnet',
+};
+/**
+ * Simulate transactions using the transaction simulation API.
+ * @param chainId - The chain ID to simulate transactions on.
+ * @param request - The request to simulate transactions.
+ */
+function simulateTransactions(chainId, request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const url = getUrl(chainId);
+        log('Sending request', url, request);
+        const jsonRpc = new providers_1.JsonRpcProvider(url);
+        const response = yield jsonRpc.send(RPC_METHOD, [request]);
+        log('Received response', response);
+        return response;
+    });
+}
+exports.simulateTransactions = simulateTransactions;
+/**
+ * Get the URL for the transaction simulation API.
+ * @param chainId - The chain ID to get the URL for.
+ * @returns The URL for the transaction simulation API.
+ */
+function getUrl(chainId) {
+    const subdomain = SUBDOMAIN_BY_CHAIN_ID[chainId];
+    if (!subdomain) {
+        log('Chain is not supported', chainId);
+        throw new Error(`Chain is not supported: ${chainId}`);
+    }
+    return BASE_URL.replace('{0}', subdomain);
+}
+//# sourceMappingURL=simulation-api.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.d.ts b/dist/utils/simulation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62f760ef2cfb9d88ced279e82527a04ef1c487ce
--- /dev/null
+++ b/dist/utils/simulation.d.ts
@@ -0,0 +1,21 @@
+import { type Hex } from '@metamask/utils';
+import type { SimulationData } from '../types';
+export declare type GetSimulationDataRequest = {
+    chainId: Hex;
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+/**
+ * Generate simulation data for a transaction.
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+export declare function getSimulationData(request: GetSimulationDataRequest): Promise<SimulationData | undefined>;
+//# sourceMappingURL=simulation.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e71e294956033dfc613ac51988be6f8b5b23f26
--- /dev/null
+++ b/dist/utils/simulation.js
@@ -0,0 +1,307 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getSimulationData = void 0;
+const abi_1 = require("@ethersproject/abi");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const simulation_api_1 = require("./simulation-api");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation');
+/**
+ * Generate simulation data for a transaction.
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+function getSimulationData(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, from, to, value, data } = request;
+        log('Getting simulation data', request);
+        try {
+            const response = yield (0, simulation_api_1.simulateTransactions)(chainId, {
+                transactions: [{ from, to, value, data }],
+                withCallTrace: true,
+                withLogs: true,
+            });
+            const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+            const events = getEvents(response);
+            log('Parsed events', events);
+            const tokenBalanceChanges = events.length
+                ? yield getTokenBalanceChanges(request, events)
+                : [];
+            return {
+                nativeBalanceChange,
+                tokenBalanceChanges,
+            };
+        }
+        catch (error) {
+            log('Failed to get simulation data', error, request);
+            return undefined;
+        }
+    });
+}
+exports.getSimulationData = getSimulationData;
+/**
+ * Extract the native balance change from a simulation response.
+ * @param userAddress - The user's account address.
+ * @param response - The simulation response.
+ * @returns The native balance change or undefined if unchanged.
+ */
+function getNativeBalanceChange(userAddress, response) {
+    var _a, _b, _c;
+    /* istanbul ignore next */
+    const { stateDiff } = (_a = response.transactions[0]) !== null && _a !== void 0 ? _a : {
+        stateDiff: { pre: {}, post: {} },
+    };
+    const previousBalance = (_b = stateDiff.pre[userAddress]) === null || _b === void 0 ? void 0 : _b.balance;
+    const newBalance = (_c = stateDiff.post[userAddress]) === null || _c === void 0 ? void 0 : _c.balance;
+    if (!previousBalance || !newBalance) {
+        return undefined;
+    }
+    return getSimulationBalanceChange(previousBalance, newBalance);
+}
+/**
+ * Extract events from a simulation response.
+ * @param response - The simulation response.
+ * @returns The parsed events.
+ */
+function getEvents(response) {
+    var _a, _b;
+    /* istanbul ignore next */
+    const logs = getLogs((_b = (_a = response.transactions[0]) === null || _a === void 0 ? void 0 : _a.callTrace) !== null && _b !== void 0 ? _b : {});
+    log('Extracted logs', logs);
+    const erc20Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+    const erc721Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC721);
+    const erc1155Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC1155);
+    return logs
+        .map((currentLog) => {
+        var _a;
+        const event = parseLog(currentLog, erc20Interface, erc721Interface, erc1155Interface);
+        if (!event) {
+            log('Failed to parse log', currentLog);
+            return undefined;
+        }
+        /* istanbul ignore next */
+        const inputs = (_a = event.abi.find((e) => e.name === event.name)) === null || _a === void 0 ? void 0 : _a.inputs;
+        /* istanbul ignore if */
+        if (!inputs) {
+            log('Failed to find inputs for event', event);
+            return undefined;
+        }
+        const args = parseEventArgs(event.args, inputs);
+        return {
+            contractAddress: currentLog.address,
+            tokenStandard: event.standard,
+            name: event.name,
+            data: args,
+            abi: event.abi,
+        };
+    })
+        .filter((e) => e !== undefined);
+}
+/**
+ * Parse event arguments using ABI input definitions.
+ * @param args - The raw event arguments.
+ * @param abiInputs - The ABI input definitions.
+ * @returns The parsed event arguments.
+ */
+function parseEventArgs(args, abiInputs) {
+    return args.reduce((result, arg, index) => {
+        const name = abiInputs[index].name.replace('_', '');
+        const value = parseEventArgValue(arg);
+        result[name] = value;
+        return result;
+    }, {});
+}
+/**
+ * Parse an event argument value.
+ * @param value - The event argument value.
+ * @returns The parsed event argument value.
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+function parseEventArgValue(value) {
+    if (Array.isArray(value)) {
+        return value.map(parseEventArgValue);
+    }
+    let parsedValue = value;
+    if (parsedValue.toHexString) {
+        parsedValue = value.toHexString();
+    }
+    return parsedValue.toLowerCase();
+}
+/**
+ * Generate token balance changes from parsed events.
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns An array of token balance changes.
+ */
+function getTokenBalanceChanges(request, events) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const balanceTransactionsByToken = getTokenBalanceTransactions(request, events);
+        const balanceTransactions = [...balanceTransactionsByToken.values()];
+        log('Generated balance transactions', balanceTransactions);
+        if (!balanceTransactions.length) {
+            return [];
+        }
+        const response = yield (0, simulation_api_1.simulateTransactions)(request.chainId, {
+            transactions: [...balanceTransactions, request, ...balanceTransactions],
+        });
+        if (response.transactions.length !== balanceTransactions.length * 2 + 1) {
+            throw new Error('Invalid response from simulation API');
+        }
+        log('Balance simulation response', response);
+        return [...balanceTransactionsByToken.keys()]
+            .map((token, index) => {
+            const previousBalance = response.transactions[index].return;
+            const newBalance = response.transactions[index + balanceTransactions.length + 1].return;
+            const balanceChange = getSimulationBalanceChange(previousBalance, newBalance);
+            if (!balanceChange) {
+                return undefined;
+            }
+            return Object.assign(Object.assign({}, token), balanceChange);
+        })
+            .filter((change) => change !== undefined);
+    });
+}
+/**
+ * Generate transactions to check token balances.
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns A map of token balance transactions keyed by token.
+ */
+function getTokenBalanceTransactions(request, events) {
+    const tokenKeys = new Set();
+    return events.reduce((result, event) => {
+        if (!['Transfer', 'TransferSingle', 'TransferBatch'].includes(event.name) ||
+            ![event.data.from, event.data.to].includes(request.from)) {
+            log('Ignoring event', event);
+            return result;
+        }
+        let tokenIds = [undefined];
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc721) {
+            tokenIds = [event.data.tokenId];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferSingle') {
+            tokenIds = [event.data.id];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferBatch') {
+            tokenIds = event.data.ids;
+        }
+        log('Extracted token ids', tokenIds);
+        for (const tokenId of tokenIds) {
+            const simulationToken = {
+                address: event.contractAddress,
+                standard: event.tokenStandard,
+                id: tokenId,
+            };
+            const tokenKey = JSON.stringify(simulationToken);
+            if (tokenKeys.has(tokenKey)) {
+                log('Ignoring additional event with same contract and token ID', simulationToken);
+                continue;
+            }
+            tokenKeys.add(tokenKey);
+            const parameters = [request.from];
+            if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155) {
+                parameters.push(tokenId);
+            }
+            result.set(simulationToken, {
+                from: request.from,
+                to: event.contractAddress,
+                data: new abi_1.Interface(event.abi).encodeFunctionData('balanceOf', parameters),
+            });
+        }
+        return result;
+    }, new Map());
+}
+/**
+ * Parse a raw event log using known ABIs.
+ * @param eventLog - The raw event log.
+ * @param erc20 - The ERC-20 ABI interface.
+ * @param erc721 - The ERC-721 ABI interface.
+ * @param erc1155 - The ERC-1155 ABI interface.
+ * @returns The parsed event log or undefined if it could not be parsed.
+ */
+function parseLog(eventLog, erc20, erc721, erc1155) {
+    const abisByStandard = [
+        {
+            abi: metamask_eth_abis_1.abiERC20,
+            contractInterface: erc20,
+            standard: types_1.SimulationTokenStandard.erc20,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC721,
+            contractInterface: erc721,
+            standard: types_1.SimulationTokenStandard.erc721,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC1155,
+            contractInterface: erc1155,
+            standard: types_1.SimulationTokenStandard.erc1155,
+        },
+    ];
+    for (const { abi, contractInterface, standard } of abisByStandard) {
+        try {
+            return Object.assign(Object.assign({}, contractInterface.parseLog(eventLog)), { abi,
+                standard });
+        }
+        catch (e) {
+            // Intentionally empty
+        }
+    }
+    return undefined;
+}
+/**
+ * Extract all logs from a call trace tree.
+ * @param call - The root call trace.
+ * @returns An array of logs.
+ */
+function getLogs(call) {
+    var _a, _b;
+    /* istanbul ignore next */
+    const logs = (_a = call.logs) !== null && _a !== void 0 ? _a : [];
+    /* istanbul ignore next */
+    const nestedCalls = (_b = call.calls) !== null && _b !== void 0 ? _b : [];
+    return [
+        ...logs,
+        ...nestedCalls.map((nestedCall) => getLogs(nestedCall)).flat(),
+    ];
+}
+/**
+ * Generate balance change data from previous and new balances.
+ * @param previousBalance - The previous balance.
+ * @param newBalance - The new balance.
+ * @returns The balance change data or undefined if unchanged.
+ */
+function getSimulationBalanceChange(previousBalance, newBalance) {
+    const differenceBN = (0, controller_utils_1.hexToBN)(newBalance).sub((0, controller_utils_1.hexToBN)(previousBalance));
+    const isDecrease = differenceBN.isNeg();
+    const difference = (0, controller_utils_1.toHex)(differenceBN.abs());
+    if (differenceBN.isZero()) {
+        log('Balance change is zero');
+        return undefined;
+    }
+    return {
+        previousBalance,
+        newBalance,
+        difference,
+        isDecrease,
+    };
+}
+//# sourceMappingURL=simulation.js.map
\ No newline at end of file
diff --git a/dist/utils/utils.d.ts b/dist/utils/utils.d.ts
index b2ab10434f29503a544d784b75b0809c80efa4f9..38f2f6d17f8c00858a69dedd952ee4a9a3cbec53 100644
--- a/dist/utils/utils.d.ts
+++ b/dist/utils/utils.d.ts
@@ -7,7 +7,7 @@ export declare const ESTIMATE_GAS_ERROR = "eth_estimateGas rpc method error";
  * @param txParams - The transaction params to normalize.
  * @returns Normalized transaction params.
  */
-export declare function normalizeTxParams(txParams: TransactionParams): TransactionParams;
+export declare function normalizeTransactionParams(txParams: TransactionParams): TransactionParams;
 /**
  * Checks if a transaction is EIP-1559 by checking for the existence of
  * maxFeePerGas and maxPriorityFeePerGas within its parameters.
@@ -55,4 +55,12 @@ export declare function normalizeTxError(error: Error & {
  * @returns An object containing normalized gas fee values.
  */
 export declare function normalizeGasFeeValues(gasFeeValues: GasPriceValue | FeeMarketEIP1559Values): GasPriceValue | FeeMarketEIP1559Values;
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+export declare function padHexToEvenLength(hex: string): string;
 //# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/utils.js b/dist/utils/utils.js
index 8090c8f63b8c24c211f0c402831694f47dc45bed..00e717c5aadca944fa3ace1c795bfef720c05de2 100644
--- a/dist/utils/utils.js
+++ b/dist/utils/utils.js
@@ -1,26 +1,25 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.normalizeGasFeeValues = exports.normalizeTxError = exports.validateIfTransactionUnapproved = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.normalizeTxParams = exports.ESTIMATE_GAS_ERROR = void 0;
+exports.padHexToEvenLength = exports.normalizeGasFeeValues = exports.normalizeTxError = exports.validateIfTransactionUnapproved = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.normalizeTransactionParams = exports.ESTIMATE_GAS_ERROR = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
-const ethereumjs_util_1 = require("ethereumjs-util");
 const types_1 = require("../types");
 exports.ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';
 // TODO: Replace `any` with type
 // eslint-disable-next-line @typescript-eslint/no-explicit-any
 const NORMALIZERS = {
-    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(data),
-    from: (from) => (0, ethereumjs_util_1.addHexPrefix)(from).toLowerCase(),
-    gas: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
-    gasLimit: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
-    gasPrice: (gasPrice) => (0, ethereumjs_util_1.addHexPrefix)(gasPrice),
-    nonce: (nonce) => (0, ethereumjs_util_1.addHexPrefix)(nonce),
-    to: (to) => (0, ethereumjs_util_1.addHexPrefix)(to).toLowerCase(),
-    value: (value) => (0, ethereumjs_util_1.addHexPrefix)(value),
-    maxFeePerGas: (maxFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxFeePerGas),
-    maxPriorityFeePerGas: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
-    estimatedBaseFee: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
-    type: (type) => (0, ethereumjs_util_1.addHexPrefix)(type),
+    data: (data) => (0, utils_1.add0x)(padHexToEvenLength(data)),
+    from: (from) => (0, utils_1.add0x)(from).toLowerCase(),
+    gas: (gas) => (0, utils_1.add0x)(gas),
+    gasLimit: (gas) => (0, utils_1.add0x)(gas),
+    gasPrice: (gasPrice) => (0, utils_1.add0x)(gasPrice),
+    nonce: (nonce) => (0, utils_1.add0x)(nonce),
+    to: (to) => (0, utils_1.add0x)(to).toLowerCase(),
+    value: (value) => (0, utils_1.add0x)(value),
+    maxFeePerGas: (maxFeePerGas) => (0, utils_1.add0x)(maxFeePerGas),
+    maxPriorityFeePerGas: (maxPriorityFeePerGas) => (0, utils_1.add0x)(maxPriorityFeePerGas),
+    estimatedBaseFee: (maxPriorityFeePerGas) => (0, utils_1.add0x)(maxPriorityFeePerGas),
+    type: (type) => (0, utils_1.add0x)(type),
 };
 /**
  * Normalizes properties on transaction params.
@@ -28,7 +27,7 @@ const NORMALIZERS = {
  * @param txParams - The transaction params to normalize.
  * @returns Normalized transaction params.
  */
-function normalizeTxParams(txParams) {
+function normalizeTransactionParams(txParams) {
     const normalizedTxParams = { from: '' };
     for (const key of (0, utils_1.getKnownPropertyNames)(NORMALIZERS)) {
         if (txParams[key]) {
@@ -40,7 +39,7 @@ function normalizeTxParams(txParams) {
     }
     return normalizedTxParams;
 }
-exports.normalizeTxParams = normalizeTxParams;
+exports.normalizeTransactionParams = normalizeTransactionParams;
 /**
  * Checks if a transaction is EIP-1559 by checking for the existence of
  * maxFeePerGas and maxPriorityFeePerGas within its parameters.
@@ -59,7 +58,7 @@ const validateGasValues = (gasValues) => {
         // TODO: Replace `any` with type
         // eslint-disable-next-line @typescript-eslint/no-explicit-any
         const value = gasValues[key];
-        if (typeof value !== 'string' || !(0, ethereumjs_util_1.isHexString)(value)) {
+        if (typeof value !== 'string' || !(0, utils_1.isStrictHexString)(value)) {
             throw new TypeError(`expected hex string for ${key} but received: ${value}`);
         }
     });
@@ -70,7 +69,7 @@ const isFeeMarketEIP1559Values = (gasValues) => (gasValues === null || gasValues
 exports.isFeeMarketEIP1559Values = isFeeMarketEIP1559Values;
 const isGasPriceValue = (gasValues) => (gasValues === null || gasValues === void 0 ? void 0 : gasValues.gasPrice) !== undefined;
 exports.isGasPriceValue = isGasPriceValue;
-const getIncreasedPriceHex = (value, rate) => (0, ethereumjs_util_1.addHexPrefix)(`${parseInt(`${value * rate}`, 10).toString(16)}`);
+const getIncreasedPriceHex = (value, rate) => (0, utils_1.add0x)(`${parseInt(`${value * rate}`, 10).toString(16)}`);
 exports.getIncreasedPriceHex = getIncreasedPriceHex;
 const getIncreasedPriceFromExisting = (value, rate) => {
     return (0, exports.getIncreasedPriceHex)((0, controller_utils_1.convertHexToDecimal)(value), rate);
@@ -133,7 +132,7 @@ exports.normalizeTxError = normalizeTxError;
 function normalizeGasFeeValues(gasFeeValues) {
     // TODO: Replace `any` with type
     // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    const normalize = (value) => typeof value === 'string' ? (0, ethereumjs_util_1.addHexPrefix)(value) : value;
+    const normalize = (value) => typeof value === 'string' ? (0, utils_1.add0x)(value) : value;
     if ('gasPrice' in gasFeeValues) {
         return {
             gasPrice: normalize(gasFeeValues.gasPrice),
@@ -145,4 +144,18 @@ function normalizeGasFeeValues(gasFeeValues) {
     };
 }
 exports.normalizeGasFeeValues = normalizeGasFeeValues;
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+function padHexToEvenLength(hex) {
+    const prefix = hex.toLowerCase().startsWith('0x') ? hex.slice(0, 2) : '';
+    const data = prefix ? hex.slice(2) : hex;
+    const evenData = data.length % 2 === 0 ? data : `0${data}`;
+    return prefix + evenData;
+}
+exports.padHexToEvenLength = padHexToEvenLength;
 //# sourceMappingURL=utils.js.map
\ No newline at end of file
