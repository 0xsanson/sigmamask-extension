diff --git a/dist/TransactionController.d.ts b/dist/TransactionController.d.ts
index 8a2025ef1e2b230d81bb28cac227f7bbb9db2c90..0e332969966b449bd702eab31105930a6aa99977 100644
--- a/dist/TransactionController.d.ts
+++ b/dist/TransactionController.d.ts
@@ -94,6 +94,7 @@ export interface TransactionControllerEventEmitter extends EventEmitter {
  * Controller responsible for submitting and managing transactions.
  */
 export declare class TransactionController extends BaseControllerV1<TransactionConfig, TransactionState> {
+    #private;
     private readonly ethQuery;
     private readonly isHistoryDisabled;
     private readonly isSwapsDisabled;
diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 731d0f5a9b077f7969c728bd30ce08e70052322c..e5cac5f27c346b811dd0a4fd309bad6e0203aba6 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -8,9 +8,15 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
         step((generator = generator.apply(thisArg, _arguments || [])).next());
     });
 };
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
+var _TransactionController_instances, _TransactionController_simulateTransaction;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.HARDFORK = void 0;
 const common_1 = require("@ethereumjs/common");
@@ -36,6 +42,7 @@ const gas_1 = require("./utils/gas");
 const gas_fees_1 = require("./utils/gas-fees");
 const history_1 = require("./utils/history");
 const nonce_1 = require("./utils/nonce");
+const simulation_1 = require("./utils/simulation");
 const swaps_1 = require("./utils/swaps");
 const transaction_type_1 = require("./utils/transaction-type");
 const utils_1 = require("./utils/utils");
@@ -97,6 +104,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
     constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions = {}, messenger, onNetworkStateChange, pendingTransactions = {}, provider, securityProviderRequest, hooks = {}, }, config, state) {
         var _a, _b, _c, _d, _e, _f;
         super(config, state);
+        _TransactionController_instances.add(this);
         this.inProcessOfSigning = new Set();
         this.mutex = new async_mutex_1.Mutex();
         this.signAbortCallbacks = new Map();
@@ -291,7 +299,10 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 verifiedOnBlockchain: false,
                 type: transactionType,
             };
-            yield this.updateGasProperties(transactionMeta);
+            yield Promise.all([
+                this.updateGasProperties(transactionMeta),
+                __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_simulateTransaction).call(this, transactionMeta),
+            ]);
             // Checks if a transaction already exists with a given actionId
             if (!existingTransactionMeta) {
                 // Set security provider response
@@ -1678,4 +1689,18 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
     }
 }
 exports.TransactionController = TransactionController;
+_TransactionController_instances = new WeakSet(), _TransactionController_simulateTransaction = function _TransactionController_simulateTransaction(transactionMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, txParams } = transactionMeta;
+        const { from, to, value, data } = txParams;
+        transactionMeta.simulationData = yield (0, simulation_1.getSimulationData)({
+            chainId,
+            from: from,
+            to: to,
+            value: value,
+            data: data,
+        });
+        (0, logger_1.projectLogger)('Retrieved simulation data', transactionMeta.simulationData);
+    });
+};
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/types.d.ts b/dist/types.d.ts
index d80d057d48112d9047fc6fe419c132c44a53c509..dc71c0d2399915548a5fa33685cf6896187792d6 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -270,6 +270,10 @@ declare type TransactionMetaBase = {
      * This is purely attached to state logs for troubleshooting and support.
      */
     sendFlowHistory?: SendFlowHistoryEntry[];
+    /**
+     * Simulation data for the transaction used to predict its outcome.
+     */
+    simulationData?: SimulationData;
     /**
      * If the gas estimation fails, an object containing error and block information.
      */
@@ -799,5 +803,40 @@ export declare type SecurityAlertResponse = {
     result_type: string;
     providerRequestsCount?: Record<string, number>;
 };
+/** Simulation data concerning an update to a native or token balance. */
+export declare type SimulationBalanceChange = {
+    /** The balance before the transaction. */
+    previousBalance: Hex;
+    /** The balance after the transaction. */
+    newBalance: Hex;
+    /** The difference in balance. */
+    difference: Hex;
+    /** Whether the balance is increasing or decreasing. */
+    isDecrease: boolean;
+};
+/** Token standards supported by simulation. */
+export declare enum SimulationTokenStandard {
+    erc20 = "erc20",
+    erc721 = "erc721",
+    erc1155 = "erc1155"
+}
+/** Simulation data concerning an updated token. */
+export declare type SimulationToken = {
+    /** The token's contract address. */
+    address: Hex;
+    /** The standard of the token. */
+    standard: SimulationTokenStandard;
+    /** The ID of the token if supported by the standard. */
+    id?: Hex;
+};
+/** Simulation data concerning a change to the a token balance. */
+export declare type SimulationTokenBalanceChange = SimulationToken & SimulationBalanceChange;
+/** Simulation data for a transaction. */
+export declare type SimulationData = {
+    /** Data concerning a change to the user's native balance. */
+    nativeBalanceChange?: SimulationBalanceChange;
+    /** Data concerning a change to the user's token balances. */
+    tokenBalanceChanges: SimulationTokenBalanceChange[];
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/types.js b/dist/types.js
index 639f911e10b4c9092ad7a77f5dcba2c3a0c2f783..19b5cefaf5a796620c840034322746ea64edc7b2 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.SimulationTokenStandard = exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
  * in the wallet. Some of these correspond with the state of the transaction on the network, but
@@ -161,4 +161,11 @@ var UserFeeLevel;
     UserFeeLevel["DAPP_SUGGESTED"] = "dappSuggested";
     UserFeeLevel["MEDIUM"] = "medium";
 })(UserFeeLevel = exports.UserFeeLevel || (exports.UserFeeLevel = {}));
+/** Token standards supported by simulation. */
+var SimulationTokenStandard;
+(function (SimulationTokenStandard) {
+    SimulationTokenStandard["erc20"] = "erc20";
+    SimulationTokenStandard["erc721"] = "erc721";
+    SimulationTokenStandard["erc1155"] = "erc1155";
+})(SimulationTokenStandard = exports.SimulationTokenStandard || (exports.SimulationTokenStandard = {}));
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.d.ts b/dist/utils/simulation-api.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8389fcda31b6a36c7d04047f6ee197b45fde2f77
--- /dev/null
+++ b/dist/utils/simulation-api.d.ts
@@ -0,0 +1,66 @@
+import { type Hex } from '@metamask/utils';
+/** Single transaction to simulate in a simulation API request.  */
+export declare type SimulationRequestTransaction = {
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+/** Request to the simulation API to simulate transactions. */
+export declare type SimulationRequest = {
+    transactions: SimulationRequestTransaction[];
+    overrides?: {
+        [address: Hex]: {
+            stateDiff: {
+                [slot: Hex]: Hex;
+            };
+        };
+    };
+    withCallTrace?: boolean;
+    withLogs?: boolean;
+};
+/** Raw event log emitted by a simulated transaction. */
+export declare type SimulationLog = {
+    address: Hex;
+    data: Hex;
+    topics: Hex[];
+};
+/** Call trace of a single simulated transaction. */
+export declare type SimulationResponseCallTrace = {
+    calls: SimulationResponseCallTrace[];
+    logs: SimulationLog[];
+};
+/** Response from the simulation API. */
+export declare type SimulationResponse = {
+    transactions: {
+        return: Hex;
+        callTrace: SimulationResponseCallTrace;
+        stateDiff: {
+            pre: {
+                [address: Hex]: {
+                    balance?: Hex;
+                    nonce?: Hex;
+                    storage?: {
+                        [slot: Hex]: Hex;
+                    };
+                };
+            };
+            post: {
+                [address: Hex]: {
+                    balance?: Hex;
+                    nonce?: Hex;
+                    storage?: {
+                        [slot: Hex]: Hex;
+                    };
+                };
+            };
+        };
+    }[];
+};
+/**
+ * Simulate transactions using the transaction simulation API.
+ * @param chainId - The chain ID to simulate transactions on.
+ * @param request - The request to simulate transactions.
+ */
+export declare function simulateTransactions(chainId: Hex, request: SimulationRequest): Promise<SimulationResponse>;
+//# sourceMappingURL=simulation-api.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.js b/dist/utils/simulation-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..e6f0c1947c7d92a03db5a7acba89e79b4bf6059b
--- /dev/null
+++ b/dist/utils/simulation-api.js
@@ -0,0 +1,61 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.simulateTransactions = void 0;
+const providers_1 = require("@ethersproject/providers");
+const utils_1 = require("@metamask/utils");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation-api');
+const RPC_METHOD = 'infura_simulateTransactions';
+const BASE_URL = 'https://tx-sentinel-{0}.api.cx.metamask.io/';
+const SUBDOMAIN_BY_CHAIN_ID = {
+    [constants_1.CHAIN_IDS.MAINNET]: 'ethereum-mainnet',
+    [constants_1.CHAIN_IDS.GOERLI]: 'ethereum-goerli',
+    [constants_1.CHAIN_IDS.SEPOLIA]: 'ethereum-sepolia',
+    [constants_1.CHAIN_IDS.LINEA_MAINNET]: 'linea-mainnet',
+    [constants_1.CHAIN_IDS.LINEA_GOERLI]: 'linea-goerli',
+    [constants_1.CHAIN_IDS.ARBITRUM]: 'arbitrum-mainnet',
+    [constants_1.CHAIN_IDS.AVALANCHE]: 'avalanche-mainnet',
+    [constants_1.CHAIN_IDS.OPTIMISM]: 'optimism-mainnet',
+    [constants_1.CHAIN_IDS.POLYGON]: 'polygon-mainnet',
+    [constants_1.CHAIN_IDS.BSC]: 'bsc-mainnet',
+};
+/**
+ * Simulate transactions using the transaction simulation API.
+ * @param chainId - The chain ID to simulate transactions on.
+ * @param request - The request to simulate transactions.
+ */
+function simulateTransactions(chainId, request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const url = getUrl(chainId);
+        log('Sending request', url, request);
+        const jsonRpc = new providers_1.JsonRpcProvider(url);
+        const response = yield jsonRpc.send(RPC_METHOD, [request]);
+        log('Received response', response);
+        return response;
+    });
+}
+exports.simulateTransactions = simulateTransactions;
+/**
+ * Get the URL for the transaction simulation API.
+ * @param chainId - The chain ID to get the URL for.
+ * @returns The URL for the transaction simulation API.
+ */
+function getUrl(chainId) {
+    const subdomain = SUBDOMAIN_BY_CHAIN_ID[chainId];
+    if (!subdomain) {
+        log('Chain is not supported', chainId);
+        throw new Error(`Chain is not supported: ${chainId}`);
+    }
+    return BASE_URL.replace('{0}', subdomain);
+}
+//# sourceMappingURL=simulation-api.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.d.ts b/dist/utils/simulation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62f760ef2cfb9d88ced279e82527a04ef1c487ce
--- /dev/null
+++ b/dist/utils/simulation.d.ts
@@ -0,0 +1,21 @@
+import { type Hex } from '@metamask/utils';
+import type { SimulationData } from '../types';
+export declare type GetSimulationDataRequest = {
+    chainId: Hex;
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+/**
+ * Generate simulation data for a transaction.
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+export declare function getSimulationData(request: GetSimulationDataRequest): Promise<SimulationData | undefined>;
+//# sourceMappingURL=simulation.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e71e294956033dfc613ac51988be6f8b5b23f26
--- /dev/null
+++ b/dist/utils/simulation.js
@@ -0,0 +1,307 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getSimulationData = void 0;
+const abi_1 = require("@ethersproject/abi");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const simulation_api_1 = require("./simulation-api");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation');
+/**
+ * Generate simulation data for a transaction.
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+function getSimulationData(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, from, to, value, data } = request;
+        log('Getting simulation data', request);
+        try {
+            const response = yield (0, simulation_api_1.simulateTransactions)(chainId, {
+                transactions: [{ from, to, value, data }],
+                withCallTrace: true,
+                withLogs: true,
+            });
+            const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+            const events = getEvents(response);
+            log('Parsed events', events);
+            const tokenBalanceChanges = events.length
+                ? yield getTokenBalanceChanges(request, events)
+                : [];
+            return {
+                nativeBalanceChange,
+                tokenBalanceChanges,
+            };
+        }
+        catch (error) {
+            log('Failed to get simulation data', error, request);
+            return undefined;
+        }
+    });
+}
+exports.getSimulationData = getSimulationData;
+/**
+ * Extract the native balance change from a simulation response.
+ * @param userAddress - The user's account address.
+ * @param response - The simulation response.
+ * @returns The native balance change or undefined if unchanged.
+ */
+function getNativeBalanceChange(userAddress, response) {
+    var _a, _b, _c;
+    /* istanbul ignore next */
+    const { stateDiff } = (_a = response.transactions[0]) !== null && _a !== void 0 ? _a : {
+        stateDiff: { pre: {}, post: {} },
+    };
+    const previousBalance = (_b = stateDiff.pre[userAddress]) === null || _b === void 0 ? void 0 : _b.balance;
+    const newBalance = (_c = stateDiff.post[userAddress]) === null || _c === void 0 ? void 0 : _c.balance;
+    if (!previousBalance || !newBalance) {
+        return undefined;
+    }
+    return getSimulationBalanceChange(previousBalance, newBalance);
+}
+/**
+ * Extract events from a simulation response.
+ * @param response - The simulation response.
+ * @returns The parsed events.
+ */
+function getEvents(response) {
+    var _a, _b;
+    /* istanbul ignore next */
+    const logs = getLogs((_b = (_a = response.transactions[0]) === null || _a === void 0 ? void 0 : _a.callTrace) !== null && _b !== void 0 ? _b : {});
+    log('Extracted logs', logs);
+    const erc20Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+    const erc721Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC721);
+    const erc1155Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC1155);
+    return logs
+        .map((currentLog) => {
+        var _a;
+        const event = parseLog(currentLog, erc20Interface, erc721Interface, erc1155Interface);
+        if (!event) {
+            log('Failed to parse log', currentLog);
+            return undefined;
+        }
+        /* istanbul ignore next */
+        const inputs = (_a = event.abi.find((e) => e.name === event.name)) === null || _a === void 0 ? void 0 : _a.inputs;
+        /* istanbul ignore if */
+        if (!inputs) {
+            log('Failed to find inputs for event', event);
+            return undefined;
+        }
+        const args = parseEventArgs(event.args, inputs);
+        return {
+            contractAddress: currentLog.address,
+            tokenStandard: event.standard,
+            name: event.name,
+            data: args,
+            abi: event.abi,
+        };
+    })
+        .filter((e) => e !== undefined);
+}
+/**
+ * Parse event arguments using ABI input definitions.
+ * @param args - The raw event arguments.
+ * @param abiInputs - The ABI input definitions.
+ * @returns The parsed event arguments.
+ */
+function parseEventArgs(args, abiInputs) {
+    return args.reduce((result, arg, index) => {
+        const name = abiInputs[index].name.replace('_', '');
+        const value = parseEventArgValue(arg);
+        result[name] = value;
+        return result;
+    }, {});
+}
+/**
+ * Parse an event argument value.
+ * @param value - The event argument value.
+ * @returns The parsed event argument value.
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+function parseEventArgValue(value) {
+    if (Array.isArray(value)) {
+        return value.map(parseEventArgValue);
+    }
+    let parsedValue = value;
+    if (parsedValue.toHexString) {
+        parsedValue = value.toHexString();
+    }
+    return parsedValue.toLowerCase();
+}
+/**
+ * Generate token balance changes from parsed events.
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns An array of token balance changes.
+ */
+function getTokenBalanceChanges(request, events) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const balanceTransactionsByToken = getTokenBalanceTransactions(request, events);
+        const balanceTransactions = [...balanceTransactionsByToken.values()];
+        log('Generated balance transactions', balanceTransactions);
+        if (!balanceTransactions.length) {
+            return [];
+        }
+        const response = yield (0, simulation_api_1.simulateTransactions)(request.chainId, {
+            transactions: [...balanceTransactions, request, ...balanceTransactions],
+        });
+        if (response.transactions.length !== balanceTransactions.length * 2 + 1) {
+            throw new Error('Invalid response from simulation API');
+        }
+        log('Balance simulation response', response);
+        return [...balanceTransactionsByToken.keys()]
+            .map((token, index) => {
+            const previousBalance = response.transactions[index].return;
+            const newBalance = response.transactions[index + balanceTransactions.length + 1].return;
+            const balanceChange = getSimulationBalanceChange(previousBalance, newBalance);
+            if (!balanceChange) {
+                return undefined;
+            }
+            return Object.assign(Object.assign({}, token), balanceChange);
+        })
+            .filter((change) => change !== undefined);
+    });
+}
+/**
+ * Generate transactions to check token balances.
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns A map of token balance transactions keyed by token.
+ */
+function getTokenBalanceTransactions(request, events) {
+    const tokenKeys = new Set();
+    return events.reduce((result, event) => {
+        if (!['Transfer', 'TransferSingle', 'TransferBatch'].includes(event.name) ||
+            ![event.data.from, event.data.to].includes(request.from)) {
+            log('Ignoring event', event);
+            return result;
+        }
+        let tokenIds = [undefined];
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc721) {
+            tokenIds = [event.data.tokenId];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferSingle') {
+            tokenIds = [event.data.id];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferBatch') {
+            tokenIds = event.data.ids;
+        }
+        log('Extracted token ids', tokenIds);
+        for (const tokenId of tokenIds) {
+            const simulationToken = {
+                address: event.contractAddress,
+                standard: event.tokenStandard,
+                id: tokenId,
+            };
+            const tokenKey = JSON.stringify(simulationToken);
+            if (tokenKeys.has(tokenKey)) {
+                log('Ignoring additional event with same contract and token ID', simulationToken);
+                continue;
+            }
+            tokenKeys.add(tokenKey);
+            const parameters = [request.from];
+            if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155) {
+                parameters.push(tokenId);
+            }
+            result.set(simulationToken, {
+                from: request.from,
+                to: event.contractAddress,
+                data: new abi_1.Interface(event.abi).encodeFunctionData('balanceOf', parameters),
+            });
+        }
+        return result;
+    }, new Map());
+}
+/**
+ * Parse a raw event log using known ABIs.
+ * @param eventLog - The raw event log.
+ * @param erc20 - The ERC-20 ABI interface.
+ * @param erc721 - The ERC-721 ABI interface.
+ * @param erc1155 - The ERC-1155 ABI interface.
+ * @returns The parsed event log or undefined if it could not be parsed.
+ */
+function parseLog(eventLog, erc20, erc721, erc1155) {
+    const abisByStandard = [
+        {
+            abi: metamask_eth_abis_1.abiERC20,
+            contractInterface: erc20,
+            standard: types_1.SimulationTokenStandard.erc20,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC721,
+            contractInterface: erc721,
+            standard: types_1.SimulationTokenStandard.erc721,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC1155,
+            contractInterface: erc1155,
+            standard: types_1.SimulationTokenStandard.erc1155,
+        },
+    ];
+    for (const { abi, contractInterface, standard } of abisByStandard) {
+        try {
+            return Object.assign(Object.assign({}, contractInterface.parseLog(eventLog)), { abi,
+                standard });
+        }
+        catch (e) {
+            // Intentionally empty
+        }
+    }
+    return undefined;
+}
+/**
+ * Extract all logs from a call trace tree.
+ * @param call - The root call trace.
+ * @returns An array of logs.
+ */
+function getLogs(call) {
+    var _a, _b;
+    /* istanbul ignore next */
+    const logs = (_a = call.logs) !== null && _a !== void 0 ? _a : [];
+    /* istanbul ignore next */
+    const nestedCalls = (_b = call.calls) !== null && _b !== void 0 ? _b : [];
+    return [
+        ...logs,
+        ...nestedCalls.map((nestedCall) => getLogs(nestedCall)).flat(),
+    ];
+}
+/**
+ * Generate balance change data from previous and new balances.
+ * @param previousBalance - The previous balance.
+ * @param newBalance - The new balance.
+ * @returns The balance change data or undefined if unchanged.
+ */
+function getSimulationBalanceChange(previousBalance, newBalance) {
+    const differenceBN = (0, controller_utils_1.hexToBN)(newBalance).sub((0, controller_utils_1.hexToBN)(previousBalance));
+    const isDecrease = differenceBN.isNeg();
+    const difference = (0, controller_utils_1.toHex)(differenceBN.abs());
+    if (differenceBN.isZero()) {
+        log('Balance change is zero');
+        return undefined;
+    }
+    return {
+        previousBalance,
+        newBalance,
+        difference,
+        isDecrease,
+    };
+}
+//# sourceMappingURL=simulation.js.map
\ No newline at end of file
